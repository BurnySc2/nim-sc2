# Generated by protoc_gen_nim. Do not edit!

import base64
import intsets
import json
import strutils
import strformat

import nimpb/nimpb
import nimpb/json as nimpb_json

type
    Score_ScoreType* {.pure.} = enum
        Curriculum = 1
        Melee = 2
    Score* = ref ScoreObj
    ScoreObj* = object of Message
        scoreType: Score_ScoreType
        score: int32
        scoreDetails: ScoreDetails
    CategoryScoreDetails* = ref CategoryScoreDetailsObj
    CategoryScoreDetailsObj* = object of Message
        none: float32
        army: float32
        economy: float32
        technology: float32
        upgrade: float32
    VitalScoreDetails* = ref VitalScoreDetailsObj
    VitalScoreDetailsObj* = object of Message
        life: float32
        shields: float32
        energy: float32
    ScoreDetails* = ref ScoreDetailsObj
    ScoreDetailsObj* = object of Message
        idleProductionTime: float32
        idleWorkerTime: float32
        totalValueUnits: float32
        totalValueStructures: float32
        killedValueUnits: float32
        killedValueStructures: float32
        collectedMinerals: float32
        collectedVespene: float32
        collectionRateMinerals: float32
        collectionRateVespene: float32
        spentMinerals: float32
        spentVespene: float32
        foodUsed: CategoryScoreDetails
        killedMinerals: CategoryScoreDetails
        killedVespene: CategoryScoreDetails
        lostMinerals: CategoryScoreDetails
        lostVespene: CategoryScoreDetails
        friendlyFireMinerals: CategoryScoreDetails
        friendlyFireVespene: CategoryScoreDetails
        usedMinerals: CategoryScoreDetails
        usedVespene: CategoryScoreDetails
        totalUsedMinerals: CategoryScoreDetails
        totalUsedVespene: CategoryScoreDetails
        totalDamageDealt: VitalScoreDetails
        totalDamageTaken: VitalScoreDetails
        totalHealed: VitalScoreDetails
        currentApm: float32
        currentEffectiveApm: float32

proc newCategoryScoreDetails*(): CategoryScoreDetails
proc newCategoryScoreDetails*(data: string): CategoryScoreDetails
proc newCategoryScoreDetails*(data: seq[byte]): CategoryScoreDetails
proc writeCategoryScoreDetails*(stream: Stream, message: CategoryScoreDetails)
proc readCategoryScoreDetails*(stream: Stream): CategoryScoreDetails
proc sizeOfCategoryScoreDetails*(message: CategoryScoreDetails): uint64

proc newVitalScoreDetails*(): VitalScoreDetails
proc newVitalScoreDetails*(data: string): VitalScoreDetails
proc newVitalScoreDetails*(data: seq[byte]): VitalScoreDetails
proc writeVitalScoreDetails*(stream: Stream, message: VitalScoreDetails)
proc readVitalScoreDetails*(stream: Stream): VitalScoreDetails
proc sizeOfVitalScoreDetails*(message: VitalScoreDetails): uint64

proc newScoreDetails*(): ScoreDetails
proc newScoreDetails*(data: string): ScoreDetails
proc newScoreDetails*(data: seq[byte]): ScoreDetails
proc writeScoreDetails*(stream: Stream, message: ScoreDetails)
proc readScoreDetails*(stream: Stream): ScoreDetails
proc sizeOfScoreDetails*(message: ScoreDetails): uint64

proc newScore*(): Score
proc newScore*(data: string): Score
proc newScore*(data: seq[byte]): Score
proc writeScore*(stream: Stream, message: Score)
proc readScore*(stream: Stream): Score
proc sizeOfScore*(message: Score): uint64

proc fullyQualifiedName*(T: typedesc[CategoryScoreDetails]): string = "CategoryScoreDetails"

proc readCategoryScoreDetailsImpl(stream: Stream): Message = readCategoryScoreDetails(stream)
proc writeCategoryScoreDetailsImpl(stream: Stream, msg: Message) = writeCategoryScoreDetails(stream, CategoryScoreDetails(msg))

proc CategoryScoreDetailsProcs*(): MessageProcs =
    result.readImpl = readCategoryScoreDetailsImpl
    result.writeImpl = writeCategoryScoreDetailsImpl

proc newCategoryScoreDetails*(): CategoryScoreDetails =
    new(result)
    initMessage(result[])
    result.procs = CategoryScoreDetailsProcs()
    result.none = 0
    result.army = 0
    result.economy = 0
    result.technology = 0
    result.upgrade = 0

proc clearnone*(message: CategoryScoreDetails) =
    message.none = 0
    clearFields(message, [1])

proc hasnone*(message: CategoryScoreDetails): bool =
    result = hasField(message, 1)

proc setnone*(message: CategoryScoreDetails, value: float32) =
    message.none = value
    setField(message, 1)

proc none*(message: CategoryScoreDetails): float32 {.inline.} =
    message.none

proc `none=`*(message: CategoryScoreDetails, value: float32) {.inline.} =
    setnone(message, value)

proc cleararmy*(message: CategoryScoreDetails) =
    message.army = 0
    clearFields(message, [2])

proc hasarmy*(message: CategoryScoreDetails): bool =
    result = hasField(message, 2)

proc setarmy*(message: CategoryScoreDetails, value: float32) =
    message.army = value
    setField(message, 2)

proc army*(message: CategoryScoreDetails): float32 {.inline.} =
    message.army

proc `army=`*(message: CategoryScoreDetails, value: float32) {.inline.} =
    setarmy(message, value)

proc cleareconomy*(message: CategoryScoreDetails) =
    message.economy = 0
    clearFields(message, [3])

proc haseconomy*(message: CategoryScoreDetails): bool =
    result = hasField(message, 3)

proc seteconomy*(message: CategoryScoreDetails, value: float32) =
    message.economy = value
    setField(message, 3)

proc economy*(message: CategoryScoreDetails): float32 {.inline.} =
    message.economy

proc `economy=`*(message: CategoryScoreDetails, value: float32) {.inline.} =
    seteconomy(message, value)

proc cleartechnology*(message: CategoryScoreDetails) =
    message.technology = 0
    clearFields(message, [4])

proc hastechnology*(message: CategoryScoreDetails): bool =
    result = hasField(message, 4)

proc settechnology*(message: CategoryScoreDetails, value: float32) =
    message.technology = value
    setField(message, 4)

proc technology*(message: CategoryScoreDetails): float32 {.inline.} =
    message.technology

proc `technology=`*(message: CategoryScoreDetails, value: float32) {.inline.} =
    settechnology(message, value)

proc clearupgrade*(message: CategoryScoreDetails) =
    message.upgrade = 0
    clearFields(message, [5])

proc hasupgrade*(message: CategoryScoreDetails): bool =
    result = hasField(message, 5)

proc setupgrade*(message: CategoryScoreDetails, value: float32) =
    message.upgrade = value
    setField(message, 5)

proc upgrade*(message: CategoryScoreDetails): float32 {.inline.} =
    message.upgrade

proc `upgrade=`*(message: CategoryScoreDetails, value: float32) {.inline.} =
    setupgrade(message, value)

proc `$`*(message: CategoryScoreDetails): string =
    runnableExamples:
        echo $CategoryScoreDetails
        echo fmt"{CategoryScoreDetails}"
        echo &"{CategoryScoreDetails}"
    var resultSeq: seq[string]
    if message.hasnone:
        resultSeq.add(&"none: {message.none}")
    if message.hasarmy:
        resultSeq.add(&"army: {message.army}")
    if message.haseconomy:
        resultSeq.add(&"economy: {message.economy}")
    if message.hastechnology:
        resultSeq.add(&"technology: {message.technology}")
    if message.hasupgrade:
        resultSeq.add(&"upgrade: {message.upgrade}")
    result = resultSeq.join(", ")
    result = &"CategoryScoreDetails({result})"

proc sizeOfCategoryScoreDetails*(message: CategoryScoreDetails): uint64 =
    if hasnone(message):
        result = result + sizeOfTag(1, WireType.Fixed32)
        result = result + sizeOfFloat(message.none)
    if hasarmy(message):
        result = result + sizeOfTag(2, WireType.Fixed32)
        result = result + sizeOfFloat(message.army)
    if haseconomy(message):
        result = result + sizeOfTag(3, WireType.Fixed32)
        result = result + sizeOfFloat(message.economy)
    if hastechnology(message):
        result = result + sizeOfTag(4, WireType.Fixed32)
        result = result + sizeOfFloat(message.technology)
    if hasupgrade(message):
        result = result + sizeOfTag(5, WireType.Fixed32)
        result = result + sizeOfFloat(message.upgrade)
    result = result + sizeOfUnknownFields(message)

proc writeCategoryScoreDetails*(stream: Stream, message: CategoryScoreDetails) =
    if hasnone(message):
        protoWriteFloat(stream, message.none, 1)
    if hasarmy(message):
        protoWriteFloat(stream, message.army, 2)
    if haseconomy(message):
        protoWriteFloat(stream, message.economy, 3)
    if hastechnology(message):
        protoWriteFloat(stream, message.technology, 4)
    if hasupgrade(message):
        protoWriteFloat(stream, message.upgrade, 5)
    writeUnknownFields(stream, message)

proc readCategoryScoreDetails*(stream: Stream): CategoryScoreDetails =
    result = newCategoryScoreDetails()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Fixed32)
            setnone(result, protoReadFloat(stream))
        of 2:
            expectWireType(wireType, WireType.Fixed32)
            setarmy(result, protoReadFloat(stream))
        of 3:
            expectWireType(wireType, WireType.Fixed32)
            seteconomy(result, protoReadFloat(stream))
        of 4:
            expectWireType(wireType, WireType.Fixed32)
            settechnology(result, protoReadFloat(stream))
        of 5:
            expectWireType(wireType, WireType.Fixed32)
            setupgrade(result, protoReadFloat(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: CategoryScoreDetails): string =
    let
        ss = newStringStream()
    writeCategoryScoreDetails(ss, message)
    result = ss.data

proc newCategoryScoreDetails*(data: string): CategoryScoreDetails =
    let
        ss = newStringStream(data)
    result = readCategoryScoreDetails(ss)

proc newCategoryScoreDetails*(data: seq[byte]): CategoryScoreDetails =
    let
        ss = newStringStream(cast[string](data))
    result = readCategoryScoreDetails(ss)


proc fullyQualifiedName*(T: typedesc[VitalScoreDetails]): string = "VitalScoreDetails"

proc readVitalScoreDetailsImpl(stream: Stream): Message = readVitalScoreDetails(stream)
proc writeVitalScoreDetailsImpl(stream: Stream, msg: Message) = writeVitalScoreDetails(stream, VitalScoreDetails(msg))

proc VitalScoreDetailsProcs*(): MessageProcs =
    result.readImpl = readVitalScoreDetailsImpl
    result.writeImpl = writeVitalScoreDetailsImpl

proc newVitalScoreDetails*(): VitalScoreDetails =
    new(result)
    initMessage(result[])
    result.procs = VitalScoreDetailsProcs()
    result.life = 0
    result.shields = 0
    result.energy = 0

proc clearlife*(message: VitalScoreDetails) =
    message.life = 0
    clearFields(message, [1])

proc haslife*(message: VitalScoreDetails): bool =
    result = hasField(message, 1)

proc setlife*(message: VitalScoreDetails, value: float32) =
    message.life = value
    setField(message, 1)

proc life*(message: VitalScoreDetails): float32 {.inline.} =
    message.life

proc `life=`*(message: VitalScoreDetails, value: float32) {.inline.} =
    setlife(message, value)

proc clearshields*(message: VitalScoreDetails) =
    message.shields = 0
    clearFields(message, [2])

proc hasshields*(message: VitalScoreDetails): bool =
    result = hasField(message, 2)

proc setshields*(message: VitalScoreDetails, value: float32) =
    message.shields = value
    setField(message, 2)

proc shields*(message: VitalScoreDetails): float32 {.inline.} =
    message.shields

proc `shields=`*(message: VitalScoreDetails, value: float32) {.inline.} =
    setshields(message, value)

proc clearenergy*(message: VitalScoreDetails) =
    message.energy = 0
    clearFields(message, [3])

proc hasenergy*(message: VitalScoreDetails): bool =
    result = hasField(message, 3)

proc setenergy*(message: VitalScoreDetails, value: float32) =
    message.energy = value
    setField(message, 3)

proc energy*(message: VitalScoreDetails): float32 {.inline.} =
    message.energy

proc `energy=`*(message: VitalScoreDetails, value: float32) {.inline.} =
    setenergy(message, value)

proc `$`*(message: VitalScoreDetails): string =
    runnableExamples:
        echo $VitalScoreDetails
        echo fmt"{VitalScoreDetails}"
        echo &"{VitalScoreDetails}"
    var resultSeq: seq[string]
    if message.haslife:
        resultSeq.add(&"life: {message.life}")
    if message.hasshields:
        resultSeq.add(&"shields: {message.shields}")
    if message.hasenergy:
        resultSeq.add(&"energy: {message.energy}")
    result = resultSeq.join(", ")
    result = &"VitalScoreDetails({result})"

proc sizeOfVitalScoreDetails*(message: VitalScoreDetails): uint64 =
    if haslife(message):
        result = result + sizeOfTag(1, WireType.Fixed32)
        result = result + sizeOfFloat(message.life)
    if hasshields(message):
        result = result + sizeOfTag(2, WireType.Fixed32)
        result = result + sizeOfFloat(message.shields)
    if hasenergy(message):
        result = result + sizeOfTag(3, WireType.Fixed32)
        result = result + sizeOfFloat(message.energy)
    result = result + sizeOfUnknownFields(message)

proc writeVitalScoreDetails*(stream: Stream, message: VitalScoreDetails) =
    if haslife(message):
        protoWriteFloat(stream, message.life, 1)
    if hasshields(message):
        protoWriteFloat(stream, message.shields, 2)
    if hasenergy(message):
        protoWriteFloat(stream, message.energy, 3)
    writeUnknownFields(stream, message)

proc readVitalScoreDetails*(stream: Stream): VitalScoreDetails =
    result = newVitalScoreDetails()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Fixed32)
            setlife(result, protoReadFloat(stream))
        of 2:
            expectWireType(wireType, WireType.Fixed32)
            setshields(result, protoReadFloat(stream))
        of 3:
            expectWireType(wireType, WireType.Fixed32)
            setenergy(result, protoReadFloat(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: VitalScoreDetails): string =
    let
        ss = newStringStream()
    writeVitalScoreDetails(ss, message)
    result = ss.data

proc newVitalScoreDetails*(data: string): VitalScoreDetails =
    let
        ss = newStringStream(data)
    result = readVitalScoreDetails(ss)

proc newVitalScoreDetails*(data: seq[byte]): VitalScoreDetails =
    let
        ss = newStringStream(cast[string](data))
    result = readVitalScoreDetails(ss)


proc fullyQualifiedName*(T: typedesc[ScoreDetails]): string = "ScoreDetails"

proc readScoreDetailsImpl(stream: Stream): Message = readScoreDetails(stream)
proc writeScoreDetailsImpl(stream: Stream, msg: Message) = writeScoreDetails(stream, ScoreDetails(msg))

proc ScoreDetailsProcs*(): MessageProcs =
    result.readImpl = readScoreDetailsImpl
    result.writeImpl = writeScoreDetailsImpl

proc newScoreDetails*(): ScoreDetails =
    new(result)
    initMessage(result[])
    result.procs = ScoreDetailsProcs()
    result.idleProductionTime = 0
    result.idleWorkerTime = 0
    result.totalValueUnits = 0
    result.totalValueStructures = 0
    result.killedValueUnits = 0
    result.killedValueStructures = 0
    result.collectedMinerals = 0
    result.collectedVespene = 0
    result.collectionRateMinerals = 0
    result.collectionRateVespene = 0
    result.spentMinerals = 0
    result.spentVespene = 0
    result.foodUsed = nil
    result.killedMinerals = nil
    result.killedVespene = nil
    result.lostMinerals = nil
    result.lostVespene = nil
    result.friendlyFireMinerals = nil
    result.friendlyFireVespene = nil
    result.usedMinerals = nil
    result.usedVespene = nil
    result.totalUsedMinerals = nil
    result.totalUsedVespene = nil
    result.totalDamageDealt = nil
    result.totalDamageTaken = nil
    result.totalHealed = nil
    result.currentApm = 0
    result.currentEffectiveApm = 0

proc clearidleProductionTime*(message: ScoreDetails) =
    message.idleProductionTime = 0
    clearFields(message, [1])

proc hasidleProductionTime*(message: ScoreDetails): bool =
    result = hasField(message, 1)

proc setidleProductionTime*(message: ScoreDetails, value: float32) =
    message.idleProductionTime = value
    setField(message, 1)

proc idleProductionTime*(message: ScoreDetails): float32 {.inline.} =
    message.idleProductionTime

proc `idleProductionTime=`*(message: ScoreDetails, value: float32) {.inline.} =
    setidleProductionTime(message, value)

proc clearidleWorkerTime*(message: ScoreDetails) =
    message.idleWorkerTime = 0
    clearFields(message, [2])

proc hasidleWorkerTime*(message: ScoreDetails): bool =
    result = hasField(message, 2)

proc setidleWorkerTime*(message: ScoreDetails, value: float32) =
    message.idleWorkerTime = value
    setField(message, 2)

proc idleWorkerTime*(message: ScoreDetails): float32 {.inline.} =
    message.idleWorkerTime

proc `idleWorkerTime=`*(message: ScoreDetails, value: float32) {.inline.} =
    setidleWorkerTime(message, value)

proc cleartotalValueUnits*(message: ScoreDetails) =
    message.totalValueUnits = 0
    clearFields(message, [3])

proc hastotalValueUnits*(message: ScoreDetails): bool =
    result = hasField(message, 3)

proc settotalValueUnits*(message: ScoreDetails, value: float32) =
    message.totalValueUnits = value
    setField(message, 3)

proc totalValueUnits*(message: ScoreDetails): float32 {.inline.} =
    message.totalValueUnits

proc `totalValueUnits=`*(message: ScoreDetails, value: float32) {.inline.} =
    settotalValueUnits(message, value)

proc cleartotalValueStructures*(message: ScoreDetails) =
    message.totalValueStructures = 0
    clearFields(message, [4])

proc hastotalValueStructures*(message: ScoreDetails): bool =
    result = hasField(message, 4)

proc settotalValueStructures*(message: ScoreDetails, value: float32) =
    message.totalValueStructures = value
    setField(message, 4)

proc totalValueStructures*(message: ScoreDetails): float32 {.inline.} =
    message.totalValueStructures

proc `totalValueStructures=`*(message: ScoreDetails, value: float32) {.inline.} =
    settotalValueStructures(message, value)

proc clearkilledValueUnits*(message: ScoreDetails) =
    message.killedValueUnits = 0
    clearFields(message, [5])

proc haskilledValueUnits*(message: ScoreDetails): bool =
    result = hasField(message, 5)

proc setkilledValueUnits*(message: ScoreDetails, value: float32) =
    message.killedValueUnits = value
    setField(message, 5)

proc killedValueUnits*(message: ScoreDetails): float32 {.inline.} =
    message.killedValueUnits

proc `killedValueUnits=`*(message: ScoreDetails, value: float32) {.inline.} =
    setkilledValueUnits(message, value)

proc clearkilledValueStructures*(message: ScoreDetails) =
    message.killedValueStructures = 0
    clearFields(message, [6])

proc haskilledValueStructures*(message: ScoreDetails): bool =
    result = hasField(message, 6)

proc setkilledValueStructures*(message: ScoreDetails, value: float32) =
    message.killedValueStructures = value
    setField(message, 6)

proc killedValueStructures*(message: ScoreDetails): float32 {.inline.} =
    message.killedValueStructures

proc `killedValueStructures=`*(message: ScoreDetails, value: float32) {.inline.} =
    setkilledValueStructures(message, value)

proc clearcollectedMinerals*(message: ScoreDetails) =
    message.collectedMinerals = 0
    clearFields(message, [7])

proc hascollectedMinerals*(message: ScoreDetails): bool =
    result = hasField(message, 7)

proc setcollectedMinerals*(message: ScoreDetails, value: float32) =
    message.collectedMinerals = value
    setField(message, 7)

proc collectedMinerals*(message: ScoreDetails): float32 {.inline.} =
    message.collectedMinerals

proc `collectedMinerals=`*(message: ScoreDetails, value: float32) {.inline.} =
    setcollectedMinerals(message, value)

proc clearcollectedVespene*(message: ScoreDetails) =
    message.collectedVespene = 0
    clearFields(message, [8])

proc hascollectedVespene*(message: ScoreDetails): bool =
    result = hasField(message, 8)

proc setcollectedVespene*(message: ScoreDetails, value: float32) =
    message.collectedVespene = value
    setField(message, 8)

proc collectedVespene*(message: ScoreDetails): float32 {.inline.} =
    message.collectedVespene

proc `collectedVespene=`*(message: ScoreDetails, value: float32) {.inline.} =
    setcollectedVespene(message, value)

proc clearcollectionRateMinerals*(message: ScoreDetails) =
    message.collectionRateMinerals = 0
    clearFields(message, [9])

proc hascollectionRateMinerals*(message: ScoreDetails): bool =
    result = hasField(message, 9)

proc setcollectionRateMinerals*(message: ScoreDetails, value: float32) =
    message.collectionRateMinerals = value
    setField(message, 9)

proc collectionRateMinerals*(message: ScoreDetails): float32 {.inline.} =
    message.collectionRateMinerals

proc `collectionRateMinerals=`*(message: ScoreDetails, value: float32) {.inline.} =
    setcollectionRateMinerals(message, value)

proc clearcollectionRateVespene*(message: ScoreDetails) =
    message.collectionRateVespene = 0
    clearFields(message, [10])

proc hascollectionRateVespene*(message: ScoreDetails): bool =
    result = hasField(message, 10)

proc setcollectionRateVespene*(message: ScoreDetails, value: float32) =
    message.collectionRateVespene = value
    setField(message, 10)

proc collectionRateVespene*(message: ScoreDetails): float32 {.inline.} =
    message.collectionRateVespene

proc `collectionRateVespene=`*(message: ScoreDetails, value: float32) {.inline.} =
    setcollectionRateVespene(message, value)

proc clearspentMinerals*(message: ScoreDetails) =
    message.spentMinerals = 0
    clearFields(message, [11])

proc hasspentMinerals*(message: ScoreDetails): bool =
    result = hasField(message, 11)

proc setspentMinerals*(message: ScoreDetails, value: float32) =
    message.spentMinerals = value
    setField(message, 11)

proc spentMinerals*(message: ScoreDetails): float32 {.inline.} =
    message.spentMinerals

proc `spentMinerals=`*(message: ScoreDetails, value: float32) {.inline.} =
    setspentMinerals(message, value)

proc clearspentVespene*(message: ScoreDetails) =
    message.spentVespene = 0
    clearFields(message, [12])

proc hasspentVespene*(message: ScoreDetails): bool =
    result = hasField(message, 12)

proc setspentVespene*(message: ScoreDetails, value: float32) =
    message.spentVespene = value
    setField(message, 12)

proc spentVespene*(message: ScoreDetails): float32 {.inline.} =
    message.spentVespene

proc `spentVespene=`*(message: ScoreDetails, value: float32) {.inline.} =
    setspentVespene(message, value)

proc clearfoodUsed*(message: ScoreDetails) =
    message.foodUsed = nil
    clearFields(message, [13])

proc hasfoodUsed*(message: ScoreDetails): bool =
    result = hasField(message, 13)

proc setfoodUsed*(message: ScoreDetails, value: CategoryScoreDetails) =
    message.foodUsed = value
    setField(message, 13)

proc foodUsed*(message: ScoreDetails): CategoryScoreDetails {.inline.} =
    message.foodUsed

proc `foodUsed=`*(message: ScoreDetails, value: CategoryScoreDetails) {.inline.} =
    setfoodUsed(message, value)

proc clearkilledMinerals*(message: ScoreDetails) =
    message.killedMinerals = nil
    clearFields(message, [14])

proc haskilledMinerals*(message: ScoreDetails): bool =
    result = hasField(message, 14)

proc setkilledMinerals*(message: ScoreDetails, value: CategoryScoreDetails) =
    message.killedMinerals = value
    setField(message, 14)

proc killedMinerals*(message: ScoreDetails): CategoryScoreDetails {.inline.} =
    message.killedMinerals

proc `killedMinerals=`*(message: ScoreDetails, value: CategoryScoreDetails) {.inline.} =
    setkilledMinerals(message, value)

proc clearkilledVespene*(message: ScoreDetails) =
    message.killedVespene = nil
    clearFields(message, [15])

proc haskilledVespene*(message: ScoreDetails): bool =
    result = hasField(message, 15)

proc setkilledVespene*(message: ScoreDetails, value: CategoryScoreDetails) =
    message.killedVespene = value
    setField(message, 15)

proc killedVespene*(message: ScoreDetails): CategoryScoreDetails {.inline.} =
    message.killedVespene

proc `killedVespene=`*(message: ScoreDetails, value: CategoryScoreDetails) {.inline.} =
    setkilledVespene(message, value)

proc clearlostMinerals*(message: ScoreDetails) =
    message.lostMinerals = nil
    clearFields(message, [16])

proc haslostMinerals*(message: ScoreDetails): bool =
    result = hasField(message, 16)

proc setlostMinerals*(message: ScoreDetails, value: CategoryScoreDetails) =
    message.lostMinerals = value
    setField(message, 16)

proc lostMinerals*(message: ScoreDetails): CategoryScoreDetails {.inline.} =
    message.lostMinerals

proc `lostMinerals=`*(message: ScoreDetails, value: CategoryScoreDetails) {.inline.} =
    setlostMinerals(message, value)

proc clearlostVespene*(message: ScoreDetails) =
    message.lostVespene = nil
    clearFields(message, [17])

proc haslostVespene*(message: ScoreDetails): bool =
    result = hasField(message, 17)

proc setlostVespene*(message: ScoreDetails, value: CategoryScoreDetails) =
    message.lostVespene = value
    setField(message, 17)

proc lostVespene*(message: ScoreDetails): CategoryScoreDetails {.inline.} =
    message.lostVespene

proc `lostVespene=`*(message: ScoreDetails, value: CategoryScoreDetails) {.inline.} =
    setlostVespene(message, value)

proc clearfriendlyFireMinerals*(message: ScoreDetails) =
    message.friendlyFireMinerals = nil
    clearFields(message, [18])

proc hasfriendlyFireMinerals*(message: ScoreDetails): bool =
    result = hasField(message, 18)

proc setfriendlyFireMinerals*(message: ScoreDetails, value: CategoryScoreDetails) =
    message.friendlyFireMinerals = value
    setField(message, 18)

proc friendlyFireMinerals*(message: ScoreDetails): CategoryScoreDetails {.inline.} =
    message.friendlyFireMinerals

proc `friendlyFireMinerals=`*(message: ScoreDetails, value: CategoryScoreDetails) {.inline.} =
    setfriendlyFireMinerals(message, value)

proc clearfriendlyFireVespene*(message: ScoreDetails) =
    message.friendlyFireVespene = nil
    clearFields(message, [19])

proc hasfriendlyFireVespene*(message: ScoreDetails): bool =
    result = hasField(message, 19)

proc setfriendlyFireVespene*(message: ScoreDetails, value: CategoryScoreDetails) =
    message.friendlyFireVespene = value
    setField(message, 19)

proc friendlyFireVespene*(message: ScoreDetails): CategoryScoreDetails {.inline.} =
    message.friendlyFireVespene

proc `friendlyFireVespene=`*(message: ScoreDetails, value: CategoryScoreDetails) {.inline.} =
    setfriendlyFireVespene(message, value)

proc clearusedMinerals*(message: ScoreDetails) =
    message.usedMinerals = nil
    clearFields(message, [20])

proc hasusedMinerals*(message: ScoreDetails): bool =
    result = hasField(message, 20)

proc setusedMinerals*(message: ScoreDetails, value: CategoryScoreDetails) =
    message.usedMinerals = value
    setField(message, 20)

proc usedMinerals*(message: ScoreDetails): CategoryScoreDetails {.inline.} =
    message.usedMinerals

proc `usedMinerals=`*(message: ScoreDetails, value: CategoryScoreDetails) {.inline.} =
    setusedMinerals(message, value)

proc clearusedVespene*(message: ScoreDetails) =
    message.usedVespene = nil
    clearFields(message, [21])

proc hasusedVespene*(message: ScoreDetails): bool =
    result = hasField(message, 21)

proc setusedVespene*(message: ScoreDetails, value: CategoryScoreDetails) =
    message.usedVespene = value
    setField(message, 21)

proc usedVespene*(message: ScoreDetails): CategoryScoreDetails {.inline.} =
    message.usedVespene

proc `usedVespene=`*(message: ScoreDetails, value: CategoryScoreDetails) {.inline.} =
    setusedVespene(message, value)

proc cleartotalUsedMinerals*(message: ScoreDetails) =
    message.totalUsedMinerals = nil
    clearFields(message, [22])

proc hastotalUsedMinerals*(message: ScoreDetails): bool =
    result = hasField(message, 22)

proc settotalUsedMinerals*(message: ScoreDetails, value: CategoryScoreDetails) =
    message.totalUsedMinerals = value
    setField(message, 22)

proc totalUsedMinerals*(message: ScoreDetails): CategoryScoreDetails {.inline.} =
    message.totalUsedMinerals

proc `totalUsedMinerals=`*(message: ScoreDetails, value: CategoryScoreDetails) {.inline.} =
    settotalUsedMinerals(message, value)

proc cleartotalUsedVespene*(message: ScoreDetails) =
    message.totalUsedVespene = nil
    clearFields(message, [23])

proc hastotalUsedVespene*(message: ScoreDetails): bool =
    result = hasField(message, 23)

proc settotalUsedVespene*(message: ScoreDetails, value: CategoryScoreDetails) =
    message.totalUsedVespene = value
    setField(message, 23)

proc totalUsedVespene*(message: ScoreDetails): CategoryScoreDetails {.inline.} =
    message.totalUsedVespene

proc `totalUsedVespene=`*(message: ScoreDetails, value: CategoryScoreDetails) {.inline.} =
    settotalUsedVespene(message, value)

proc cleartotalDamageDealt*(message: ScoreDetails) =
    message.totalDamageDealt = nil
    clearFields(message, [24])

proc hastotalDamageDealt*(message: ScoreDetails): bool =
    result = hasField(message, 24)

proc settotalDamageDealt*(message: ScoreDetails, value: VitalScoreDetails) =
    message.totalDamageDealt = value
    setField(message, 24)

proc totalDamageDealt*(message: ScoreDetails): VitalScoreDetails {.inline.} =
    message.totalDamageDealt

proc `totalDamageDealt=`*(message: ScoreDetails, value: VitalScoreDetails) {.inline.} =
    settotalDamageDealt(message, value)

proc cleartotalDamageTaken*(message: ScoreDetails) =
    message.totalDamageTaken = nil
    clearFields(message, [25])

proc hastotalDamageTaken*(message: ScoreDetails): bool =
    result = hasField(message, 25)

proc settotalDamageTaken*(message: ScoreDetails, value: VitalScoreDetails) =
    message.totalDamageTaken = value
    setField(message, 25)

proc totalDamageTaken*(message: ScoreDetails): VitalScoreDetails {.inline.} =
    message.totalDamageTaken

proc `totalDamageTaken=`*(message: ScoreDetails, value: VitalScoreDetails) {.inline.} =
    settotalDamageTaken(message, value)

proc cleartotalHealed*(message: ScoreDetails) =
    message.totalHealed = nil
    clearFields(message, [26])

proc hastotalHealed*(message: ScoreDetails): bool =
    result = hasField(message, 26)

proc settotalHealed*(message: ScoreDetails, value: VitalScoreDetails) =
    message.totalHealed = value
    setField(message, 26)

proc totalHealed*(message: ScoreDetails): VitalScoreDetails {.inline.} =
    message.totalHealed

proc `totalHealed=`*(message: ScoreDetails, value: VitalScoreDetails) {.inline.} =
    settotalHealed(message, value)

proc clearcurrentApm*(message: ScoreDetails) =
    message.currentApm = 0
    clearFields(message, [27])

proc hascurrentApm*(message: ScoreDetails): bool =
    result = hasField(message, 27)

proc setcurrentApm*(message: ScoreDetails, value: float32) =
    message.currentApm = value
    setField(message, 27)

proc currentApm*(message: ScoreDetails): float32 {.inline.} =
    message.currentApm

proc `currentApm=`*(message: ScoreDetails, value: float32) {.inline.} =
    setcurrentApm(message, value)

proc clearcurrentEffectiveApm*(message: ScoreDetails) =
    message.currentEffectiveApm = 0
    clearFields(message, [28])

proc hascurrentEffectiveApm*(message: ScoreDetails): bool =
    result = hasField(message, 28)

proc setcurrentEffectiveApm*(message: ScoreDetails, value: float32) =
    message.currentEffectiveApm = value
    setField(message, 28)

proc currentEffectiveApm*(message: ScoreDetails): float32 {.inline.} =
    message.currentEffectiveApm

proc `currentEffectiveApm=`*(message: ScoreDetails, value: float32) {.inline.} =
    setcurrentEffectiveApm(message, value)

proc `$`*(message: ScoreDetails): string =
    runnableExamples:
        echo $ScoreDetails
        echo fmt"{ScoreDetails}"
        echo &"{ScoreDetails}"
    var resultSeq: seq[string]
    if message.hasidleProductionTime:
        resultSeq.add(&"idleProductionTime: {message.idleProductionTime}")
    if message.hasidleWorkerTime:
        resultSeq.add(&"idleWorkerTime: {message.idleWorkerTime}")
    if message.hastotalValueUnits:
        resultSeq.add(&"totalValueUnits: {message.totalValueUnits}")
    if message.hastotalValueStructures:
        resultSeq.add(&"totalValueStructures: {message.totalValueStructures}")
    if message.haskilledValueUnits:
        resultSeq.add(&"killedValueUnits: {message.killedValueUnits}")
    if message.haskilledValueStructures:
        resultSeq.add(&"killedValueStructures: {message.killedValueStructures}")
    if message.hascollectedMinerals:
        resultSeq.add(&"collectedMinerals: {message.collectedMinerals}")
    if message.hascollectedVespene:
        resultSeq.add(&"collectedVespene: {message.collectedVespene}")
    if message.hascollectionRateMinerals:
        resultSeq.add(&"collectionRateMinerals: {message.collectionRateMinerals}")
    if message.hascollectionRateVespene:
        resultSeq.add(&"collectionRateVespene: {message.collectionRateVespene}")
    if message.hasspentMinerals:
        resultSeq.add(&"spentMinerals: {message.spentMinerals}")
    if message.hasspentVespene:
        resultSeq.add(&"spentVespene: {message.spentVespene}")
    if message.hasfoodUsed:
        resultSeq.add(&"foodUsed: {message.foodUsed}")
    if message.haskilledMinerals:
        resultSeq.add(&"killedMinerals: {message.killedMinerals}")
    if message.haskilledVespene:
        resultSeq.add(&"killedVespene: {message.killedVespene}")
    if message.haslostMinerals:
        resultSeq.add(&"lostMinerals: {message.lostMinerals}")
    if message.haslostVespene:
        resultSeq.add(&"lostVespene: {message.lostVespene}")
    if message.hasfriendlyFireMinerals:
        resultSeq.add(&"friendlyFireMinerals: {message.friendlyFireMinerals}")
    if message.hasfriendlyFireVespene:
        resultSeq.add(&"friendlyFireVespene: {message.friendlyFireVespene}")
    if message.hasusedMinerals:
        resultSeq.add(&"usedMinerals: {message.usedMinerals}")
    if message.hasusedVespene:
        resultSeq.add(&"usedVespene: {message.usedVespene}")
    if message.hastotalUsedMinerals:
        resultSeq.add(&"totalUsedMinerals: {message.totalUsedMinerals}")
    if message.hastotalUsedVespene:
        resultSeq.add(&"totalUsedVespene: {message.totalUsedVespene}")
    if message.hastotalDamageDealt:
        resultSeq.add(&"totalDamageDealt: {message.totalDamageDealt}")
    if message.hastotalDamageTaken:
        resultSeq.add(&"totalDamageTaken: {message.totalDamageTaken}")
    if message.hastotalHealed:
        resultSeq.add(&"totalHealed: {message.totalHealed}")
    if message.hascurrentApm:
        resultSeq.add(&"currentApm: {message.currentApm}")
    if message.hascurrentEffectiveApm:
        resultSeq.add(&"currentEffectiveApm: {message.currentEffectiveApm}")
    result = resultSeq.join(", ")
    result = &"ScoreDetails({result})"

proc sizeOfScoreDetails*(message: ScoreDetails): uint64 =
    if hasidleProductionTime(message):
        result = result + sizeOfTag(1, WireType.Fixed32)
        result = result + sizeOfFloat(message.idleProductionTime)
    if hasidleWorkerTime(message):
        result = result + sizeOfTag(2, WireType.Fixed32)
        result = result + sizeOfFloat(message.idleWorkerTime)
    if hastotalValueUnits(message):
        result = result + sizeOfTag(3, WireType.Fixed32)
        result = result + sizeOfFloat(message.totalValueUnits)
    if hastotalValueStructures(message):
        result = result + sizeOfTag(4, WireType.Fixed32)
        result = result + sizeOfFloat(message.totalValueStructures)
    if haskilledValueUnits(message):
        result = result + sizeOfTag(5, WireType.Fixed32)
        result = result + sizeOfFloat(message.killedValueUnits)
    if haskilledValueStructures(message):
        result = result + sizeOfTag(6, WireType.Fixed32)
        result = result + sizeOfFloat(message.killedValueStructures)
    if hascollectedMinerals(message):
        result = result + sizeOfTag(7, WireType.Fixed32)
        result = result + sizeOfFloat(message.collectedMinerals)
    if hascollectedVespene(message):
        result = result + sizeOfTag(8, WireType.Fixed32)
        result = result + sizeOfFloat(message.collectedVespene)
    if hascollectionRateMinerals(message):
        result = result + sizeOfTag(9, WireType.Fixed32)
        result = result + sizeOfFloat(message.collectionRateMinerals)
    if hascollectionRateVespene(message):
        result = result + sizeOfTag(10, WireType.Fixed32)
        result = result + sizeOfFloat(message.collectionRateVespene)
    if hasspentMinerals(message):
        result = result + sizeOfTag(11, WireType.Fixed32)
        result = result + sizeOfFloat(message.spentMinerals)
    if hasspentVespene(message):
        result = result + sizeOfTag(12, WireType.Fixed32)
        result = result + sizeOfFloat(message.spentVespene)
    if hasfoodUsed(message):
        result = result + sizeOfTag(13, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfCategoryScoreDetails(message.foodUsed))
    if haskilledMinerals(message):
        result = result + sizeOfTag(14, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfCategoryScoreDetails(message.killedMinerals))
    if haskilledVespene(message):
        result = result + sizeOfTag(15, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfCategoryScoreDetails(message.killedVespene))
    if haslostMinerals(message):
        result = result + sizeOfTag(16, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfCategoryScoreDetails(message.lostMinerals))
    if haslostVespene(message):
        result = result + sizeOfTag(17, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfCategoryScoreDetails(message.lostVespene))
    if hasfriendlyFireMinerals(message):
        result = result + sizeOfTag(18, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfCategoryScoreDetails(message.friendlyFireMinerals))
    if hasfriendlyFireVespene(message):
        result = result + sizeOfTag(19, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfCategoryScoreDetails(message.friendlyFireVespene))
    if hasusedMinerals(message):
        result = result + sizeOfTag(20, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfCategoryScoreDetails(message.usedMinerals))
    if hasusedVespene(message):
        result = result + sizeOfTag(21, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfCategoryScoreDetails(message.usedVespene))
    if hastotalUsedMinerals(message):
        result = result + sizeOfTag(22, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfCategoryScoreDetails(message.totalUsedMinerals))
    if hastotalUsedVespene(message):
        result = result + sizeOfTag(23, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfCategoryScoreDetails(message.totalUsedVespene))
    if hastotalDamageDealt(message):
        result = result + sizeOfTag(24, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfVitalScoreDetails(message.totalDamageDealt))
    if hastotalDamageTaken(message):
        result = result + sizeOfTag(25, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfVitalScoreDetails(message.totalDamageTaken))
    if hastotalHealed(message):
        result = result + sizeOfTag(26, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfVitalScoreDetails(message.totalHealed))
    if hascurrentApm(message):
        result = result + sizeOfTag(27, WireType.Fixed32)
        result = result + sizeOfFloat(message.currentApm)
    if hascurrentEffectiveApm(message):
        result = result + sizeOfTag(28, WireType.Fixed32)
        result = result + sizeOfFloat(message.currentEffectiveApm)
    result = result + sizeOfUnknownFields(message)

proc writeScoreDetails*(stream: Stream, message: ScoreDetails) =
    if hasidleProductionTime(message):
        protoWriteFloat(stream, message.idleProductionTime, 1)
    if hasidleWorkerTime(message):
        protoWriteFloat(stream, message.idleWorkerTime, 2)
    if hastotalValueUnits(message):
        protoWriteFloat(stream, message.totalValueUnits, 3)
    if hastotalValueStructures(message):
        protoWriteFloat(stream, message.totalValueStructures, 4)
    if haskilledValueUnits(message):
        protoWriteFloat(stream, message.killedValueUnits, 5)
    if haskilledValueStructures(message):
        protoWriteFloat(stream, message.killedValueStructures, 6)
    if hascollectedMinerals(message):
        protoWriteFloat(stream, message.collectedMinerals, 7)
    if hascollectedVespene(message):
        protoWriteFloat(stream, message.collectedVespene, 8)
    if hascollectionRateMinerals(message):
        protoWriteFloat(stream, message.collectionRateMinerals, 9)
    if hascollectionRateVespene(message):
        protoWriteFloat(stream, message.collectionRateVespene, 10)
    if hasspentMinerals(message):
        protoWriteFloat(stream, message.spentMinerals, 11)
    if hasspentVespene(message):
        protoWriteFloat(stream, message.spentVespene, 12)
    if hasfoodUsed(message):
        writeMessage(stream, message.foodUsed, 13)
    if haskilledMinerals(message):
        writeMessage(stream, message.killedMinerals, 14)
    if haskilledVespene(message):
        writeMessage(stream, message.killedVespene, 15)
    if haslostMinerals(message):
        writeMessage(stream, message.lostMinerals, 16)
    if haslostVespene(message):
        writeMessage(stream, message.lostVespene, 17)
    if hasfriendlyFireMinerals(message):
        writeMessage(stream, message.friendlyFireMinerals, 18)
    if hasfriendlyFireVespene(message):
        writeMessage(stream, message.friendlyFireVespene, 19)
    if hasusedMinerals(message):
        writeMessage(stream, message.usedMinerals, 20)
    if hasusedVespene(message):
        writeMessage(stream, message.usedVespene, 21)
    if hastotalUsedMinerals(message):
        writeMessage(stream, message.totalUsedMinerals, 22)
    if hastotalUsedVespene(message):
        writeMessage(stream, message.totalUsedVespene, 23)
    if hastotalDamageDealt(message):
        writeMessage(stream, message.totalDamageDealt, 24)
    if hastotalDamageTaken(message):
        writeMessage(stream, message.totalDamageTaken, 25)
    if hastotalHealed(message):
        writeMessage(stream, message.totalHealed, 26)
    if hascurrentApm(message):
        protoWriteFloat(stream, message.currentApm, 27)
    if hascurrentEffectiveApm(message):
        protoWriteFloat(stream, message.currentEffectiveApm, 28)
    writeUnknownFields(stream, message)

proc readScoreDetails*(stream: Stream): ScoreDetails =
    result = newScoreDetails()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Fixed32)
            setidleProductionTime(result, protoReadFloat(stream))
        of 2:
            expectWireType(wireType, WireType.Fixed32)
            setidleWorkerTime(result, protoReadFloat(stream))
        of 3:
            expectWireType(wireType, WireType.Fixed32)
            settotalValueUnits(result, protoReadFloat(stream))
        of 4:
            expectWireType(wireType, WireType.Fixed32)
            settotalValueStructures(result, protoReadFloat(stream))
        of 5:
            expectWireType(wireType, WireType.Fixed32)
            setkilledValueUnits(result, protoReadFloat(stream))
        of 6:
            expectWireType(wireType, WireType.Fixed32)
            setkilledValueStructures(result, protoReadFloat(stream))
        of 7:
            expectWireType(wireType, WireType.Fixed32)
            setcollectedMinerals(result, protoReadFloat(stream))
        of 8:
            expectWireType(wireType, WireType.Fixed32)
            setcollectedVespene(result, protoReadFloat(stream))
        of 9:
            expectWireType(wireType, WireType.Fixed32)
            setcollectionRateMinerals(result, protoReadFloat(stream))
        of 10:
            expectWireType(wireType, WireType.Fixed32)
            setcollectionRateVespene(result, protoReadFloat(stream))
        of 11:
            expectWireType(wireType, WireType.Fixed32)
            setspentMinerals(result, protoReadFloat(stream))
        of 12:
            expectWireType(wireType, WireType.Fixed32)
            setspentVespene(result, protoReadFloat(stream))
        of 13:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setfoodUsed(result, newCategoryScoreDetails(data))
        of 14:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setkilledMinerals(result, newCategoryScoreDetails(data))
        of 15:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setkilledVespene(result, newCategoryScoreDetails(data))
        of 16:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setlostMinerals(result, newCategoryScoreDetails(data))
        of 17:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setlostVespene(result, newCategoryScoreDetails(data))
        of 18:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setfriendlyFireMinerals(result, newCategoryScoreDetails(data))
        of 19:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setfriendlyFireVespene(result, newCategoryScoreDetails(data))
        of 20:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setusedMinerals(result, newCategoryScoreDetails(data))
        of 21:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setusedVespene(result, newCategoryScoreDetails(data))
        of 22:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            settotalUsedMinerals(result, newCategoryScoreDetails(data))
        of 23:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            settotalUsedVespene(result, newCategoryScoreDetails(data))
        of 24:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            settotalDamageDealt(result, newVitalScoreDetails(data))
        of 25:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            settotalDamageTaken(result, newVitalScoreDetails(data))
        of 26:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            settotalHealed(result, newVitalScoreDetails(data))
        of 27:
            expectWireType(wireType, WireType.Fixed32)
            setcurrentApm(result, protoReadFloat(stream))
        of 28:
            expectWireType(wireType, WireType.Fixed32)
            setcurrentEffectiveApm(result, protoReadFloat(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ScoreDetails): string =
    let
        ss = newStringStream()
    writeScoreDetails(ss, message)
    result = ss.data

proc newScoreDetails*(data: string): ScoreDetails =
    let
        ss = newStringStream(data)
    result = readScoreDetails(ss)

proc newScoreDetails*(data: seq[byte]): ScoreDetails =
    let
        ss = newStringStream(cast[string](data))
    result = readScoreDetails(ss)


proc fullyQualifiedName*(T: typedesc[Score]): string = "Score"

proc readScoreImpl(stream: Stream): Message = readScore(stream)
proc writeScoreImpl(stream: Stream, msg: Message) = writeScore(stream, Score(msg))

proc ScoreProcs*(): MessageProcs =
    result.readImpl = readScoreImpl
    result.writeImpl = writeScoreImpl

proc newScore*(): Score =
    new(result)
    initMessage(result[])
    result.procs = ScoreProcs()
    result.scoreType = Score_ScoreType.Curriculum
    result.score = 0
    result.scoreDetails = nil

proc clearscoreType*(message: Score) =
    message.scoreType = Score_ScoreType.Curriculum
    clearFields(message, [6])

proc hasscoreType*(message: Score): bool =
    result = hasField(message, 6)

proc setscoreType*(message: Score, value: Score_ScoreType) =
    message.scoreType = value
    setField(message, 6)

proc scoreType*(message: Score): Score_ScoreType {.inline.} =
    message.scoreType

proc `scoreType=`*(message: Score, value: Score_ScoreType) {.inline.} =
    setscoreType(message, value)

proc clearscore*(message: Score) =
    message.score = 0
    clearFields(message, [7])

proc hasscore*(message: Score): bool =
    result = hasField(message, 7)

proc setscore*(message: Score, value: int32) =
    message.score = value
    setField(message, 7)

proc score*(message: Score): int32 {.inline.} =
    message.score

proc `score=`*(message: Score, value: int32) {.inline.} =
    setscore(message, value)

proc clearscoreDetails*(message: Score) =
    message.scoreDetails = nil
    clearFields(message, [8])

proc hasscoreDetails*(message: Score): bool =
    result = hasField(message, 8)

proc setscoreDetails*(message: Score, value: ScoreDetails) =
    message.scoreDetails = value
    setField(message, 8)

proc scoreDetails*(message: Score): ScoreDetails {.inline.} =
    message.scoreDetails

proc `scoreDetails=`*(message: Score, value: ScoreDetails) {.inline.} =
    setscoreDetails(message, value)

proc `$`*(message: Score): string =
    runnableExamples:
        echo $Score
        echo fmt"{Score}"
        echo &"{Score}"
    var resultSeq: seq[string]
    if message.hasscoreType:
        resultSeq.add(&"scoreType: {message.scoreType}")
    if message.hasscore:
        resultSeq.add(&"score: {message.score}")
    if message.hasscoreDetails:
        resultSeq.add(&"scoreDetails: {message.scoreDetails}")
    result = resultSeq.join(", ")
    result = &"Score({result})"

proc sizeOfScore*(message: Score): uint64 =
    if hasscoreType(message):
        result = result + sizeOfTag(6, WireType.Varint)
        result = result + sizeOfEnum[Score_ScoreType](message.scoreType)
    if hasscore(message):
        result = result + sizeOfTag(7, WireType.Varint)
        result = result + sizeOfInt32(message.score)
    if hasscoreDetails(message):
        result = result + sizeOfTag(8, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfScoreDetails(message.scoreDetails))
    result = result + sizeOfUnknownFields(message)

proc writeScore*(stream: Stream, message: Score) =
    if hasscoreType(message):
        protoWriteEnum(stream, message.scoreType, 6)
    if hasscore(message):
        protoWriteInt32(stream, message.score, 7)
    if hasscoreDetails(message):
        writeMessage(stream, message.scoreDetails, 8)
    writeUnknownFields(stream, message)

proc readScore*(stream: Stream): Score =
    result = newScore()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 6:
            expectWireType(wireType, WireType.Varint)
            setscoreType(result, protoReadEnum[Score_ScoreType](stream))
        of 7:
            expectWireType(wireType, WireType.Varint)
            setscore(result, protoReadInt32(stream))
        of 8:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setscoreDetails(result, newScoreDetails(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: Score): string =
    let
        ss = newStringStream()
    writeScore(ss, message)
    result = ss.data

proc newScore*(data: string): Score =
    let
        ss = newStringStream(data)
    result = readScore(ss)

proc newScore*(data: seq[byte]): Score =
    let
        ss = newStringStream(cast[string](data))
    result = readScore(ss)


