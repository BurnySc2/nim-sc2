# Generated by protoc_gen_nim. Do not edit!

import base64
import intsets
import json
import strformat
import strutils

import nimpb/nimpb
import nimpb/json as nimpb_json

import common_pb
import data_pb
import debug_pb
import error_pb
import query_pb
import raw_pb
import score_pb
import spatial_pb
import ui_pb

type
    Status* {.pure.} = enum
        launched = 1
        init_game = 2
        in_game = 3
        in_replay = 4
        ended = 5
        quit = 6
        unknown = 99
    Difficulty* {.pure.} = enum
        VeryEasy = 1
        Easy = 2
        Medium = 3
        MediumHard = 4
        Hard = 5
        Harder = 6
        VeryHard = 7
        CheatVision = 8
        CheatMoney = 9
        CheatInsane = 10
    PlayerType* {.pure.} = enum
        Participant = 1
        Computer = 2
        Observer = 3
    AIBuild* {.pure.} = enum
        RandomBuild = 1
        Rush = 2
        Timing = 3
        Power = 4
        Macro = 5
        Air = 6
    Alert* {.pure.} = enum
        NuclearLaunchDetected = 1
        NydusWormDetected = 2
        AlertError = 3
        AddOnComplete = 4
        BuildingComplete = 5
        BuildingUnderAttack = 6
        LarvaHatched = 7
        MergeComplete = 8
        MineralsExhausted = 9
        MorphComplete = 10
        MothershipComplete = 11
        MULEExpired = 12
        NukeComplete = 13
        ResearchComplete = 14
        TrainError = 15
        TrainUnitComplete = 16
        TrainWorkerComplete = 17
        TransformationComplete = 18
        UnitUnderAttack = 19
        UpgradeComplete = 20
        VespeneExhausted = 21
        WarpInComplete = 22
    Result* {.pure.} = enum
        Victory = 1
        Defeat = 2
        Tie = 3
        Undecided = 4
    ResponseCreateGame_Error* {.pure.} = enum
        MissingMap = 1
        InvalidMapPath = 2
        InvalidMapData = 3
        InvalidMapName = 4
        InvalidMapHandle = 5
        MissingPlayerSetup = 6
        InvalidPlayerSetup = 7
        MultiplayerUnsupported = 8
    ResponseJoinGame_Error* {.pure.} = enum
        MissingParticipation = 1
        InvalidObservedPlayerId = 2
        MissingOptions = 3
        MissingPorts = 4
        GameFull = 5
        LaunchError = 6
        FeatureUnsupported = 7
        NoSpaceForUser = 8
        MapDoesNotExist = 9
        CannotOpenMap = 10
        ChecksumError = 11
        NetworkError = 12
        OtherError = 13
    ResponseRestartGame_Error* {.pure.} = enum
        LaunchError = 1
    ResponseStartReplay_Error* {.pure.} = enum
        MissingReplay = 1
        InvalidReplayPath = 2
        InvalidReplayData = 3
        InvalidMapData = 4
        InvalidObservedPlayerId = 5
        MissingOptions = 6
        LaunchError = 7
    ResponseMapCommand_Error* {.pure.} = enum
        NoTriggerError = 1
    ResponseReplayInfo_Error* {.pure.} = enum
        MissingReplay = 1
        InvalidReplayPath = 2
        InvalidReplayData = 3
        ParsingError = 4
        DownloadError = 5
    ResponseSaveMap_Error* {.pure.} = enum
        InvalidMapData = 1
    ActionChat_Channel* {.pure.} = enum
        Broadcast = 1
        Team = 2
    Request* = ref RequestObj
    RequestObj* = object of Message
        id: uint32
        request: Request_request_OneOf

    Request_request_Kind* {.pure.} = enum
        CreateGame
        JoinGame
        RestartGame
        StartReplay
        LeaveGame
        QuickSave
        QuickLoad
        Quit
        GameInfo
        Observation
        Action
        ObsAction
        Step
        Data
        Query
        SaveReplay
        MapCommand
        ReplayInfo
        AvailableMaps
        SaveMap
        Ping
        Debug
        NotSet

    Request_request_OneOf* = object
        case kind*: Request_request_Kind
        of Request_request_Kind.CreateGame: createGame*: RequestCreateGame
        of Request_request_Kind.JoinGame: joinGame*: RequestJoinGame
        of Request_request_Kind.RestartGame: restartGame*: RequestRestartGame
        of Request_request_Kind.StartReplay: startReplay*: RequestStartReplay
        of Request_request_Kind.LeaveGame: leaveGame*: RequestLeaveGame
        of Request_request_Kind.QuickSave: quickSave*: RequestQuickSave
        of Request_request_Kind.QuickLoad: quickLoad*: RequestQuickLoad
        of Request_request_Kind.Quit: quit*: RequestQuit
        of Request_request_Kind.GameInfo: gameInfo*: RequestGameInfo
        of Request_request_Kind.Observation: observation*: RequestObservation
        of Request_request_Kind.Action: action*: RequestAction
        of Request_request_Kind.ObsAction: obsAction*: RequestObserverAction
        of Request_request_Kind.Step: step*: RequestStep
        of Request_request_Kind.Data: data*: RequestData
        of Request_request_Kind.Query: query*: RequestQuery
        of Request_request_Kind.SaveReplay: saveReplay*: RequestSaveReplay
        of Request_request_Kind.MapCommand: mapCommand*: RequestMapCommand
        of Request_request_Kind.ReplayInfo: replayInfo*: RequestReplayInfo
        of Request_request_Kind.AvailableMaps: availableMaps*: RequestAvailableMaps
        of Request_request_Kind.SaveMap: saveMap*: RequestSaveMap
        of Request_request_Kind.Ping: ping*: RequestPing
        of Request_request_Kind.Debug: debug*: RequestDebug
        of Request_request_Kind.NotSet: nil
    Response* = ref ResponseObj
    ResponseObj* = object of Message
        id: uint32
        error: seq[string]
        status: Status
        response: Response_response_OneOf

    Response_response_Kind* {.pure.} = enum
        CreateGame
        JoinGame
        RestartGame
        StartReplay
        LeaveGame
        QuickSave
        QuickLoad
        Quit
        GameInfo
        Observation
        Action
        ObsAction
        Step
        Data
        Query
        SaveReplay
        ReplayInfo
        AvailableMaps
        SaveMap
        MapCommand
        Ping
        Debug
        NotSet

    Response_response_OneOf* = object
        case kind*: Response_response_Kind
        of Response_response_Kind.CreateGame: createGame*: ResponseCreateGame
        of Response_response_Kind.JoinGame: joinGame*: ResponseJoinGame
        of Response_response_Kind.RestartGame: restartGame*: ResponseRestartGame
        of Response_response_Kind.StartReplay: startReplay*: ResponseStartReplay
        of Response_response_Kind.LeaveGame: leaveGame*: ResponseLeaveGame
        of Response_response_Kind.QuickSave: quickSave*: ResponseQuickSave
        of Response_response_Kind.QuickLoad: quickLoad*: ResponseQuickLoad
        of Response_response_Kind.Quit: quit*: ResponseQuit
        of Response_response_Kind.GameInfo: gameInfo*: ResponseGameInfo
        of Response_response_Kind.Observation: observation*: ResponseObservation
        of Response_response_Kind.Action: action*: ResponseAction
        of Response_response_Kind.ObsAction: obsAction*: ResponseObserverAction
        of Response_response_Kind.Step: step*: ResponseStep
        of Response_response_Kind.Data: data*: ResponseData
        of Response_response_Kind.Query: query*: ResponseQuery
        of Response_response_Kind.SaveReplay: saveReplay*: ResponseSaveReplay
        of Response_response_Kind.ReplayInfo: replayInfo*: ResponseReplayInfo
        of Response_response_Kind.AvailableMaps: availableMaps*: ResponseAvailableMaps
        of Response_response_Kind.SaveMap: saveMap*: ResponseSaveMap
        of Response_response_Kind.MapCommand: mapCommand*: ResponseMapCommand
        of Response_response_Kind.Ping: ping*: ResponsePing
        of Response_response_Kind.Debug: debug*: ResponseDebug
        of Response_response_Kind.NotSet: nil
    RequestCreateGame* = ref RequestCreateGameObj
    RequestCreateGameObj* = object of Message
        playerSetup: seq[PlayerSetup]
        disableFog: bool
        randomSeed: uint32
        realtime: bool
        map: RequestCreateGame_map_OneOf

    RequestCreateGame_map_Kind* {.pure.} = enum
        LocalMap
        BattlenetMapName
        NotSet

    RequestCreateGame_map_OneOf* = object
        case kind*: RequestCreateGame_map_Kind
        of RequestCreateGame_map_Kind.LocalMap: localMap*: LocalMap
        of RequestCreateGame_map_Kind.BattlenetMapName: battlenetMapName*: string
        of RequestCreateGame_map_Kind.NotSet: nil
    LocalMap* = ref LocalMapObj
    LocalMapObj* = object of Message
        mapPath: string
        mapData: seq[byte]
    ResponseCreateGame* = ref ResponseCreateGameObj
    ResponseCreateGameObj* = object of Message
        error: ResponseCreateGame_Error
        errorDetails: string
    RequestJoinGame* = ref RequestJoinGameObj
    RequestJoinGameObj* = object of Message
        options: InterfaceOptions
        serverPorts: PortSet
        clientPorts: seq[PortSet]
        sharedPort: int32
        playerName: string
        hostIp: string
        participation: RequestJoinGame_participation_OneOf

    RequestJoinGame_participation_Kind* {.pure.} = enum
        Race
        ObservedPlayerId
        NotSet

    RequestJoinGame_participation_OneOf* = object
        case kind*: RequestJoinGame_participation_Kind
        of RequestJoinGame_participation_Kind.Race: race*: Race
        of RequestJoinGame_participation_Kind.ObservedPlayerId: observedPlayerId*: uint32
        of RequestJoinGame_participation_Kind.NotSet: nil
    PortSet* = ref PortSetObj
    PortSetObj* = object of Message
        gamePort: int32
        basePort: int32
    ResponseJoinGame* = ref ResponseJoinGameObj
    ResponseJoinGameObj* = object of Message
        playerId: uint32
        error: ResponseJoinGame_Error
        errorDetails: string
    RequestRestartGame* = ref RequestRestartGameObj
    RequestRestartGameObj* = object of Message
    ResponseRestartGame* = ref ResponseRestartGameObj
    ResponseRestartGameObj* = object of Message
        error: ResponseRestartGame_Error
        errorDetails: string
        needHardReset: bool
    RequestStartReplay* = ref RequestStartReplayObj
    RequestStartReplayObj* = object of Message
        mapData: seq[byte]
        observedPlayerId: int32
        options: InterfaceOptions
        disableFog: bool
        realtime: bool
        recordReplay: bool
        replay: RequestStartReplay_replay_OneOf

    RequestStartReplay_replay_Kind* {.pure.} = enum
        ReplayPath
        ReplayData
        NotSet

    RequestStartReplay_replay_OneOf* = object
        case kind*: RequestStartReplay_replay_Kind
        of RequestStartReplay_replay_Kind.ReplayPath: replayPath*: string
        of RequestStartReplay_replay_Kind.ReplayData: replayData*: seq[byte]
        of RequestStartReplay_replay_Kind.NotSet: nil
    ResponseStartReplay* = ref ResponseStartReplayObj
    ResponseStartReplayObj* = object of Message
        error: ResponseStartReplay_Error
        errorDetails: string
    RequestMapCommand* = ref RequestMapCommandObj
    RequestMapCommandObj* = object of Message
        triggerCmd: string
    ResponseMapCommand* = ref ResponseMapCommandObj
    ResponseMapCommandObj* = object of Message
        error: ResponseMapCommand_Error
        errorDetails: string
    RequestLeaveGame* = ref RequestLeaveGameObj
    RequestLeaveGameObj* = object of Message
    ResponseLeaveGame* = ref ResponseLeaveGameObj
    ResponseLeaveGameObj* = object of Message
    RequestQuickSave* = ref RequestQuickSaveObj
    RequestQuickSaveObj* = object of Message
    ResponseQuickSave* = ref ResponseQuickSaveObj
    ResponseQuickSaveObj* = object of Message
    RequestQuickLoad* = ref RequestQuickLoadObj
    RequestQuickLoadObj* = object of Message
    ResponseQuickLoad* = ref ResponseQuickLoadObj
    ResponseQuickLoadObj* = object of Message
    RequestQuit* = ref RequestQuitObj
    RequestQuitObj* = object of Message
    ResponseQuit* = ref ResponseQuitObj
    ResponseQuitObj* = object of Message
    RequestGameInfo* = ref RequestGameInfoObj
    RequestGameInfoObj* = object of Message
    ResponseGameInfo* = ref ResponseGameInfoObj
    ResponseGameInfoObj* = object of Message
        mapName: string
        modNames: seq[string]
        localMapPath: string
        playerInfo: seq[PlayerInfo]
        startRaw: StartRaw
        options: InterfaceOptions
    RequestObservation* = ref RequestObservationObj
    RequestObservationObj* = object of Message
        disableFog: bool
        gameLoop: uint32
    ResponseObservation* = ref ResponseObservationObj
    ResponseObservationObj* = object of Message
        actions: seq[Action]
        actionErrors: seq[ActionError]
        observation: Observation
        playerResult: seq[PlayerResult]
        chat: seq[ChatReceived]
    ChatReceived* = ref ChatReceivedObj
    ChatReceivedObj* = object of Message
        playerId: uint32
        message: string
    RequestAction* = ref RequestActionObj
    RequestActionObj* = object of Message
        actions: seq[Action]
    ResponseAction* = ref ResponseActionObj
    ResponseActionObj* = object of Message
        result: seq[ActionResult]
    RequestObserverAction* = ref RequestObserverActionObj
    RequestObserverActionObj* = object of Message
        actions: seq[ObserverAction]
    ResponseObserverAction* = ref ResponseObserverActionObj
    ResponseObserverActionObj* = object of Message
    RequestStep* = ref RequestStepObj
    RequestStepObj* = object of Message
        count: uint32
    ResponseStep* = ref ResponseStepObj
    ResponseStepObj* = object of Message
        simulationLoop: uint32
    RequestData* = ref RequestDataObj
    RequestDataObj* = object of Message
        abilityId: bool
        unitTypeId: bool
        upgradeId: bool
        buffId: bool
        effectId: bool
    ResponseData* = ref ResponseDataObj
    ResponseDataObj* = object of Message
        abilities: seq[AbilityData]
        units: seq[UnitTypeData]
        upgrades: seq[UpgradeData]
        buffs: seq[BuffData]
        effects: seq[EffectData]
    RequestSaveReplay* = ref RequestSaveReplayObj
    RequestSaveReplayObj* = object of Message
    ResponseSaveReplay* = ref ResponseSaveReplayObj
    ResponseSaveReplayObj* = object of Message
        data: seq[byte]
    RequestReplayInfo* = ref RequestReplayInfoObj
    RequestReplayInfoObj* = object of Message
        downloadData: bool
        replay: RequestReplayInfo_replay_OneOf

    RequestReplayInfo_replay_Kind* {.pure.} = enum
        ReplayPath
        ReplayData
        NotSet

    RequestReplayInfo_replay_OneOf* = object
        case kind*: RequestReplayInfo_replay_Kind
        of RequestReplayInfo_replay_Kind.ReplayPath: replayPath*: string
        of RequestReplayInfo_replay_Kind.ReplayData: replayData*: seq[byte]
        of RequestReplayInfo_replay_Kind.NotSet: nil
    PlayerInfoExtra* = ref PlayerInfoExtraObj
    PlayerInfoExtraObj* = object of Message
        playerInfo: PlayerInfo
        playerResult: PlayerResult
        playerMmr: int32
        playerApm: int32
    ResponseReplayInfo* = ref ResponseReplayInfoObj
    ResponseReplayInfoObj* = object of Message
        mapName: string
        localMapPath: string
        playerInfo: seq[PlayerInfoExtra]
        gameDurationLoops: uint32
        gameDurationSeconds: float32
        gameVersion: string
        dataVersion: string
        dataBuild: uint32
        baseBuild: uint32
        error: ResponseReplayInfo_Error
        errorDetails: string
    RequestAvailableMaps* = ref RequestAvailableMapsObj
    RequestAvailableMapsObj* = object of Message
    ResponseAvailableMaps* = ref ResponseAvailableMapsObj
    ResponseAvailableMapsObj* = object of Message
        localMapPaths: seq[string]
        battlenetMapNames: seq[string]
    RequestSaveMap* = ref RequestSaveMapObj
    RequestSaveMapObj* = object of Message
        mapPath: string
        mapData: seq[byte]
    ResponseSaveMap* = ref ResponseSaveMapObj
    ResponseSaveMapObj* = object of Message
        error: ResponseSaveMap_Error
    RequestPing* = ref RequestPingObj
    RequestPingObj* = object of Message
    ResponsePing* = ref ResponsePingObj
    ResponsePingObj* = object of Message
        gameVersion: string
        dataVersion: string
        dataBuild: uint32
        baseBuild: uint32
    RequestDebug* = ref RequestDebugObj
    RequestDebugObj* = object of Message
        debug: seq[DebugCommand]
    ResponseDebug* = ref ResponseDebugObj
    ResponseDebugObj* = object of Message
    PlayerSetup* = ref PlayerSetupObj
    PlayerSetupObj* = object of Message
        ftype: PlayerType
        race: Race
        difficulty: Difficulty
        playerName: string
        aiBuild: AIBuild
    SpatialCameraSetup* = ref SpatialCameraSetupObj
    SpatialCameraSetupObj* = object of Message
        resolution: Size2DI
        minimapResolution: Size2DI
        width: float32
        cropToPlayableArea: bool
        allowCheatingLayers: bool
    InterfaceOptions* = ref InterfaceOptionsObj
    InterfaceOptionsObj* = object of Message
        raw: bool
        score: bool
        featureLayer: SpatialCameraSetup
        render: SpatialCameraSetup
        showCloaked: bool
        showBurrowedShadows: bool
        showPlaceholders: bool
        rawAffectsSelection: bool
        rawCropToPlayableArea: bool
    PlayerInfo* = ref PlayerInfoObj
    PlayerInfoObj* = object of Message
        playerId: uint32
        ftype: PlayerType
        raceRequested: Race
        raceActual: Race
        difficulty: Difficulty
        aiBuild: AIBuild
        playerName: string
    PlayerCommon* = ref PlayerCommonObj
    PlayerCommonObj* = object of Message
        playerId: uint32
        minerals: uint32
        vespene: uint32
        foodCap: uint32
        foodUsed: uint32
        foodArmy: uint32
        foodWorkers: uint32
        idleWorkerCount: uint32
        armyCount: uint32
        warpGateCount: uint32
        larvaCount: uint32
    Observation* = ref ObservationObj
    ObservationObj* = object of Message
        gameLoop: uint32
        playerCommon: PlayerCommon
        alerts: seq[Alert]
        abilities: seq[AvailableAbility]
        score: Score
        rawData: ObservationRaw
        featureLayerData: ObservationFeatureLayer
        renderData: ObservationRender
        uiData: ObservationUI
    Action* = ref ActionObj
    ActionObj* = object of Message
        actionRaw: ActionRaw
        actionFeatureLayer: ActionSpatial
        actionRender: ActionSpatial
        actionUi: ActionUI
        actionChat: ActionChat
        gameLoop: uint32
    ActionChat* = ref ActionChatObj
    ActionChatObj* = object of Message
        channel: ActionChat_Channel
        message: string
    ActionError* = ref ActionErrorObj
    ActionErrorObj* = object of Message
        unitTag: uint64
        abilityId: uint64
        result: ActionResult
    ObserverAction* = ref ObserverActionObj
    ObserverActionObj* = object of Message
        action: ObserverAction_action_OneOf

    ObserverAction_action_Kind* {.pure.} = enum
        PlayerPerspective
        CameraMove
        CameraFollowPlayer
        CameraFollowUnits
        NotSet

    ObserverAction_action_OneOf* = object
        case kind*: ObserverAction_action_Kind
        of ObserverAction_action_Kind.PlayerPerspective: playerPerspective*: ActionObserverPlayerPerspective
        of ObserverAction_action_Kind.CameraMove: cameraMove*: ActionObserverCameraMove
        of ObserverAction_action_Kind.CameraFollowPlayer: cameraFollowPlayer*: ActionObserverCameraFollowPlayer
        of ObserverAction_action_Kind.CameraFollowUnits: cameraFollowUnits*: ActionObserverCameraFollowUnits
        of ObserverAction_action_Kind.NotSet: nil
    ActionObserverPlayerPerspective* = ref ActionObserverPlayerPerspectiveObj
    ActionObserverPlayerPerspectiveObj* = object of Message
        playerId: uint32
    ActionObserverCameraMove* = ref ActionObserverCameraMoveObj
    ActionObserverCameraMoveObj* = object of Message
        worldPos: Point2D
        distance: float32
    ActionObserverCameraFollowPlayer* = ref ActionObserverCameraFollowPlayerObj
    ActionObserverCameraFollowPlayerObj* = object of Message
        playerId: uint32
    ActionObserverCameraFollowUnits* = ref ActionObserverCameraFollowUnitsObj
    ActionObserverCameraFollowUnitsObj* = object of Message
        unitTags: seq[uint64]
    PlayerResult* = ref PlayerResultObj
    PlayerResultObj* = object of Message
        playerId: uint32
        result: Result

proc newActionObserverCameraFollowPlayer*(): ActionObserverCameraFollowPlayer
proc newActionObserverCameraFollowPlayer*(data: string): ActionObserverCameraFollowPlayer
proc newActionObserverCameraFollowPlayer*(data: seq[byte]): ActionObserverCameraFollowPlayer
proc writeActionObserverCameraFollowPlayer*(stream: Stream, message: ActionObserverCameraFollowPlayer)
proc readActionObserverCameraFollowPlayer*(stream: Stream): ActionObserverCameraFollowPlayer
proc sizeOfActionObserverCameraFollowPlayer*(message: ActionObserverCameraFollowPlayer): uint64

proc newActionObserverPlayerPerspective*(): ActionObserverPlayerPerspective
proc newActionObserverPlayerPerspective*(data: string): ActionObserverPlayerPerspective
proc newActionObserverPlayerPerspective*(data: seq[byte]): ActionObserverPlayerPerspective
proc writeActionObserverPlayerPerspective*(stream: Stream, message: ActionObserverPlayerPerspective)
proc readActionObserverPlayerPerspective*(stream: Stream): ActionObserverPlayerPerspective
proc sizeOfActionObserverPlayerPerspective*(message: ActionObserverPlayerPerspective): uint64

proc newActionObserverCameraMove*(): ActionObserverCameraMove
proc newActionObserverCameraMove*(data: string): ActionObserverCameraMove
proc newActionObserverCameraMove*(data: seq[byte]): ActionObserverCameraMove
proc writeActionObserverCameraMove*(stream: Stream, message: ActionObserverCameraMove)
proc readActionObserverCameraMove*(stream: Stream): ActionObserverCameraMove
proc sizeOfActionObserverCameraMove*(message: ActionObserverCameraMove): uint64

proc newActionObserverCameraFollowUnits*(): ActionObserverCameraFollowUnits
proc newActionObserverCameraFollowUnits*(data: string): ActionObserverCameraFollowUnits
proc newActionObserverCameraFollowUnits*(data: seq[byte]): ActionObserverCameraFollowUnits
proc writeActionObserverCameraFollowUnits*(stream: Stream, message: ActionObserverCameraFollowUnits)
proc readActionObserverCameraFollowUnits*(stream: Stream): ActionObserverCameraFollowUnits
proc sizeOfActionObserverCameraFollowUnits*(message: ActionObserverCameraFollowUnits): uint64

proc newObserverAction*(): ObserverAction
proc newObserverAction*(data: string): ObserverAction
proc newObserverAction*(data: seq[byte]): ObserverAction
proc writeObserverAction*(stream: Stream, message: ObserverAction)
proc readObserverAction*(stream: Stream): ObserverAction
proc sizeOfObserverAction*(message: ObserverAction): uint64

proc newRequestObserverAction*(): RequestObserverAction
proc newRequestObserverAction*(data: string): RequestObserverAction
proc newRequestObserverAction*(data: seq[byte]): RequestObserverAction
proc writeRequestObserverAction*(stream: Stream, message: RequestObserverAction)
proc readRequestObserverAction*(stream: Stream): RequestObserverAction
proc sizeOfRequestObserverAction*(message: RequestObserverAction): uint64

proc newResponseDebug*(): ResponseDebug
proc newResponseDebug*(data: string): ResponseDebug
proc newResponseDebug*(data: seq[byte]): ResponseDebug
proc writeResponseDebug*(stream: Stream, message: ResponseDebug)
proc readResponseDebug*(stream: Stream): ResponseDebug
proc sizeOfResponseDebug*(message: ResponseDebug): uint64

proc newLocalMap*(): LocalMap
proc newLocalMap*(data: string): LocalMap
proc newLocalMap*(data: seq[byte]): LocalMap
proc writeLocalMap*(stream: Stream, message: LocalMap)
proc readLocalMap*(stream: Stream): LocalMap
proc sizeOfLocalMap*(message: LocalMap): uint64

proc newPlayerCommon*(): PlayerCommon
proc newPlayerCommon*(data: string): PlayerCommon
proc newPlayerCommon*(data: seq[byte]): PlayerCommon
proc writePlayerCommon*(stream: Stream, message: PlayerCommon)
proc readPlayerCommon*(stream: Stream): PlayerCommon
proc sizeOfPlayerCommon*(message: PlayerCommon): uint64

proc newObservation*(): Observation
proc newObservation*(data: string): Observation
proc newObservation*(data: seq[byte]): Observation
proc writeObservation*(stream: Stream, message: Observation)
proc readObservation*(stream: Stream): Observation
proc sizeOfObservation*(message: Observation): uint64

proc newSpatialCameraSetup*(): SpatialCameraSetup
proc newSpatialCameraSetup*(data: string): SpatialCameraSetup
proc newSpatialCameraSetup*(data: seq[byte]): SpatialCameraSetup
proc writeSpatialCameraSetup*(stream: Stream, message: SpatialCameraSetup)
proc readSpatialCameraSetup*(stream: Stream): SpatialCameraSetup
proc sizeOfSpatialCameraSetup*(message: SpatialCameraSetup): uint64

proc newInterfaceOptions*(): InterfaceOptions
proc newInterfaceOptions*(data: string): InterfaceOptions
proc newInterfaceOptions*(data: seq[byte]): InterfaceOptions
proc writeInterfaceOptions*(stream: Stream, message: InterfaceOptions)
proc readInterfaceOptions*(stream: Stream): InterfaceOptions
proc sizeOfInterfaceOptions*(message: InterfaceOptions): uint64

proc newRequestRestartGame*(): RequestRestartGame
proc newRequestRestartGame*(data: string): RequestRestartGame
proc newRequestRestartGame*(data: seq[byte]): RequestRestartGame
proc writeRequestRestartGame*(stream: Stream, message: RequestRestartGame)
proc readRequestRestartGame*(stream: Stream): RequestRestartGame
proc sizeOfRequestRestartGame*(message: RequestRestartGame): uint64

proc newResponsePing*(): ResponsePing
proc newResponsePing*(data: string): ResponsePing
proc newResponsePing*(data: seq[byte]): ResponsePing
proc writeResponsePing*(stream: Stream, message: ResponsePing)
proc readResponsePing*(stream: Stream): ResponsePing
proc sizeOfResponsePing*(message: ResponsePing): uint64

proc newResponseData*(): ResponseData
proc newResponseData*(data: string): ResponseData
proc newResponseData*(data: seq[byte]): ResponseData
proc writeResponseData*(stream: Stream, message: ResponseData)
proc readResponseData*(stream: Stream): ResponseData
proc sizeOfResponseData*(message: ResponseData): uint64

proc newActionChat*(): ActionChat
proc newActionChat*(data: string): ActionChat
proc newActionChat*(data: seq[byte]): ActionChat
proc writeActionChat*(stream: Stream, message: ActionChat)
proc readActionChat*(stream: Stream): ActionChat
proc sizeOfActionChat*(message: ActionChat): uint64

proc newAction*(): Action
proc newAction*(data: string): Action
proc newAction*(data: seq[byte]): Action
proc writeAction*(stream: Stream, message: Action)
proc readAction*(stream: Stream): Action
proc sizeOfAction*(message: Action): uint64

proc newChatReceived*(): ChatReceived
proc newChatReceived*(data: string): ChatReceived
proc newChatReceived*(data: seq[byte]): ChatReceived
proc writeChatReceived*(stream: Stream, message: ChatReceived)
proc readChatReceived*(stream: Stream): ChatReceived
proc sizeOfChatReceived*(message: ChatReceived): uint64

proc newActionError*(): ActionError
proc newActionError*(data: string): ActionError
proc newActionError*(data: seq[byte]): ActionError
proc writeActionError*(stream: Stream, message: ActionError)
proc readActionError*(stream: Stream): ActionError
proc sizeOfActionError*(message: ActionError): uint64

proc newPlayerResult*(): PlayerResult
proc newPlayerResult*(data: string): PlayerResult
proc newPlayerResult*(data: seq[byte]): PlayerResult
proc writePlayerResult*(stream: Stream, message: PlayerResult)
proc readPlayerResult*(stream: Stream): PlayerResult
proc sizeOfPlayerResult*(message: PlayerResult): uint64

proc newResponseObservation*(): ResponseObservation
proc newResponseObservation*(data: string): ResponseObservation
proc newResponseObservation*(data: seq[byte]): ResponseObservation
proc writeResponseObservation*(stream: Stream, message: ResponseObservation)
proc readResponseObservation*(stream: Stream): ResponseObservation
proc sizeOfResponseObservation*(message: ResponseObservation): uint64

proc newResponseMapCommand*(): ResponseMapCommand
proc newResponseMapCommand*(data: string): ResponseMapCommand
proc newResponseMapCommand*(data: seq[byte]): ResponseMapCommand
proc writeResponseMapCommand*(stream: Stream, message: ResponseMapCommand)
proc readResponseMapCommand*(stream: Stream): ResponseMapCommand
proc sizeOfResponseMapCommand*(message: ResponseMapCommand): uint64

proc newRequestQuickLoad*(): RequestQuickLoad
proc newRequestQuickLoad*(data: string): RequestQuickLoad
proc newRequestQuickLoad*(data: seq[byte]): RequestQuickLoad
proc writeRequestQuickLoad*(stream: Stream, message: RequestQuickLoad)
proc readRequestQuickLoad*(stream: Stream): RequestQuickLoad
proc sizeOfRequestQuickLoad*(message: RequestQuickLoad): uint64

proc newPlayerSetup*(): PlayerSetup
proc newPlayerSetup*(data: string): PlayerSetup
proc newPlayerSetup*(data: seq[byte]): PlayerSetup
proc writePlayerSetup*(stream: Stream, message: PlayerSetup)
proc readPlayerSetup*(stream: Stream): PlayerSetup
proc sizeOfPlayerSetup*(message: PlayerSetup): uint64

proc newRequestStep*(): RequestStep
proc newRequestStep*(data: string): RequestStep
proc newRequestStep*(data: seq[byte]): RequestStep
proc writeRequestStep*(stream: Stream, message: RequestStep)
proc readRequestStep*(stream: Stream): RequestStep
proc sizeOfRequestStep*(message: RequestStep): uint64

proc newRequestMapCommand*(): RequestMapCommand
proc newRequestMapCommand*(data: string): RequestMapCommand
proc newRequestMapCommand*(data: seq[byte]): RequestMapCommand
proc writeRequestMapCommand*(stream: Stream, message: RequestMapCommand)
proc readRequestMapCommand*(stream: Stream): RequestMapCommand
proc sizeOfRequestMapCommand*(message: RequestMapCommand): uint64

proc newResponseSaveMap*(): ResponseSaveMap
proc newResponseSaveMap*(data: string): ResponseSaveMap
proc newResponseSaveMap*(data: seq[byte]): ResponseSaveMap
proc writeResponseSaveMap*(stream: Stream, message: ResponseSaveMap)
proc readResponseSaveMap*(stream: Stream): ResponseSaveMap
proc sizeOfResponseSaveMap*(message: ResponseSaveMap): uint64

proc newResponseCreateGame*(): ResponseCreateGame
proc newResponseCreateGame*(data: string): ResponseCreateGame
proc newResponseCreateGame*(data: seq[byte]): ResponseCreateGame
proc writeResponseCreateGame*(stream: Stream, message: ResponseCreateGame)
proc readResponseCreateGame*(stream: Stream): ResponseCreateGame
proc sizeOfResponseCreateGame*(message: ResponseCreateGame): uint64

proc newResponseLeaveGame*(): ResponseLeaveGame
proc newResponseLeaveGame*(data: string): ResponseLeaveGame
proc newResponseLeaveGame*(data: seq[byte]): ResponseLeaveGame
proc writeResponseLeaveGame*(stream: Stream, message: ResponseLeaveGame)
proc readResponseLeaveGame*(stream: Stream): ResponseLeaveGame
proc sizeOfResponseLeaveGame*(message: ResponseLeaveGame): uint64

proc newPlayerInfo*(): PlayerInfo
proc newPlayerInfo*(data: string): PlayerInfo
proc newPlayerInfo*(data: seq[byte]): PlayerInfo
proc writePlayerInfo*(stream: Stream, message: PlayerInfo)
proc readPlayerInfo*(stream: Stream): PlayerInfo
proc sizeOfPlayerInfo*(message: PlayerInfo): uint64

proc newPlayerInfoExtra*(): PlayerInfoExtra
proc newPlayerInfoExtra*(data: string): PlayerInfoExtra
proc newPlayerInfoExtra*(data: seq[byte]): PlayerInfoExtra
proc writePlayerInfoExtra*(stream: Stream, message: PlayerInfoExtra)
proc readPlayerInfoExtra*(stream: Stream): PlayerInfoExtra
proc sizeOfPlayerInfoExtra*(message: PlayerInfoExtra): uint64

proc newResponseReplayInfo*(): ResponseReplayInfo
proc newResponseReplayInfo*(data: string): ResponseReplayInfo
proc newResponseReplayInfo*(data: seq[byte]): ResponseReplayInfo
proc writeResponseReplayInfo*(stream: Stream, message: ResponseReplayInfo)
proc readResponseReplayInfo*(stream: Stream): ResponseReplayInfo
proc sizeOfResponseReplayInfo*(message: ResponseReplayInfo): uint64

proc newResponseStartReplay*(): ResponseStartReplay
proc newResponseStartReplay*(data: string): ResponseStartReplay
proc newResponseStartReplay*(data: seq[byte]): ResponseStartReplay
proc writeResponseStartReplay*(stream: Stream, message: ResponseStartReplay)
proc readResponseStartReplay*(stream: Stream): ResponseStartReplay
proc sizeOfResponseStartReplay*(message: ResponseStartReplay): uint64

proc newResponseAction*(): ResponseAction
proc newResponseAction*(data: string): ResponseAction
proc newResponseAction*(data: seq[byte]): ResponseAction
proc writeResponseAction*(stream: Stream, message: ResponseAction)
proc readResponseAction*(stream: Stream): ResponseAction
proc sizeOfResponseAction*(message: ResponseAction): uint64

proc newResponseRestartGame*(): ResponseRestartGame
proc newResponseRestartGame*(data: string): ResponseRestartGame
proc newResponseRestartGame*(data: seq[byte]): ResponseRestartGame
proc writeResponseRestartGame*(stream: Stream, message: ResponseRestartGame)
proc readResponseRestartGame*(stream: Stream): ResponseRestartGame
proc sizeOfResponseRestartGame*(message: ResponseRestartGame): uint64

proc newResponseJoinGame*(): ResponseJoinGame
proc newResponseJoinGame*(data: string): ResponseJoinGame
proc newResponseJoinGame*(data: seq[byte]): ResponseJoinGame
proc writeResponseJoinGame*(stream: Stream, message: ResponseJoinGame)
proc readResponseJoinGame*(stream: Stream): ResponseJoinGame
proc sizeOfResponseJoinGame*(message: ResponseJoinGame): uint64

proc newResponseQuit*(): ResponseQuit
proc newResponseQuit*(data: string): ResponseQuit
proc newResponseQuit*(data: seq[byte]): ResponseQuit
proc writeResponseQuit*(stream: Stream, message: ResponseQuit)
proc readResponseQuit*(stream: Stream): ResponseQuit
proc sizeOfResponseQuit*(message: ResponseQuit): uint64

proc newResponseStep*(): ResponseStep
proc newResponseStep*(data: string): ResponseStep
proc newResponseStep*(data: seq[byte]): ResponseStep
proc writeResponseStep*(stream: Stream, message: ResponseStep)
proc readResponseStep*(stream: Stream): ResponseStep
proc sizeOfResponseStep*(message: ResponseStep): uint64

proc newResponseQuickLoad*(): ResponseQuickLoad
proc newResponseQuickLoad*(data: string): ResponseQuickLoad
proc newResponseQuickLoad*(data: seq[byte]): ResponseQuickLoad
proc writeResponseQuickLoad*(stream: Stream, message: ResponseQuickLoad)
proc readResponseQuickLoad*(stream: Stream): ResponseQuickLoad
proc sizeOfResponseQuickLoad*(message: ResponseQuickLoad): uint64

proc newResponseSaveReplay*(): ResponseSaveReplay
proc newResponseSaveReplay*(data: string): ResponseSaveReplay
proc newResponseSaveReplay*(data: seq[byte]): ResponseSaveReplay
proc writeResponseSaveReplay*(stream: Stream, message: ResponseSaveReplay)
proc readResponseSaveReplay*(stream: Stream): ResponseSaveReplay
proc sizeOfResponseSaveReplay*(message: ResponseSaveReplay): uint64

proc newResponseQuickSave*(): ResponseQuickSave
proc newResponseQuickSave*(data: string): ResponseQuickSave
proc newResponseQuickSave*(data: seq[byte]): ResponseQuickSave
proc writeResponseQuickSave*(stream: Stream, message: ResponseQuickSave)
proc readResponseQuickSave*(stream: Stream): ResponseQuickSave
proc sizeOfResponseQuickSave*(message: ResponseQuickSave): uint64

proc newResponseAvailableMaps*(): ResponseAvailableMaps
proc newResponseAvailableMaps*(data: string): ResponseAvailableMaps
proc newResponseAvailableMaps*(data: seq[byte]): ResponseAvailableMaps
proc writeResponseAvailableMaps*(stream: Stream, message: ResponseAvailableMaps)
proc readResponseAvailableMaps*(stream: Stream): ResponseAvailableMaps
proc sizeOfResponseAvailableMaps*(message: ResponseAvailableMaps): uint64

proc newResponseGameInfo*(): ResponseGameInfo
proc newResponseGameInfo*(data: string): ResponseGameInfo
proc newResponseGameInfo*(data: seq[byte]): ResponseGameInfo
proc writeResponseGameInfo*(stream: Stream, message: ResponseGameInfo)
proc readResponseGameInfo*(stream: Stream): ResponseGameInfo
proc sizeOfResponseGameInfo*(message: ResponseGameInfo): uint64

proc newResponseObserverAction*(): ResponseObserverAction
proc newResponseObserverAction*(data: string): ResponseObserverAction
proc newResponseObserverAction*(data: seq[byte]): ResponseObserverAction
proc writeResponseObserverAction*(stream: Stream, message: ResponseObserverAction)
proc readResponseObserverAction*(stream: Stream): ResponseObserverAction
proc sizeOfResponseObserverAction*(message: ResponseObserverAction): uint64

proc newResponse*(): Response
proc newResponse*(data: string): Response
proc newResponse*(data: seq[byte]): Response
proc writeResponse*(stream: Stream, message: Response)
proc readResponse*(stream: Stream): Response
proc sizeOfResponse*(message: Response): uint64

proc newRequestPing*(): RequestPing
proc newRequestPing*(data: string): RequestPing
proc newRequestPing*(data: seq[byte]): RequestPing
proc writeRequestPing*(stream: Stream, message: RequestPing)
proc readRequestPing*(stream: Stream): RequestPing
proc sizeOfRequestPing*(message: RequestPing): uint64

proc newRequestQuickSave*(): RequestQuickSave
proc newRequestQuickSave*(data: string): RequestQuickSave
proc newRequestQuickSave*(data: seq[byte]): RequestQuickSave
proc writeRequestQuickSave*(stream: Stream, message: RequestQuickSave)
proc readRequestQuickSave*(stream: Stream): RequestQuickSave
proc sizeOfRequestQuickSave*(message: RequestQuickSave): uint64

proc newRequestGameInfo*(): RequestGameInfo
proc newRequestGameInfo*(data: string): RequestGameInfo
proc newRequestGameInfo*(data: seq[byte]): RequestGameInfo
proc writeRequestGameInfo*(stream: Stream, message: RequestGameInfo)
proc readRequestGameInfo*(stream: Stream): RequestGameInfo
proc sizeOfRequestGameInfo*(message: RequestGameInfo): uint64

proc newRequestDebug*(): RequestDebug
proc newRequestDebug*(data: string): RequestDebug
proc newRequestDebug*(data: seq[byte]): RequestDebug
proc writeRequestDebug*(stream: Stream, message: RequestDebug)
proc readRequestDebug*(stream: Stream): RequestDebug
proc sizeOfRequestDebug*(message: RequestDebug): uint64

proc newRequestCreateGame*(): RequestCreateGame
proc newRequestCreateGame*(data: string): RequestCreateGame
proc newRequestCreateGame*(data: seq[byte]): RequestCreateGame
proc writeRequestCreateGame*(stream: Stream, message: RequestCreateGame)
proc readRequestCreateGame*(stream: Stream): RequestCreateGame
proc sizeOfRequestCreateGame*(message: RequestCreateGame): uint64

proc newRequestReplayInfo*(): RequestReplayInfo
proc newRequestReplayInfo*(data: string): RequestReplayInfo
proc newRequestReplayInfo*(data: seq[byte]): RequestReplayInfo
proc writeRequestReplayInfo*(stream: Stream, message: RequestReplayInfo)
proc readRequestReplayInfo*(stream: Stream): RequestReplayInfo
proc sizeOfRequestReplayInfo*(message: RequestReplayInfo): uint64

proc newRequestSaveMap*(): RequestSaveMap
proc newRequestSaveMap*(data: string): RequestSaveMap
proc newRequestSaveMap*(data: seq[byte]): RequestSaveMap
proc writeRequestSaveMap*(stream: Stream, message: RequestSaveMap)
proc readRequestSaveMap*(stream: Stream): RequestSaveMap
proc sizeOfRequestSaveMap*(message: RequestSaveMap): uint64

proc newRequestQuit*(): RequestQuit
proc newRequestQuit*(data: string): RequestQuit
proc newRequestQuit*(data: seq[byte]): RequestQuit
proc writeRequestQuit*(stream: Stream, message: RequestQuit)
proc readRequestQuit*(stream: Stream): RequestQuit
proc sizeOfRequestQuit*(message: RequestQuit): uint64

proc newRequestAvailableMaps*(): RequestAvailableMaps
proc newRequestAvailableMaps*(data: string): RequestAvailableMaps
proc newRequestAvailableMaps*(data: seq[byte]): RequestAvailableMaps
proc writeRequestAvailableMaps*(stream: Stream, message: RequestAvailableMaps)
proc readRequestAvailableMaps*(stream: Stream): RequestAvailableMaps
proc sizeOfRequestAvailableMaps*(message: RequestAvailableMaps): uint64

proc newRequestLeaveGame*(): RequestLeaveGame
proc newRequestLeaveGame*(data: string): RequestLeaveGame
proc newRequestLeaveGame*(data: seq[byte]): RequestLeaveGame
proc writeRequestLeaveGame*(stream: Stream, message: RequestLeaveGame)
proc readRequestLeaveGame*(stream: Stream): RequestLeaveGame
proc sizeOfRequestLeaveGame*(message: RequestLeaveGame): uint64

proc newRequestSaveReplay*(): RequestSaveReplay
proc newRequestSaveReplay*(data: string): RequestSaveReplay
proc newRequestSaveReplay*(data: seq[byte]): RequestSaveReplay
proc writeRequestSaveReplay*(stream: Stream, message: RequestSaveReplay)
proc readRequestSaveReplay*(stream: Stream): RequestSaveReplay
proc sizeOfRequestSaveReplay*(message: RequestSaveReplay): uint64

proc newRequestAction*(): RequestAction
proc newRequestAction*(data: string): RequestAction
proc newRequestAction*(data: seq[byte]): RequestAction
proc writeRequestAction*(stream: Stream, message: RequestAction)
proc readRequestAction*(stream: Stream): RequestAction
proc sizeOfRequestAction*(message: RequestAction): uint64

proc newRequestStartReplay*(): RequestStartReplay
proc newRequestStartReplay*(data: string): RequestStartReplay
proc newRequestStartReplay*(data: seq[byte]): RequestStartReplay
proc writeRequestStartReplay*(stream: Stream, message: RequestStartReplay)
proc readRequestStartReplay*(stream: Stream): RequestStartReplay
proc sizeOfRequestStartReplay*(message: RequestStartReplay): uint64

proc newRequestData*(): RequestData
proc newRequestData*(data: string): RequestData
proc newRequestData*(data: seq[byte]): RequestData
proc writeRequestData*(stream: Stream, message: RequestData)
proc readRequestData*(stream: Stream): RequestData
proc sizeOfRequestData*(message: RequestData): uint64

proc newPortSet*(): PortSet
proc newPortSet*(data: string): PortSet
proc newPortSet*(data: seq[byte]): PortSet
proc writePortSet*(stream: Stream, message: PortSet)
proc readPortSet*(stream: Stream): PortSet
proc sizeOfPortSet*(message: PortSet): uint64

proc newRequestJoinGame*(): RequestJoinGame
proc newRequestJoinGame*(data: string): RequestJoinGame
proc newRequestJoinGame*(data: seq[byte]): RequestJoinGame
proc writeRequestJoinGame*(stream: Stream, message: RequestJoinGame)
proc readRequestJoinGame*(stream: Stream): RequestJoinGame
proc sizeOfRequestJoinGame*(message: RequestJoinGame): uint64

proc newRequestObservation*(): RequestObservation
proc newRequestObservation*(data: string): RequestObservation
proc newRequestObservation*(data: seq[byte]): RequestObservation
proc writeRequestObservation*(stream: Stream, message: RequestObservation)
proc readRequestObservation*(stream: Stream): RequestObservation
proc sizeOfRequestObservation*(message: RequestObservation): uint64

proc newRequest*(): Request
proc newRequest*(data: string): Request
proc newRequest*(data: seq[byte]): Request
proc writeRequest*(stream: Stream, message: Request)
proc readRequest*(stream: Stream): Request
proc sizeOfRequest*(message: Request): uint64

proc fullyQualifiedName*(T: typedesc[ActionObserverCameraFollowPlayer]): string = "ActionObserverCameraFollowPlayer"

proc readActionObserverCameraFollowPlayerImpl(stream: Stream): Message = readActionObserverCameraFollowPlayer(stream)
proc writeActionObserverCameraFollowPlayerImpl(stream: Stream, msg: Message) = writeActionObserverCameraFollowPlayer(stream, ActionObserverCameraFollowPlayer(msg))

proc ActionObserverCameraFollowPlayerProcs*(): MessageProcs =
    result.readImpl = readActionObserverCameraFollowPlayerImpl
    result.writeImpl = writeActionObserverCameraFollowPlayerImpl

proc newActionObserverCameraFollowPlayer*(): ActionObserverCameraFollowPlayer =
    new(result)
    initMessage(result[])
    result.procs = ActionObserverCameraFollowPlayerProcs()
    result.playerId = 0

proc clearplayerId*(message: ActionObserverCameraFollowPlayer) =
    message.playerId = 0
    clearFields(message, [1])

proc hasplayerId*(message: ActionObserverCameraFollowPlayer): bool =
    result = hasField(message, 1)

proc setplayerId*(message: ActionObserverCameraFollowPlayer, value: uint32) =
    message.playerId = value
    setField(message, 1)

proc playerId*(message: ActionObserverCameraFollowPlayer): uint32 {.inline.} =
    message.playerId

proc `playerId=`*(message: ActionObserverCameraFollowPlayer, value: uint32) {.inline.} =
    setplayerId(message, value)

proc `$`*(message: ActionObserverCameraFollowPlayer): string =
    runnableExamples:
        echo $ActionObserverCameraFollowPlayer
        echo fmt"{ActionObserverCameraFollowPlayer}"
        echo &"{ActionObserverCameraFollowPlayer}"
    var resultSeq: seq[string]
    if message.hasplayerId:
        resultSeq.add(&"playerId: {message.playerId}")
    result = resultSeq.join(", ")
    result = &"ActionObserverCameraFollowPlayer({result})"

proc sizeOfActionObserverCameraFollowPlayer*(message: ActionObserverCameraFollowPlayer): uint64 =
    if hasplayerId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.playerId)
    result = result + sizeOfUnknownFields(message)

proc writeActionObserverCameraFollowPlayer*(stream: Stream, message: ActionObserverCameraFollowPlayer) =
    if hasplayerId(message):
        protoWriteUInt32(stream, message.playerId, 1)
    writeUnknownFields(stream, message)

proc readActionObserverCameraFollowPlayer*(stream: Stream): ActionObserverCameraFollowPlayer =
    result = newActionObserverCameraFollowPlayer()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setplayerId(result, protoReadUInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionObserverCameraFollowPlayer): string =
    let
        ss = newStringStream()
    writeActionObserverCameraFollowPlayer(ss, message)
    result = ss.data

proc newActionObserverCameraFollowPlayer*(data: string): ActionObserverCameraFollowPlayer =
    let
        ss = newStringStream(data)
    result = readActionObserverCameraFollowPlayer(ss)

proc newActionObserverCameraFollowPlayer*(data: seq[byte]): ActionObserverCameraFollowPlayer =
    let
        ss = newStringStream(cast[string](data))
    result = readActionObserverCameraFollowPlayer(ss)


proc fullyQualifiedName*(T: typedesc[ActionObserverPlayerPerspective]): string = "ActionObserverPlayerPerspective"

proc readActionObserverPlayerPerspectiveImpl(stream: Stream): Message = readActionObserverPlayerPerspective(stream)
proc writeActionObserverPlayerPerspectiveImpl(stream: Stream, msg: Message) = writeActionObserverPlayerPerspective(stream, ActionObserverPlayerPerspective(msg))

proc ActionObserverPlayerPerspectiveProcs*(): MessageProcs =
    result.readImpl = readActionObserverPlayerPerspectiveImpl
    result.writeImpl = writeActionObserverPlayerPerspectiveImpl

proc newActionObserverPlayerPerspective*(): ActionObserverPlayerPerspective =
    new(result)
    initMessage(result[])
    result.procs = ActionObserverPlayerPerspectiveProcs()
    result.playerId = 0

proc clearplayerId*(message: ActionObserverPlayerPerspective) =
    message.playerId = 0
    clearFields(message, [1])

proc hasplayerId*(message: ActionObserverPlayerPerspective): bool =
    result = hasField(message, 1)

proc setplayerId*(message: ActionObserverPlayerPerspective, value: uint32) =
    message.playerId = value
    setField(message, 1)

proc playerId*(message: ActionObserverPlayerPerspective): uint32 {.inline.} =
    message.playerId

proc `playerId=`*(message: ActionObserverPlayerPerspective, value: uint32) {.inline.} =
    setplayerId(message, value)

proc `$`*(message: ActionObserverPlayerPerspective): string =
    runnableExamples:
        echo $ActionObserverPlayerPerspective
        echo fmt"{ActionObserverPlayerPerspective}"
        echo &"{ActionObserverPlayerPerspective}"
    var resultSeq: seq[string]
    if message.hasplayerId:
        resultSeq.add(&"playerId: {message.playerId}")
    result = resultSeq.join(", ")
    result = &"ActionObserverPlayerPerspective({result})"

proc sizeOfActionObserverPlayerPerspective*(message: ActionObserverPlayerPerspective): uint64 =
    if hasplayerId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.playerId)
    result = result + sizeOfUnknownFields(message)

proc writeActionObserverPlayerPerspective*(stream: Stream, message: ActionObserverPlayerPerspective) =
    if hasplayerId(message):
        protoWriteUInt32(stream, message.playerId, 1)
    writeUnknownFields(stream, message)

proc readActionObserverPlayerPerspective*(stream: Stream): ActionObserverPlayerPerspective =
    result = newActionObserverPlayerPerspective()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setplayerId(result, protoReadUInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionObserverPlayerPerspective): string =
    let
        ss = newStringStream()
    writeActionObserverPlayerPerspective(ss, message)
    result = ss.data

proc newActionObserverPlayerPerspective*(data: string): ActionObserverPlayerPerspective =
    let
        ss = newStringStream(data)
    result = readActionObserverPlayerPerspective(ss)

proc newActionObserverPlayerPerspective*(data: seq[byte]): ActionObserverPlayerPerspective =
    let
        ss = newStringStream(cast[string](data))
    result = readActionObserverPlayerPerspective(ss)


proc fullyQualifiedName*(T: typedesc[ActionObserverCameraMove]): string = "ActionObserverCameraMove"

proc readActionObserverCameraMoveImpl(stream: Stream): Message = readActionObserverCameraMove(stream)
proc writeActionObserverCameraMoveImpl(stream: Stream, msg: Message) = writeActionObserverCameraMove(stream, ActionObserverCameraMove(msg))

proc ActionObserverCameraMoveProcs*(): MessageProcs =
    result.readImpl = readActionObserverCameraMoveImpl
    result.writeImpl = writeActionObserverCameraMoveImpl

proc newActionObserverCameraMove*(): ActionObserverCameraMove =
    new(result)
    initMessage(result[])
    result.procs = ActionObserverCameraMoveProcs()
    result.worldPos = nil
    result.distance = 0

proc clearworldPos*(message: ActionObserverCameraMove) =
    message.worldPos = nil
    clearFields(message, [1])

proc hasworldPos*(message: ActionObserverCameraMove): bool =
    result = hasField(message, 1)

proc setworldPos*(message: ActionObserverCameraMove, value: Point2D) =
    message.worldPos = value
    setField(message, 1)

proc worldPos*(message: ActionObserverCameraMove): Point2D {.inline.} =
    message.worldPos

proc `worldPos=`*(message: ActionObserverCameraMove, value: Point2D) {.inline.} =
    setworldPos(message, value)

proc cleardistance*(message: ActionObserverCameraMove) =
    message.distance = 0
    clearFields(message, [2])

proc hasdistance*(message: ActionObserverCameraMove): bool =
    result = hasField(message, 2)

proc setdistance*(message: ActionObserverCameraMove, value: float32) =
    message.distance = value
    setField(message, 2)

proc distance*(message: ActionObserverCameraMove): float32 {.inline.} =
    message.distance

proc `distance=`*(message: ActionObserverCameraMove, value: float32) {.inline.} =
    setdistance(message, value)

proc `$`*(message: ActionObserverCameraMove): string =
    runnableExamples:
        echo $ActionObserverCameraMove
        echo fmt"{ActionObserverCameraMove}"
        echo &"{ActionObserverCameraMove}"
    var resultSeq: seq[string]
    if message.hasworldPos:
        resultSeq.add(&"worldPos: {message.worldPos}")
    if message.hasdistance:
        resultSeq.add(&"distance: {message.distance}")
    result = resultSeq.join(", ")
    result = &"ActionObserverCameraMove({result})"

proc sizeOfActionObserverCameraMove*(message: ActionObserverCameraMove): uint64 =
    if hasworldPos(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint2D(message.worldPos))
    if hasdistance(message):
        result = result + sizeOfTag(2, WireType.Fixed32)
        result = result + sizeOfFloat(message.distance)
    result = result + sizeOfUnknownFields(message)

proc writeActionObserverCameraMove*(stream: Stream, message: ActionObserverCameraMove) =
    if hasworldPos(message):
        writeMessage(stream, message.worldPos, 1)
    if hasdistance(message):
        protoWriteFloat(stream, message.distance, 2)
    writeUnknownFields(stream, message)

proc readActionObserverCameraMove*(stream: Stream): ActionObserverCameraMove =
    result = newActionObserverCameraMove()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setworldPos(result, newPoint2D(data))
        of 2:
            expectWireType(wireType, WireType.Fixed32)
            setdistance(result, protoReadFloat(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionObserverCameraMove): string =
    let
        ss = newStringStream()
    writeActionObserverCameraMove(ss, message)
    result = ss.data

proc newActionObserverCameraMove*(data: string): ActionObserverCameraMove =
    let
        ss = newStringStream(data)
    result = readActionObserverCameraMove(ss)

proc newActionObserverCameraMove*(data: seq[byte]): ActionObserverCameraMove =
    let
        ss = newStringStream(cast[string](data))
    result = readActionObserverCameraMove(ss)


proc fullyQualifiedName*(T: typedesc[ActionObserverCameraFollowUnits]): string = "ActionObserverCameraFollowUnits"

proc readActionObserverCameraFollowUnitsImpl(stream: Stream): Message = readActionObserverCameraFollowUnits(stream)
proc writeActionObserverCameraFollowUnitsImpl(stream: Stream, msg: Message) = writeActionObserverCameraFollowUnits(stream, ActionObserverCameraFollowUnits(msg))

proc ActionObserverCameraFollowUnitsProcs*(): MessageProcs =
    result.readImpl = readActionObserverCameraFollowUnitsImpl
    result.writeImpl = writeActionObserverCameraFollowUnitsImpl

proc newActionObserverCameraFollowUnits*(): ActionObserverCameraFollowUnits =
    new(result)
    initMessage(result[])
    result.procs = ActionObserverCameraFollowUnitsProcs()
    result.unitTags = @[]

proc clearunitTags*(message: ActionObserverCameraFollowUnits) =
    message.unitTags = @[]
    clearFields(message, [1])

proc hasunitTags*(message: ActionObserverCameraFollowUnits): bool =
    result = hasField(message, 1) or (len(message.unitTags) > 0)

proc setunitTags*(message: ActionObserverCameraFollowUnits, value: seq[uint64]) =
    message.unitTags = value
    setField(message, 1)

proc addunitTags*(message: ActionObserverCameraFollowUnits, value: uint64) =
    add(message.unitTags, value)

proc unitTags*(message: ActionObserverCameraFollowUnits): seq[uint64] {.inline.} =
    message.unitTags

proc `unitTags=`*(message: ActionObserverCameraFollowUnits, value: seq[uint64]) {.inline.} =
    setunitTags(message, value)

proc `$`*(message: ActionObserverCameraFollowUnits): string =
    runnableExamples:
        echo $ActionObserverCameraFollowUnits
        echo fmt"{ActionObserverCameraFollowUnits}"
        echo &"{ActionObserverCameraFollowUnits}"
    var resultSeq: seq[string]
    if message.hasunitTags:
        resultSeq.add(&"unitTags: {message.unitTags}")
    result = resultSeq.join(", ")
    result = &"ActionObserverCameraFollowUnits({result})"

proc sizeOfActionObserverCameraFollowUnits*(message: ActionObserverCameraFollowUnits): uint64 =
    if len(message.unitTags) > 0:
        for value in message.unitTags:
            result = result + sizeOfTag(1, WireType.Varint)
            result = result + sizeOfUInt64(value)
    result = result + sizeOfUnknownFields(message)

proc writeActionObserverCameraFollowUnits*(stream: Stream, message: ActionObserverCameraFollowUnits) =
    for value in message.unitTags:
        protoWriteUInt64(stream, value, 1)
    writeUnknownFields(stream, message)

proc readActionObserverCameraFollowUnits*(stream: Stream): ActionObserverCameraFollowUnits =
    result = newActionObserverCameraFollowUnits()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint, WireType.LengthDelimited)
            if wireType == WireType.LengthDelimited:
                let
                    size = readVarint(stream)
                    start = uint64(getPosition(stream))
                var consumed = 0'u64
                while consumed < size:
                    addunitTags(result, protoReadUInt64(stream))
                    consumed = uint64(getPosition(stream)) - start
                if consumed != size:
                    raise newException(Exception, "packed field size mismatch")
            else:
                addunitTags(result, protoReadUInt64(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionObserverCameraFollowUnits): string =
    let
        ss = newStringStream()
    writeActionObserverCameraFollowUnits(ss, message)
    result = ss.data

proc newActionObserverCameraFollowUnits*(data: string): ActionObserverCameraFollowUnits =
    let
        ss = newStringStream(data)
    result = readActionObserverCameraFollowUnits(ss)

proc newActionObserverCameraFollowUnits*(data: seq[byte]): ActionObserverCameraFollowUnits =
    let
        ss = newStringStream(cast[string](data))
    result = readActionObserverCameraFollowUnits(ss)


proc fullyQualifiedName*(T: typedesc[ObserverAction]): string = "ObserverAction"

proc readObserverActionImpl(stream: Stream): Message = readObserverAction(stream)
proc writeObserverActionImpl(stream: Stream, msg: Message) = writeObserverAction(stream, ObserverAction(msg))

proc ObserverActionProcs*(): MessageProcs =
    result.readImpl = readObserverActionImpl
    result.writeImpl = writeObserverActionImpl

proc newObserverAction*(): ObserverAction =
    new(result)
    initMessage(result[])
    result.procs = ObserverActionProcs()
    result.action = ObserverAction_action_OneOf(kind: ObserverAction_action_Kind.NotSet)

proc clearplayerPerspective*(message: ObserverAction) =
    reset(message.action)
    message.action.kind = ObserverAction_action_Kind.NotSet
    clearFields(message, [1, 2, 3, 4])

proc hasplayerPerspective*(message: ObserverAction): bool =
    result = hasField(message, 1)

proc setplayerPerspective*(message: ObserverAction, value: ActionObserverPlayerPerspective) =
    if message.action.kind != ObserverAction_action_Kind.PlayerPerspective:
        message.action = ObserverAction_action_OneOf(kind: ObserverAction_action_Kind.PlayerPerspective, playerPerspective: value)
    else:
        message.action.playerPerspective = value
    setField(message, 1)
    clearFields(message, [2, 3, 4])

proc playerPerspective*(message: ObserverAction): ActionObserverPlayerPerspective {.inline.} =
    message.action.playerPerspective

proc `playerPerspective=`*(message: ObserverAction, value: ActionObserverPlayerPerspective) {.inline.} =
    setplayerPerspective(message, value)

proc clearcameraMove*(message: ObserverAction) =
    reset(message.action)
    message.action.kind = ObserverAction_action_Kind.NotSet
    clearFields(message, [2, 1, 3, 4])

proc hascameraMove*(message: ObserverAction): bool =
    result = hasField(message, 2)

proc setcameraMove*(message: ObserverAction, value: ActionObserverCameraMove) =
    if message.action.kind != ObserverAction_action_Kind.CameraMove:
        message.action = ObserverAction_action_OneOf(kind: ObserverAction_action_Kind.CameraMove, cameraMove: value)
    else:
        message.action.cameraMove = value
    setField(message, 2)
    clearFields(message, [1, 3, 4])

proc cameraMove*(message: ObserverAction): ActionObserverCameraMove {.inline.} =
    message.action.cameraMove

proc `cameraMove=`*(message: ObserverAction, value: ActionObserverCameraMove) {.inline.} =
    setcameraMove(message, value)

proc clearcameraFollowPlayer*(message: ObserverAction) =
    reset(message.action)
    message.action.kind = ObserverAction_action_Kind.NotSet
    clearFields(message, [3, 1, 2, 4])

proc hascameraFollowPlayer*(message: ObserverAction): bool =
    result = hasField(message, 3)

proc setcameraFollowPlayer*(message: ObserverAction, value: ActionObserverCameraFollowPlayer) =
    if message.action.kind != ObserverAction_action_Kind.CameraFollowPlayer:
        message.action = ObserverAction_action_OneOf(kind: ObserverAction_action_Kind.CameraFollowPlayer, cameraFollowPlayer: value)
    else:
        message.action.cameraFollowPlayer = value
    setField(message, 3)
    clearFields(message, [1, 2, 4])

proc cameraFollowPlayer*(message: ObserverAction): ActionObserverCameraFollowPlayer {.inline.} =
    message.action.cameraFollowPlayer

proc `cameraFollowPlayer=`*(message: ObserverAction, value: ActionObserverCameraFollowPlayer) {.inline.} =
    setcameraFollowPlayer(message, value)

proc clearcameraFollowUnits*(message: ObserverAction) =
    reset(message.action)
    message.action.kind = ObserverAction_action_Kind.NotSet
    clearFields(message, [4, 1, 2, 3])

proc hascameraFollowUnits*(message: ObserverAction): bool =
    result = hasField(message, 4)

proc setcameraFollowUnits*(message: ObserverAction, value: ActionObserverCameraFollowUnits) =
    if message.action.kind != ObserverAction_action_Kind.CameraFollowUnits:
        message.action = ObserverAction_action_OneOf(kind: ObserverAction_action_Kind.CameraFollowUnits, cameraFollowUnits: value)
    else:
        message.action.cameraFollowUnits = value
    setField(message, 4)
    clearFields(message, [1, 2, 3])

proc cameraFollowUnits*(message: ObserverAction): ActionObserverCameraFollowUnits {.inline.} =
    message.action.cameraFollowUnits

proc `cameraFollowUnits=`*(message: ObserverAction, value: ActionObserverCameraFollowUnits) {.inline.} =
    setcameraFollowUnits(message, value)

proc `$`*(message: ObserverAction): string =
    runnableExamples:
        echo $ObserverAction
        echo fmt"{ObserverAction}"
        echo &"{ObserverAction}"
    var resultSeq: seq[string]
    if message.hasplayerPerspective:
        resultSeq.add(&"playerPerspective: {message.playerPerspective}")
    if message.hascameraMove:
        resultSeq.add(&"cameraMove: {message.cameraMove}")
    if message.hascameraFollowPlayer:
        resultSeq.add(&"cameraFollowPlayer: {message.cameraFollowPlayer}")
    if message.hascameraFollowUnits:
        resultSeq.add(&"cameraFollowUnits: {message.cameraFollowUnits}")
    result = resultSeq.join(", ")
    result = &"ObserverAction({result})"

proc sizeOfObserverAction*(message: ObserverAction): uint64 =
    if hasplayerPerspective(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionObserverPlayerPerspective(message.action.playerPerspective))
    if hascameraMove(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionObserverCameraMove(message.action.cameraMove))
    if hascameraFollowPlayer(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionObserverCameraFollowPlayer(message.action.cameraFollowPlayer))
    if hascameraFollowUnits(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionObserverCameraFollowUnits(message.action.cameraFollowUnits))
    result = result + sizeOfUnknownFields(message)

proc writeObserverAction*(stream: Stream, message: ObserverAction) =
    if hasplayerPerspective(message):
        writeMessage(stream, message.action.playerPerspective, 1)
    if hascameraMove(message):
        writeMessage(stream, message.action.cameraMove, 2)
    if hascameraFollowPlayer(message):
        writeMessage(stream, message.action.cameraFollowPlayer, 3)
    if hascameraFollowUnits(message):
        writeMessage(stream, message.action.cameraFollowUnits, 4)
    writeUnknownFields(stream, message)

proc readObserverAction*(stream: Stream): ObserverAction =
    result = newObserverAction()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setplayerPerspective(result, newActionObserverPlayerPerspective(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcameraMove(result, newActionObserverCameraMove(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcameraFollowPlayer(result, newActionObserverCameraFollowPlayer(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcameraFollowUnits(result, newActionObserverCameraFollowUnits(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ObserverAction): string =
    let
        ss = newStringStream()
    writeObserverAction(ss, message)
    result = ss.data

proc newObserverAction*(data: string): ObserverAction =
    let
        ss = newStringStream(data)
    result = readObserverAction(ss)

proc newObserverAction*(data: seq[byte]): ObserverAction =
    let
        ss = newStringStream(cast[string](data))
    result = readObserverAction(ss)


proc fullyQualifiedName*(T: typedesc[RequestObserverAction]): string = "RequestObserverAction"

proc readRequestObserverActionImpl(stream: Stream): Message = readRequestObserverAction(stream)
proc writeRequestObserverActionImpl(stream: Stream, msg: Message) = writeRequestObserverAction(stream, RequestObserverAction(msg))

proc RequestObserverActionProcs*(): MessageProcs =
    result.readImpl = readRequestObserverActionImpl
    result.writeImpl = writeRequestObserverActionImpl

proc newRequestObserverAction*(): RequestObserverAction =
    new(result)
    initMessage(result[])
    result.procs = RequestObserverActionProcs()
    result.actions = @[]

proc clearactions*(message: RequestObserverAction) =
    message.actions = @[]
    clearFields(message, [1])

proc hasactions*(message: RequestObserverAction): bool =
    result = hasField(message, 1) or (len(message.actions) > 0)

proc setactions*(message: RequestObserverAction, value: seq[ObserverAction]) =
    message.actions = value
    setField(message, 1)

proc addactions*(message: RequestObserverAction, value: ObserverAction) =
    add(message.actions, value)

proc actions*(message: RequestObserverAction): seq[ObserverAction] {.inline.} =
    message.actions

proc `actions=`*(message: RequestObserverAction, value: seq[ObserverAction]) {.inline.} =
    setactions(message, value)

proc `$`*(message: RequestObserverAction): string =
    runnableExamples:
        echo $RequestObserverAction
        echo fmt"{RequestObserverAction}"
        echo &"{RequestObserverAction}"
    var resultSeq: seq[string]
    if message.hasactions:
        resultSeq.add(&"actions: {message.actions}")
    result = resultSeq.join(", ")
    result = &"RequestObserverAction({result})"

proc sizeOfRequestObserverAction*(message: RequestObserverAction): uint64 =
    for value in message.actions:
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfObserverAction(value))
    result = result + sizeOfUnknownFields(message)

proc writeRequestObserverAction*(stream: Stream, message: RequestObserverAction) =
    for value in message.actions:
        writeMessage(stream, value, 1)
    writeUnknownFields(stream, message)

proc readRequestObserverAction*(stream: Stream): RequestObserverAction =
    result = newRequestObserverAction()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addactions(result, newObserverAction(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestObserverAction): string =
    let
        ss = newStringStream()
    writeRequestObserverAction(ss, message)
    result = ss.data

proc newRequestObserverAction*(data: string): RequestObserverAction =
    let
        ss = newStringStream(data)
    result = readRequestObserverAction(ss)

proc newRequestObserverAction*(data: seq[byte]): RequestObserverAction =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestObserverAction(ss)


proc fullyQualifiedName*(T: typedesc[ResponseDebug]): string = "ResponseDebug"

proc readResponseDebugImpl(stream: Stream): Message = readResponseDebug(stream)
proc writeResponseDebugImpl(stream: Stream, msg: Message) = writeResponseDebug(stream, ResponseDebug(msg))

proc ResponseDebugProcs*(): MessageProcs =
    result.readImpl = readResponseDebugImpl
    result.writeImpl = writeResponseDebugImpl

proc newResponseDebug*(): ResponseDebug =
    new(result)
    initMessage(result[])
    result.procs = ResponseDebugProcs()

proc `$`*(message: ResponseDebug): string =
    runnableExamples:
        echo $ResponseDebug
        echo fmt"{ResponseDebug}"
        echo &"{ResponseDebug}"
    var resultSeq: seq[string]
    result = resultSeq.join(", ")
    result = &"ResponseDebug({result})"

proc sizeOfResponseDebug*(message: ResponseDebug): uint64 =
    result = result + sizeOfUnknownFields(message)

proc writeResponseDebug*(stream: Stream, message: ResponseDebug) =
    writeUnknownFields(stream, message)

proc readResponseDebug*(stream: Stream): ResponseDebug =
    result = newResponseDebug()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseDebug): string =
    let
        ss = newStringStream()
    writeResponseDebug(ss, message)
    result = ss.data

proc newResponseDebug*(data: string): ResponseDebug =
    let
        ss = newStringStream(data)
    result = readResponseDebug(ss)

proc newResponseDebug*(data: seq[byte]): ResponseDebug =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseDebug(ss)


proc fullyQualifiedName*(T: typedesc[LocalMap]): string = "LocalMap"

proc readLocalMapImpl(stream: Stream): Message = readLocalMap(stream)
proc writeLocalMapImpl(stream: Stream, msg: Message) = writeLocalMap(stream, LocalMap(msg))

proc LocalMapProcs*(): MessageProcs =
    result.readImpl = readLocalMapImpl
    result.writeImpl = writeLocalMapImpl

proc newLocalMap*(): LocalMap =
    new(result)
    initMessage(result[])
    result.procs = LocalMapProcs()
    result.mapPath = ""
    result.mapData = @[]

proc clearmapPath*(message: LocalMap) =
    message.mapPath = ""
    clearFields(message, [1])

proc hasmapPath*(message: LocalMap): bool =
    result = hasField(message, 1)

proc setmapPath*(message: LocalMap, value: string) =
    message.mapPath = value
    setField(message, 1)

proc mapPath*(message: LocalMap): string {.inline.} =
    message.mapPath

proc `mapPath=`*(message: LocalMap, value: string) {.inline.} =
    setmapPath(message, value)

proc clearmapData*(message: LocalMap) =
    message.mapData = @[]
    clearFields(message, [7])

proc hasmapData*(message: LocalMap): bool =
    result = hasField(message, 7)

proc setmapData*(message: LocalMap, value: seq[byte]) =
    message.mapData = value
    setField(message, 7)

proc mapData*(message: LocalMap): seq[byte] {.inline.} =
    message.mapData

proc `mapData=`*(message: LocalMap, value: seq[byte]) {.inline.} =
    setmapData(message, value)

proc `$`*(message: LocalMap): string =
    runnableExamples:
        echo $LocalMap
        echo fmt"{LocalMap}"
        echo &"{LocalMap}"
    var resultSeq: seq[string]
    if message.hasmapPath:
        resultSeq.add(&"mapPath: {message.mapPath}")
    if message.hasmapData:
        resultSeq.add(&"mapData: {message.mapData}")
    result = resultSeq.join(", ")
    result = &"LocalMap({result})"

proc sizeOfLocalMap*(message: LocalMap): uint64 =
    if hasmapPath(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfString(message.mapPath)
    if hasmapData(message):
        result = result + sizeOfTag(7, WireType.LengthDelimited)
        result = result + sizeOfBytes(message.mapData)
    result = result + sizeOfUnknownFields(message)

proc writeLocalMap*(stream: Stream, message: LocalMap) =
    if hasmapPath(message):
        protoWriteString(stream, message.mapPath, 1)
    if hasmapData(message):
        protoWriteBytes(stream, message.mapData, 7)
    writeUnknownFields(stream, message)

proc readLocalMap*(stream: Stream): LocalMap =
    result = newLocalMap()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            setmapPath(result, protoReadString(stream))
        of 7:
            expectWireType(wireType, WireType.LengthDelimited)
            setmapData(result, protoReadBytes(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: LocalMap): string =
    let
        ss = newStringStream()
    writeLocalMap(ss, message)
    result = ss.data

proc newLocalMap*(data: string): LocalMap =
    let
        ss = newStringStream(data)
    result = readLocalMap(ss)

proc newLocalMap*(data: seq[byte]): LocalMap =
    let
        ss = newStringStream(cast[string](data))
    result = readLocalMap(ss)


proc fullyQualifiedName*(T: typedesc[PlayerCommon]): string = "PlayerCommon"

proc readPlayerCommonImpl(stream: Stream): Message = readPlayerCommon(stream)
proc writePlayerCommonImpl(stream: Stream, msg: Message) = writePlayerCommon(stream, PlayerCommon(msg))

proc PlayerCommonProcs*(): MessageProcs =
    result.readImpl = readPlayerCommonImpl
    result.writeImpl = writePlayerCommonImpl

proc newPlayerCommon*(): PlayerCommon =
    new(result)
    initMessage(result[])
    result.procs = PlayerCommonProcs()
    result.playerId = 0
    result.minerals = 0
    result.vespene = 0
    result.foodCap = 0
    result.foodUsed = 0
    result.foodArmy = 0
    result.foodWorkers = 0
    result.idleWorkerCount = 0
    result.armyCount = 0
    result.warpGateCount = 0
    result.larvaCount = 0

proc clearplayerId*(message: PlayerCommon) =
    message.playerId = 0
    clearFields(message, [1])

proc hasplayerId*(message: PlayerCommon): bool =
    result = hasField(message, 1)

proc setplayerId*(message: PlayerCommon, value: uint32) =
    message.playerId = value
    setField(message, 1)

proc playerId*(message: PlayerCommon): uint32 {.inline.} =
    message.playerId

proc `playerId=`*(message: PlayerCommon, value: uint32) {.inline.} =
    setplayerId(message, value)

proc clearminerals*(message: PlayerCommon) =
    message.minerals = 0
    clearFields(message, [2])

proc hasminerals*(message: PlayerCommon): bool =
    result = hasField(message, 2)

proc setminerals*(message: PlayerCommon, value: uint32) =
    message.minerals = value
    setField(message, 2)

proc minerals*(message: PlayerCommon): uint32 {.inline.} =
    message.minerals

proc `minerals=`*(message: PlayerCommon, value: uint32) {.inline.} =
    setminerals(message, value)

proc clearvespene*(message: PlayerCommon) =
    message.vespene = 0
    clearFields(message, [3])

proc hasvespene*(message: PlayerCommon): bool =
    result = hasField(message, 3)

proc setvespene*(message: PlayerCommon, value: uint32) =
    message.vespene = value
    setField(message, 3)

proc vespene*(message: PlayerCommon): uint32 {.inline.} =
    message.vespene

proc `vespene=`*(message: PlayerCommon, value: uint32) {.inline.} =
    setvespene(message, value)

proc clearfoodCap*(message: PlayerCommon) =
    message.foodCap = 0
    clearFields(message, [4])

proc hasfoodCap*(message: PlayerCommon): bool =
    result = hasField(message, 4)

proc setfoodCap*(message: PlayerCommon, value: uint32) =
    message.foodCap = value
    setField(message, 4)

proc foodCap*(message: PlayerCommon): uint32 {.inline.} =
    message.foodCap

proc `foodCap=`*(message: PlayerCommon, value: uint32) {.inline.} =
    setfoodCap(message, value)

proc clearfoodUsed*(message: PlayerCommon) =
    message.foodUsed = 0
    clearFields(message, [5])

proc hasfoodUsed*(message: PlayerCommon): bool =
    result = hasField(message, 5)

proc setfoodUsed*(message: PlayerCommon, value: uint32) =
    message.foodUsed = value
    setField(message, 5)

proc foodUsed*(message: PlayerCommon): uint32 {.inline.} =
    message.foodUsed

proc `foodUsed=`*(message: PlayerCommon, value: uint32) {.inline.} =
    setfoodUsed(message, value)

proc clearfoodArmy*(message: PlayerCommon) =
    message.foodArmy = 0
    clearFields(message, [6])

proc hasfoodArmy*(message: PlayerCommon): bool =
    result = hasField(message, 6)

proc setfoodArmy*(message: PlayerCommon, value: uint32) =
    message.foodArmy = value
    setField(message, 6)

proc foodArmy*(message: PlayerCommon): uint32 {.inline.} =
    message.foodArmy

proc `foodArmy=`*(message: PlayerCommon, value: uint32) {.inline.} =
    setfoodArmy(message, value)

proc clearfoodWorkers*(message: PlayerCommon) =
    message.foodWorkers = 0
    clearFields(message, [7])

proc hasfoodWorkers*(message: PlayerCommon): bool =
    result = hasField(message, 7)

proc setfoodWorkers*(message: PlayerCommon, value: uint32) =
    message.foodWorkers = value
    setField(message, 7)

proc foodWorkers*(message: PlayerCommon): uint32 {.inline.} =
    message.foodWorkers

proc `foodWorkers=`*(message: PlayerCommon, value: uint32) {.inline.} =
    setfoodWorkers(message, value)

proc clearidleWorkerCount*(message: PlayerCommon) =
    message.idleWorkerCount = 0
    clearFields(message, [8])

proc hasidleWorkerCount*(message: PlayerCommon): bool =
    result = hasField(message, 8)

proc setidleWorkerCount*(message: PlayerCommon, value: uint32) =
    message.idleWorkerCount = value
    setField(message, 8)

proc idleWorkerCount*(message: PlayerCommon): uint32 {.inline.} =
    message.idleWorkerCount

proc `idleWorkerCount=`*(message: PlayerCommon, value: uint32) {.inline.} =
    setidleWorkerCount(message, value)

proc cleararmyCount*(message: PlayerCommon) =
    message.armyCount = 0
    clearFields(message, [9])

proc hasarmyCount*(message: PlayerCommon): bool =
    result = hasField(message, 9)

proc setarmyCount*(message: PlayerCommon, value: uint32) =
    message.armyCount = value
    setField(message, 9)

proc armyCount*(message: PlayerCommon): uint32 {.inline.} =
    message.armyCount

proc `armyCount=`*(message: PlayerCommon, value: uint32) {.inline.} =
    setarmyCount(message, value)

proc clearwarpGateCount*(message: PlayerCommon) =
    message.warpGateCount = 0
    clearFields(message, [10])

proc haswarpGateCount*(message: PlayerCommon): bool =
    result = hasField(message, 10)

proc setwarpGateCount*(message: PlayerCommon, value: uint32) =
    message.warpGateCount = value
    setField(message, 10)

proc warpGateCount*(message: PlayerCommon): uint32 {.inline.} =
    message.warpGateCount

proc `warpGateCount=`*(message: PlayerCommon, value: uint32) {.inline.} =
    setwarpGateCount(message, value)

proc clearlarvaCount*(message: PlayerCommon) =
    message.larvaCount = 0
    clearFields(message, [11])

proc haslarvaCount*(message: PlayerCommon): bool =
    result = hasField(message, 11)

proc setlarvaCount*(message: PlayerCommon, value: uint32) =
    message.larvaCount = value
    setField(message, 11)

proc larvaCount*(message: PlayerCommon): uint32 {.inline.} =
    message.larvaCount

proc `larvaCount=`*(message: PlayerCommon, value: uint32) {.inline.} =
    setlarvaCount(message, value)

proc `$`*(message: PlayerCommon): string =
    runnableExamples:
        echo $PlayerCommon
        echo fmt"{PlayerCommon}"
        echo &"{PlayerCommon}"
    var resultSeq: seq[string]
    if message.hasplayerId:
        resultSeq.add(&"playerId: {message.playerId}")
    if message.hasminerals:
        resultSeq.add(&"minerals: {message.minerals}")
    if message.hasvespene:
        resultSeq.add(&"vespene: {message.vespene}")
    if message.hasfoodCap:
        resultSeq.add(&"foodCap: {message.foodCap}")
    if message.hasfoodUsed:
        resultSeq.add(&"foodUsed: {message.foodUsed}")
    if message.hasfoodArmy:
        resultSeq.add(&"foodArmy: {message.foodArmy}")
    if message.hasfoodWorkers:
        resultSeq.add(&"foodWorkers: {message.foodWorkers}")
    if message.hasidleWorkerCount:
        resultSeq.add(&"idleWorkerCount: {message.idleWorkerCount}")
    if message.hasarmyCount:
        resultSeq.add(&"armyCount: {message.armyCount}")
    if message.haswarpGateCount:
        resultSeq.add(&"warpGateCount: {message.warpGateCount}")
    if message.haslarvaCount:
        resultSeq.add(&"larvaCount: {message.larvaCount}")
    result = resultSeq.join(", ")
    result = &"PlayerCommon({result})"

proc sizeOfPlayerCommon*(message: PlayerCommon): uint64 =
    if hasplayerId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.playerId)
    if hasminerals(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfUInt32(message.minerals)
    if hasvespene(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfUInt32(message.vespene)
    if hasfoodCap(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfUInt32(message.foodCap)
    if hasfoodUsed(message):
        result = result + sizeOfTag(5, WireType.Varint)
        result = result + sizeOfUInt32(message.foodUsed)
    if hasfoodArmy(message):
        result = result + sizeOfTag(6, WireType.Varint)
        result = result + sizeOfUInt32(message.foodArmy)
    if hasfoodWorkers(message):
        result = result + sizeOfTag(7, WireType.Varint)
        result = result + sizeOfUInt32(message.foodWorkers)
    if hasidleWorkerCount(message):
        result = result + sizeOfTag(8, WireType.Varint)
        result = result + sizeOfUInt32(message.idleWorkerCount)
    if hasarmyCount(message):
        result = result + sizeOfTag(9, WireType.Varint)
        result = result + sizeOfUInt32(message.armyCount)
    if haswarpGateCount(message):
        result = result + sizeOfTag(10, WireType.Varint)
        result = result + sizeOfUInt32(message.warpGateCount)
    if haslarvaCount(message):
        result = result + sizeOfTag(11, WireType.Varint)
        result = result + sizeOfUInt32(message.larvaCount)
    result = result + sizeOfUnknownFields(message)

proc writePlayerCommon*(stream: Stream, message: PlayerCommon) =
    if hasplayerId(message):
        protoWriteUInt32(stream, message.playerId, 1)
    if hasminerals(message):
        protoWriteUInt32(stream, message.minerals, 2)
    if hasvespene(message):
        protoWriteUInt32(stream, message.vespene, 3)
    if hasfoodCap(message):
        protoWriteUInt32(stream, message.foodCap, 4)
    if hasfoodUsed(message):
        protoWriteUInt32(stream, message.foodUsed, 5)
    if hasfoodArmy(message):
        protoWriteUInt32(stream, message.foodArmy, 6)
    if hasfoodWorkers(message):
        protoWriteUInt32(stream, message.foodWorkers, 7)
    if hasidleWorkerCount(message):
        protoWriteUInt32(stream, message.idleWorkerCount, 8)
    if hasarmyCount(message):
        protoWriteUInt32(stream, message.armyCount, 9)
    if haswarpGateCount(message):
        protoWriteUInt32(stream, message.warpGateCount, 10)
    if haslarvaCount(message):
        protoWriteUInt32(stream, message.larvaCount, 11)
    writeUnknownFields(stream, message)

proc readPlayerCommon*(stream: Stream): PlayerCommon =
    result = newPlayerCommon()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setplayerId(result, protoReadUInt32(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setminerals(result, protoReadUInt32(stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setvespene(result, protoReadUInt32(stream))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setfoodCap(result, protoReadUInt32(stream))
        of 5:
            expectWireType(wireType, WireType.Varint)
            setfoodUsed(result, protoReadUInt32(stream))
        of 6:
            expectWireType(wireType, WireType.Varint)
            setfoodArmy(result, protoReadUInt32(stream))
        of 7:
            expectWireType(wireType, WireType.Varint)
            setfoodWorkers(result, protoReadUInt32(stream))
        of 8:
            expectWireType(wireType, WireType.Varint)
            setidleWorkerCount(result, protoReadUInt32(stream))
        of 9:
            expectWireType(wireType, WireType.Varint)
            setarmyCount(result, protoReadUInt32(stream))
        of 10:
            expectWireType(wireType, WireType.Varint)
            setwarpGateCount(result, protoReadUInt32(stream))
        of 11:
            expectWireType(wireType, WireType.Varint)
            setlarvaCount(result, protoReadUInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: PlayerCommon): string =
    let
        ss = newStringStream()
    writePlayerCommon(ss, message)
    result = ss.data

proc newPlayerCommon*(data: string): PlayerCommon =
    let
        ss = newStringStream(data)
    result = readPlayerCommon(ss)

proc newPlayerCommon*(data: seq[byte]): PlayerCommon =
    let
        ss = newStringStream(cast[string](data))
    result = readPlayerCommon(ss)


proc fullyQualifiedName*(T: typedesc[Observation]): string = "Observation"

proc readObservationImpl(stream: Stream): Message = readObservation(stream)
proc writeObservationImpl(stream: Stream, msg: Message) = writeObservation(stream, Observation(msg))

proc ObservationProcs*(): MessageProcs =
    result.readImpl = readObservationImpl
    result.writeImpl = writeObservationImpl

proc newObservation*(): Observation =
    new(result)
    initMessage(result[])
    result.procs = ObservationProcs()
    result.gameLoop = 0
    result.playerCommon = nil
    result.alerts = @[]
    result.abilities = @[]
    result.score = nil
    result.rawData = nil
    result.featureLayerData = nil
    result.renderData = nil
    result.uiData = nil

proc cleargameLoop*(message: Observation) =
    message.gameLoop = 0
    clearFields(message, [9])

proc hasgameLoop*(message: Observation): bool =
    result = hasField(message, 9)

proc setgameLoop*(message: Observation, value: uint32) =
    message.gameLoop = value
    setField(message, 9)

proc gameLoop*(message: Observation): uint32 {.inline.} =
    message.gameLoop

proc `gameLoop=`*(message: Observation, value: uint32) {.inline.} =
    setgameLoop(message, value)

proc clearplayerCommon*(message: Observation) =
    message.playerCommon = nil
    clearFields(message, [1])

proc hasplayerCommon*(message: Observation): bool =
    result = hasField(message, 1)

proc setplayerCommon*(message: Observation, value: PlayerCommon) =
    message.playerCommon = value
    setField(message, 1)

proc playerCommon*(message: Observation): PlayerCommon {.inline.} =
    message.playerCommon

proc `playerCommon=`*(message: Observation, value: PlayerCommon) {.inline.} =
    setplayerCommon(message, value)

proc clearalerts*(message: Observation) =
    message.alerts = @[]
    clearFields(message, [10])

proc hasalerts*(message: Observation): bool =
    result = hasField(message, 10) or (len(message.alerts) > 0)

proc setalerts*(message: Observation, value: seq[Alert]) =
    message.alerts = value
    setField(message, 10)

proc addalerts*(message: Observation, value: Alert) =
    add(message.alerts, value)

proc alerts*(message: Observation): seq[Alert] {.inline.} =
    message.alerts

proc `alerts=`*(message: Observation, value: seq[Alert]) {.inline.} =
    setalerts(message, value)

proc clearabilities*(message: Observation) =
    message.abilities = @[]
    clearFields(message, [3])

proc hasabilities*(message: Observation): bool =
    result = hasField(message, 3) or (len(message.abilities) > 0)

proc setabilities*(message: Observation, value: seq[AvailableAbility]) =
    message.abilities = value
    setField(message, 3)

proc addabilities*(message: Observation, value: AvailableAbility) =
    add(message.abilities, value)

proc abilities*(message: Observation): seq[AvailableAbility] {.inline.} =
    message.abilities

proc `abilities=`*(message: Observation, value: seq[AvailableAbility]) {.inline.} =
    setabilities(message, value)

proc clearscore*(message: Observation) =
    message.score = nil
    clearFields(message, [4])

proc hasscore*(message: Observation): bool =
    result = hasField(message, 4)

proc setscore*(message: Observation, value: Score) =
    message.score = value
    setField(message, 4)

proc score*(message: Observation): Score {.inline.} =
    message.score

proc `score=`*(message: Observation, value: Score) {.inline.} =
    setscore(message, value)

proc clearrawData*(message: Observation) =
    message.rawData = nil
    clearFields(message, [5])

proc hasrawData*(message: Observation): bool =
    result = hasField(message, 5)

proc setrawData*(message: Observation, value: ObservationRaw) =
    message.rawData = value
    setField(message, 5)

proc rawData*(message: Observation): ObservationRaw {.inline.} =
    message.rawData

proc `rawData=`*(message: Observation, value: ObservationRaw) {.inline.} =
    setrawData(message, value)

proc clearfeatureLayerData*(message: Observation) =
    message.featureLayerData = nil
    clearFields(message, [6])

proc hasfeatureLayerData*(message: Observation): bool =
    result = hasField(message, 6)

proc setfeatureLayerData*(message: Observation, value: ObservationFeatureLayer) =
    message.featureLayerData = value
    setField(message, 6)

proc featureLayerData*(message: Observation): ObservationFeatureLayer {.inline.} =
    message.featureLayerData

proc `featureLayerData=`*(message: Observation, value: ObservationFeatureLayer) {.inline.} =
    setfeatureLayerData(message, value)

proc clearrenderData*(message: Observation) =
    message.renderData = nil
    clearFields(message, [7])

proc hasrenderData*(message: Observation): bool =
    result = hasField(message, 7)

proc setrenderData*(message: Observation, value: ObservationRender) =
    message.renderData = value
    setField(message, 7)

proc renderData*(message: Observation): ObservationRender {.inline.} =
    message.renderData

proc `renderData=`*(message: Observation, value: ObservationRender) {.inline.} =
    setrenderData(message, value)

proc clearuiData*(message: Observation) =
    message.uiData = nil
    clearFields(message, [8])

proc hasuiData*(message: Observation): bool =
    result = hasField(message, 8)

proc setuiData*(message: Observation, value: ObservationUI) =
    message.uiData = value
    setField(message, 8)

proc uiData*(message: Observation): ObservationUI {.inline.} =
    message.uiData

proc `uiData=`*(message: Observation, value: ObservationUI) {.inline.} =
    setuiData(message, value)

proc `$`*(message: Observation): string =
    runnableExamples:
        echo $Observation
        echo fmt"{Observation}"
        echo &"{Observation}"
    var resultSeq: seq[string]
    if message.hasgameLoop:
        resultSeq.add(&"gameLoop: {message.gameLoop}")
    if message.hasplayerCommon:
        resultSeq.add(&"playerCommon: {message.playerCommon}")
    if message.hasalerts:
        resultSeq.add(&"alerts: {message.alerts}")
    if message.hasabilities:
        resultSeq.add(&"abilities: {message.abilities}")
    if message.hasscore:
        resultSeq.add(&"score: {message.score}")
    if message.hasrawData:
        resultSeq.add(&"rawData: {message.rawData}")
    if message.hasfeatureLayerData:
        resultSeq.add(&"featureLayerData: {message.featureLayerData}")
    if message.hasrenderData:
        resultSeq.add(&"renderData: {message.renderData}")
    if message.hasuiData:
        resultSeq.add(&"uiData: {message.uiData}")
    result = resultSeq.join(", ")
    result = &"Observation({result})"

proc sizeOfObservation*(message: Observation): uint64 =
    if hasgameLoop(message):
        result = result + sizeOfTag(9, WireType.Varint)
        result = result + sizeOfUInt32(message.gameLoop)
    if hasplayerCommon(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPlayerCommon(message.playerCommon))
    if len(message.alerts) > 0:
        for value in message.alerts:
            result = result + sizeOfTag(10, WireType.Varint)
            result = result + sizeOfEnum[Alert](value)
    for value in message.abilities:
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfAvailableAbility(value))
    if hasscore(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfScore(message.score))
    if hasrawData(message):
        result = result + sizeOfTag(5, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfObservationRaw(message.rawData))
    if hasfeatureLayerData(message):
        result = result + sizeOfTag(6, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfObservationFeatureLayer(message.featureLayerData))
    if hasrenderData(message):
        result = result + sizeOfTag(7, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfObservationRender(message.renderData))
    if hasuiData(message):
        result = result + sizeOfTag(8, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfObservationUI(message.uiData))
    result = result + sizeOfUnknownFields(message)

proc writeObservation*(stream: Stream, message: Observation) =
    if hasgameLoop(message):
        protoWriteUInt32(stream, message.gameLoop, 9)
    if hasplayerCommon(message):
        writeMessage(stream, message.playerCommon, 1)
    for value in message.alerts:
        protoWriteEnum(stream, value, 10)
    for value in message.abilities:
        writeMessage(stream, value, 3)
    if hasscore(message):
        writeMessage(stream, message.score, 4)
    if hasrawData(message):
        writeMessage(stream, message.rawData, 5)
    if hasfeatureLayerData(message):
        writeMessage(stream, message.featureLayerData, 6)
    if hasrenderData(message):
        writeMessage(stream, message.renderData, 7)
    if hasuiData(message):
        writeMessage(stream, message.uiData, 8)
    writeUnknownFields(stream, message)

proc readObservation*(stream: Stream): Observation =
    result = newObservation()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 9:
            expectWireType(wireType, WireType.Varint)
            setgameLoop(result, protoReadUInt32(stream))
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setplayerCommon(result, newPlayerCommon(data))
        of 10:
            expectWireType(wireType, WireType.Varint, WireType.LengthDelimited)
            if wireType == WireType.LengthDelimited:
                let
                    size = readVarint(stream)
                    start = uint64(getPosition(stream))
                var consumed = 0'u64
                while consumed < size:
                    addalerts(result, protoReadEnum[Alert](stream))
                    consumed = uint64(getPosition(stream)) - start
                if consumed != size:
                    raise newException(Exception, "packed field size mismatch")
            else:
                addalerts(result, protoReadEnum[Alert](stream))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addabilities(result, newAvailableAbility(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setscore(result, newScore(data))
        of 5:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setrawData(result, newObservationRaw(data))
        of 6:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setfeatureLayerData(result, newObservationFeatureLayer(data))
        of 7:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setrenderData(result, newObservationRender(data))
        of 8:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setuiData(result, newObservationUI(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: Observation): string =
    let
        ss = newStringStream()
    writeObservation(ss, message)
    result = ss.data

proc newObservation*(data: string): Observation =
    let
        ss = newStringStream(data)
    result = readObservation(ss)

proc newObservation*(data: seq[byte]): Observation =
    let
        ss = newStringStream(cast[string](data))
    result = readObservation(ss)


proc fullyQualifiedName*(T: typedesc[SpatialCameraSetup]): string = "SpatialCameraSetup"

proc readSpatialCameraSetupImpl(stream: Stream): Message = readSpatialCameraSetup(stream)
proc writeSpatialCameraSetupImpl(stream: Stream, msg: Message) = writeSpatialCameraSetup(stream, SpatialCameraSetup(msg))

proc SpatialCameraSetupProcs*(): MessageProcs =
    result.readImpl = readSpatialCameraSetupImpl
    result.writeImpl = writeSpatialCameraSetupImpl

proc newSpatialCameraSetup*(): SpatialCameraSetup =
    new(result)
    initMessage(result[])
    result.procs = SpatialCameraSetupProcs()
    result.resolution = nil
    result.minimapResolution = nil
    result.width = 0
    result.cropToPlayableArea = false
    result.allowCheatingLayers = false

proc clearresolution*(message: SpatialCameraSetup) =
    message.resolution = nil
    clearFields(message, [2])

proc hasresolution*(message: SpatialCameraSetup): bool =
    result = hasField(message, 2)

proc setresolution*(message: SpatialCameraSetup, value: Size2DI) =
    message.resolution = value
    setField(message, 2)

proc resolution*(message: SpatialCameraSetup): Size2DI {.inline.} =
    message.resolution

proc `resolution=`*(message: SpatialCameraSetup, value: Size2DI) {.inline.} =
    setresolution(message, value)

proc clearminimapResolution*(message: SpatialCameraSetup) =
    message.minimapResolution = nil
    clearFields(message, [3])

proc hasminimapResolution*(message: SpatialCameraSetup): bool =
    result = hasField(message, 3)

proc setminimapResolution*(message: SpatialCameraSetup, value: Size2DI) =
    message.minimapResolution = value
    setField(message, 3)

proc minimapResolution*(message: SpatialCameraSetup): Size2DI {.inline.} =
    message.minimapResolution

proc `minimapResolution=`*(message: SpatialCameraSetup, value: Size2DI) {.inline.} =
    setminimapResolution(message, value)

proc clearwidth*(message: SpatialCameraSetup) =
    message.width = 0
    clearFields(message, [1])

proc haswidth*(message: SpatialCameraSetup): bool =
    result = hasField(message, 1)

proc setwidth*(message: SpatialCameraSetup, value: float32) =
    message.width = value
    setField(message, 1)

proc width*(message: SpatialCameraSetup): float32 {.inline.} =
    message.width

proc `width=`*(message: SpatialCameraSetup, value: float32) {.inline.} =
    setwidth(message, value)

proc clearcropToPlayableArea*(message: SpatialCameraSetup) =
    message.cropToPlayableArea = false
    clearFields(message, [4])

proc hascropToPlayableArea*(message: SpatialCameraSetup): bool =
    result = hasField(message, 4)

proc setcropToPlayableArea*(message: SpatialCameraSetup, value: bool) =
    message.cropToPlayableArea = value
    setField(message, 4)

proc cropToPlayableArea*(message: SpatialCameraSetup): bool {.inline.} =
    message.cropToPlayableArea

proc `cropToPlayableArea=`*(message: SpatialCameraSetup, value: bool) {.inline.} =
    setcropToPlayableArea(message, value)

proc clearallowCheatingLayers*(message: SpatialCameraSetup) =
    message.allowCheatingLayers = false
    clearFields(message, [5])

proc hasallowCheatingLayers*(message: SpatialCameraSetup): bool =
    result = hasField(message, 5)

proc setallowCheatingLayers*(message: SpatialCameraSetup, value: bool) =
    message.allowCheatingLayers = value
    setField(message, 5)

proc allowCheatingLayers*(message: SpatialCameraSetup): bool {.inline.} =
    message.allowCheatingLayers

proc `allowCheatingLayers=`*(message: SpatialCameraSetup, value: bool) {.inline.} =
    setallowCheatingLayers(message, value)

proc `$`*(message: SpatialCameraSetup): string =
    runnableExamples:
        echo $SpatialCameraSetup
        echo fmt"{SpatialCameraSetup}"
        echo &"{SpatialCameraSetup}"
    var resultSeq: seq[string]
    if message.hasresolution:
        resultSeq.add(&"resolution: {message.resolution}")
    if message.hasminimapResolution:
        resultSeq.add(&"minimapResolution: {message.minimapResolution}")
    if message.haswidth:
        resultSeq.add(&"width: {message.width}")
    if message.hascropToPlayableArea:
        resultSeq.add(&"cropToPlayableArea: {message.cropToPlayableArea}")
    if message.hasallowCheatingLayers:
        resultSeq.add(&"allowCheatingLayers: {message.allowCheatingLayers}")
    result = resultSeq.join(", ")
    result = &"SpatialCameraSetup({result})"

proc sizeOfSpatialCameraSetup*(message: SpatialCameraSetup): uint64 =
    if hasresolution(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfSize2DI(message.resolution))
    if hasminimapResolution(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfSize2DI(message.minimapResolution))
    if haswidth(message):
        result = result + sizeOfTag(1, WireType.Fixed32)
        result = result + sizeOfFloat(message.width)
    if hascropToPlayableArea(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfBool(message.cropToPlayableArea)
    if hasallowCheatingLayers(message):
        result = result + sizeOfTag(5, WireType.Varint)
        result = result + sizeOfBool(message.allowCheatingLayers)
    result = result + sizeOfUnknownFields(message)

proc writeSpatialCameraSetup*(stream: Stream, message: SpatialCameraSetup) =
    if hasresolution(message):
        writeMessage(stream, message.resolution, 2)
    if hasminimapResolution(message):
        writeMessage(stream, message.minimapResolution, 3)
    if haswidth(message):
        protoWriteFloat(stream, message.width, 1)
    if hascropToPlayableArea(message):
        protoWriteBool(stream, message.cropToPlayableArea, 4)
    if hasallowCheatingLayers(message):
        protoWriteBool(stream, message.allowCheatingLayers, 5)
    writeUnknownFields(stream, message)

proc readSpatialCameraSetup*(stream: Stream): SpatialCameraSetup =
    result = newSpatialCameraSetup()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setresolution(result, newSize2DI(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setminimapResolution(result, newSize2DI(data))
        of 1:
            expectWireType(wireType, WireType.Fixed32)
            setwidth(result, protoReadFloat(stream))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setcropToPlayableArea(result, protoReadBool(stream))
        of 5:
            expectWireType(wireType, WireType.Varint)
            setallowCheatingLayers(result, protoReadBool(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: SpatialCameraSetup): string =
    let
        ss = newStringStream()
    writeSpatialCameraSetup(ss, message)
    result = ss.data

proc newSpatialCameraSetup*(data: string): SpatialCameraSetup =
    let
        ss = newStringStream(data)
    result = readSpatialCameraSetup(ss)

proc newSpatialCameraSetup*(data: seq[byte]): SpatialCameraSetup =
    let
        ss = newStringStream(cast[string](data))
    result = readSpatialCameraSetup(ss)


proc fullyQualifiedName*(T: typedesc[InterfaceOptions]): string = "InterfaceOptions"

proc readInterfaceOptionsImpl(stream: Stream): Message = readInterfaceOptions(stream)
proc writeInterfaceOptionsImpl(stream: Stream, msg: Message) = writeInterfaceOptions(stream, InterfaceOptions(msg))

proc InterfaceOptionsProcs*(): MessageProcs =
    result.readImpl = readInterfaceOptionsImpl
    result.writeImpl = writeInterfaceOptionsImpl

proc newInterfaceOptions*(): InterfaceOptions =
    new(result)
    initMessage(result[])
    result.procs = InterfaceOptionsProcs()
    result.raw = false
    result.score = false
    result.featureLayer = nil
    result.render = nil
    result.showCloaked = false
    result.showBurrowedShadows = false
    result.showPlaceholders = false
    result.rawAffectsSelection = false
    result.rawCropToPlayableArea = false

proc clearraw*(message: InterfaceOptions) =
    message.raw = false
    clearFields(message, [1])

proc hasraw*(message: InterfaceOptions): bool =
    result = hasField(message, 1)

proc setraw*(message: InterfaceOptions, value: bool) =
    message.raw = value
    setField(message, 1)

proc raw*(message: InterfaceOptions): bool {.inline.} =
    message.raw

proc `raw=`*(message: InterfaceOptions, value: bool) {.inline.} =
    setraw(message, value)

proc clearscore*(message: InterfaceOptions) =
    message.score = false
    clearFields(message, [2])

proc hasscore*(message: InterfaceOptions): bool =
    result = hasField(message, 2)

proc setscore*(message: InterfaceOptions, value: bool) =
    message.score = value
    setField(message, 2)

proc score*(message: InterfaceOptions): bool {.inline.} =
    message.score

proc `score=`*(message: InterfaceOptions, value: bool) {.inline.} =
    setscore(message, value)

proc clearfeatureLayer*(message: InterfaceOptions) =
    message.featureLayer = nil
    clearFields(message, [3])

proc hasfeatureLayer*(message: InterfaceOptions): bool =
    result = hasField(message, 3)

proc setfeatureLayer*(message: InterfaceOptions, value: SpatialCameraSetup) =
    message.featureLayer = value
    setField(message, 3)

proc featureLayer*(message: InterfaceOptions): SpatialCameraSetup {.inline.} =
    message.featureLayer

proc `featureLayer=`*(message: InterfaceOptions, value: SpatialCameraSetup) {.inline.} =
    setfeatureLayer(message, value)

proc clearrender*(message: InterfaceOptions) =
    message.render = nil
    clearFields(message, [4])

proc hasrender*(message: InterfaceOptions): bool =
    result = hasField(message, 4)

proc setrender*(message: InterfaceOptions, value: SpatialCameraSetup) =
    message.render = value
    setField(message, 4)

proc render*(message: InterfaceOptions): SpatialCameraSetup {.inline.} =
    message.render

proc `render=`*(message: InterfaceOptions, value: SpatialCameraSetup) {.inline.} =
    setrender(message, value)

proc clearshowCloaked*(message: InterfaceOptions) =
    message.showCloaked = false
    clearFields(message, [5])

proc hasshowCloaked*(message: InterfaceOptions): bool =
    result = hasField(message, 5)

proc setshowCloaked*(message: InterfaceOptions, value: bool) =
    message.showCloaked = value
    setField(message, 5)

proc showCloaked*(message: InterfaceOptions): bool {.inline.} =
    message.showCloaked

proc `showCloaked=`*(message: InterfaceOptions, value: bool) {.inline.} =
    setshowCloaked(message, value)

proc clearshowBurrowedShadows*(message: InterfaceOptions) =
    message.showBurrowedShadows = false
    clearFields(message, [9])

proc hasshowBurrowedShadows*(message: InterfaceOptions): bool =
    result = hasField(message, 9)

proc setshowBurrowedShadows*(message: InterfaceOptions, value: bool) =
    message.showBurrowedShadows = value
    setField(message, 9)

proc showBurrowedShadows*(message: InterfaceOptions): bool {.inline.} =
    message.showBurrowedShadows

proc `showBurrowedShadows=`*(message: InterfaceOptions, value: bool) {.inline.} =
    setshowBurrowedShadows(message, value)

proc clearshowPlaceholders*(message: InterfaceOptions) =
    message.showPlaceholders = false
    clearFields(message, [8])

proc hasshowPlaceholders*(message: InterfaceOptions): bool =
    result = hasField(message, 8)

proc setshowPlaceholders*(message: InterfaceOptions, value: bool) =
    message.showPlaceholders = value
    setField(message, 8)

proc showPlaceholders*(message: InterfaceOptions): bool {.inline.} =
    message.showPlaceholders

proc `showPlaceholders=`*(message: InterfaceOptions, value: bool) {.inline.} =
    setshowPlaceholders(message, value)

proc clearrawAffectsSelection*(message: InterfaceOptions) =
    message.rawAffectsSelection = false
    clearFields(message, [6])

proc hasrawAffectsSelection*(message: InterfaceOptions): bool =
    result = hasField(message, 6)

proc setrawAffectsSelection*(message: InterfaceOptions, value: bool) =
    message.rawAffectsSelection = value
    setField(message, 6)

proc rawAffectsSelection*(message: InterfaceOptions): bool {.inline.} =
    message.rawAffectsSelection

proc `rawAffectsSelection=`*(message: InterfaceOptions, value: bool) {.inline.} =
    setrawAffectsSelection(message, value)

proc clearrawCropToPlayableArea*(message: InterfaceOptions) =
    message.rawCropToPlayableArea = false
    clearFields(message, [7])

proc hasrawCropToPlayableArea*(message: InterfaceOptions): bool =
    result = hasField(message, 7)

proc setrawCropToPlayableArea*(message: InterfaceOptions, value: bool) =
    message.rawCropToPlayableArea = value
    setField(message, 7)

proc rawCropToPlayableArea*(message: InterfaceOptions): bool {.inline.} =
    message.rawCropToPlayableArea

proc `rawCropToPlayableArea=`*(message: InterfaceOptions, value: bool) {.inline.} =
    setrawCropToPlayableArea(message, value)

proc `$`*(message: InterfaceOptions): string =
    runnableExamples:
        echo $InterfaceOptions
        echo fmt"{InterfaceOptions}"
        echo &"{InterfaceOptions}"
    var resultSeq: seq[string]
    if message.hasraw:
        resultSeq.add(&"raw: {message.raw}")
    if message.hasscore:
        resultSeq.add(&"score: {message.score}")
    if message.hasfeatureLayer:
        resultSeq.add(&"featureLayer: {message.featureLayer}")
    if message.hasrender:
        resultSeq.add(&"render: {message.render}")
    if message.hasshowCloaked:
        resultSeq.add(&"showCloaked: {message.showCloaked}")
    if message.hasshowBurrowedShadows:
        resultSeq.add(&"showBurrowedShadows: {message.showBurrowedShadows}")
    if message.hasshowPlaceholders:
        resultSeq.add(&"showPlaceholders: {message.showPlaceholders}")
    if message.hasrawAffectsSelection:
        resultSeq.add(&"rawAffectsSelection: {message.rawAffectsSelection}")
    if message.hasrawCropToPlayableArea:
        resultSeq.add(&"rawCropToPlayableArea: {message.rawCropToPlayableArea}")
    result = resultSeq.join(", ")
    result = &"InterfaceOptions({result})"

proc sizeOfInterfaceOptions*(message: InterfaceOptions): uint64 =
    if hasraw(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfBool(message.raw)
    if hasscore(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfBool(message.score)
    if hasfeatureLayer(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfSpatialCameraSetup(message.featureLayer))
    if hasrender(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfSpatialCameraSetup(message.render))
    if hasshowCloaked(message):
        result = result + sizeOfTag(5, WireType.Varint)
        result = result + sizeOfBool(message.showCloaked)
    if hasshowBurrowedShadows(message):
        result = result + sizeOfTag(9, WireType.Varint)
        result = result + sizeOfBool(message.showBurrowedShadows)
    if hasshowPlaceholders(message):
        result = result + sizeOfTag(8, WireType.Varint)
        result = result + sizeOfBool(message.showPlaceholders)
    if hasrawAffectsSelection(message):
        result = result + sizeOfTag(6, WireType.Varint)
        result = result + sizeOfBool(message.rawAffectsSelection)
    if hasrawCropToPlayableArea(message):
        result = result + sizeOfTag(7, WireType.Varint)
        result = result + sizeOfBool(message.rawCropToPlayableArea)
    result = result + sizeOfUnknownFields(message)

proc writeInterfaceOptions*(stream: Stream, message: InterfaceOptions) =
    if hasraw(message):
        protoWriteBool(stream, message.raw, 1)
    if hasscore(message):
        protoWriteBool(stream, message.score, 2)
    if hasfeatureLayer(message):
        writeMessage(stream, message.featureLayer, 3)
    if hasrender(message):
        writeMessage(stream, message.render, 4)
    if hasshowCloaked(message):
        protoWriteBool(stream, message.showCloaked, 5)
    if hasshowBurrowedShadows(message):
        protoWriteBool(stream, message.showBurrowedShadows, 9)
    if hasshowPlaceholders(message):
        protoWriteBool(stream, message.showPlaceholders, 8)
    if hasrawAffectsSelection(message):
        protoWriteBool(stream, message.rawAffectsSelection, 6)
    if hasrawCropToPlayableArea(message):
        protoWriteBool(stream, message.rawCropToPlayableArea, 7)
    writeUnknownFields(stream, message)

proc readInterfaceOptions*(stream: Stream): InterfaceOptions =
    result = newInterfaceOptions()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setraw(result, protoReadBool(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setscore(result, protoReadBool(stream))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setfeatureLayer(result, newSpatialCameraSetup(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setrender(result, newSpatialCameraSetup(data))
        of 5:
            expectWireType(wireType, WireType.Varint)
            setshowCloaked(result, protoReadBool(stream))
        of 9:
            expectWireType(wireType, WireType.Varint)
            setshowBurrowedShadows(result, protoReadBool(stream))
        of 8:
            expectWireType(wireType, WireType.Varint)
            setshowPlaceholders(result, protoReadBool(stream))
        of 6:
            expectWireType(wireType, WireType.Varint)
            setrawAffectsSelection(result, protoReadBool(stream))
        of 7:
            expectWireType(wireType, WireType.Varint)
            setrawCropToPlayableArea(result, protoReadBool(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: InterfaceOptions): string =
    let
        ss = newStringStream()
    writeInterfaceOptions(ss, message)
    result = ss.data

proc newInterfaceOptions*(data: string): InterfaceOptions =
    let
        ss = newStringStream(data)
    result = readInterfaceOptions(ss)

proc newInterfaceOptions*(data: seq[byte]): InterfaceOptions =
    let
        ss = newStringStream(cast[string](data))
    result = readInterfaceOptions(ss)


proc fullyQualifiedName*(T: typedesc[RequestRestartGame]): string = "RequestRestartGame"

proc readRequestRestartGameImpl(stream: Stream): Message = readRequestRestartGame(stream)
proc writeRequestRestartGameImpl(stream: Stream, msg: Message) = writeRequestRestartGame(stream, RequestRestartGame(msg))

proc RequestRestartGameProcs*(): MessageProcs =
    result.readImpl = readRequestRestartGameImpl
    result.writeImpl = writeRequestRestartGameImpl

proc newRequestRestartGame*(): RequestRestartGame =
    new(result)
    initMessage(result[])
    result.procs = RequestRestartGameProcs()

proc `$`*(message: RequestRestartGame): string =
    runnableExamples:
        echo $RequestRestartGame
        echo fmt"{RequestRestartGame}"
        echo &"{RequestRestartGame}"
    var resultSeq: seq[string]
    result = resultSeq.join(", ")
    result = &"RequestRestartGame({result})"

proc sizeOfRequestRestartGame*(message: RequestRestartGame): uint64 =
    result = result + sizeOfUnknownFields(message)

proc writeRequestRestartGame*(stream: Stream, message: RequestRestartGame) =
    writeUnknownFields(stream, message)

proc readRequestRestartGame*(stream: Stream): RequestRestartGame =
    result = newRequestRestartGame()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestRestartGame): string =
    let
        ss = newStringStream()
    writeRequestRestartGame(ss, message)
    result = ss.data

proc newRequestRestartGame*(data: string): RequestRestartGame =
    let
        ss = newStringStream(data)
    result = readRequestRestartGame(ss)

proc newRequestRestartGame*(data: seq[byte]): RequestRestartGame =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestRestartGame(ss)


proc fullyQualifiedName*(T: typedesc[ResponsePing]): string = "ResponsePing"

proc readResponsePingImpl(stream: Stream): Message = readResponsePing(stream)
proc writeResponsePingImpl(stream: Stream, msg: Message) = writeResponsePing(stream, ResponsePing(msg))

proc ResponsePingProcs*(): MessageProcs =
    result.readImpl = readResponsePingImpl
    result.writeImpl = writeResponsePingImpl

proc newResponsePing*(): ResponsePing =
    new(result)
    initMessage(result[])
    result.procs = ResponsePingProcs()
    result.gameVersion = ""
    result.dataVersion = ""
    result.dataBuild = 0
    result.baseBuild = 0

proc cleargameVersion*(message: ResponsePing) =
    message.gameVersion = ""
    clearFields(message, [1])

proc hasgameVersion*(message: ResponsePing): bool =
    result = hasField(message, 1)

proc setgameVersion*(message: ResponsePing, value: string) =
    message.gameVersion = value
    setField(message, 1)

proc gameVersion*(message: ResponsePing): string {.inline.} =
    message.gameVersion

proc `gameVersion=`*(message: ResponsePing, value: string) {.inline.} =
    setgameVersion(message, value)

proc cleardataVersion*(message: ResponsePing) =
    message.dataVersion = ""
    clearFields(message, [2])

proc hasdataVersion*(message: ResponsePing): bool =
    result = hasField(message, 2)

proc setdataVersion*(message: ResponsePing, value: string) =
    message.dataVersion = value
    setField(message, 2)

proc dataVersion*(message: ResponsePing): string {.inline.} =
    message.dataVersion

proc `dataVersion=`*(message: ResponsePing, value: string) {.inline.} =
    setdataVersion(message, value)

proc cleardataBuild*(message: ResponsePing) =
    message.dataBuild = 0
    clearFields(message, [3])

proc hasdataBuild*(message: ResponsePing): bool =
    result = hasField(message, 3)

proc setdataBuild*(message: ResponsePing, value: uint32) =
    message.dataBuild = value
    setField(message, 3)

proc dataBuild*(message: ResponsePing): uint32 {.inline.} =
    message.dataBuild

proc `dataBuild=`*(message: ResponsePing, value: uint32) {.inline.} =
    setdataBuild(message, value)

proc clearbaseBuild*(message: ResponsePing) =
    message.baseBuild = 0
    clearFields(message, [4])

proc hasbaseBuild*(message: ResponsePing): bool =
    result = hasField(message, 4)

proc setbaseBuild*(message: ResponsePing, value: uint32) =
    message.baseBuild = value
    setField(message, 4)

proc baseBuild*(message: ResponsePing): uint32 {.inline.} =
    message.baseBuild

proc `baseBuild=`*(message: ResponsePing, value: uint32) {.inline.} =
    setbaseBuild(message, value)

proc `$`*(message: ResponsePing): string =
    runnableExamples:
        echo $ResponsePing
        echo fmt"{ResponsePing}"
        echo &"{ResponsePing}"
    var resultSeq: seq[string]
    if message.hasgameVersion:
        resultSeq.add(&"gameVersion: {message.gameVersion}")
    if message.hasdataVersion:
        resultSeq.add(&"dataVersion: {message.dataVersion}")
    if message.hasdataBuild:
        resultSeq.add(&"dataBuild: {message.dataBuild}")
    if message.hasbaseBuild:
        resultSeq.add(&"baseBuild: {message.baseBuild}")
    result = resultSeq.join(", ")
    result = &"ResponsePing({result})"

proc sizeOfResponsePing*(message: ResponsePing): uint64 =
    if hasgameVersion(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfString(message.gameVersion)
    if hasdataVersion(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfString(message.dataVersion)
    if hasdataBuild(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfUInt32(message.dataBuild)
    if hasbaseBuild(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfUInt32(message.baseBuild)
    result = result + sizeOfUnknownFields(message)

proc writeResponsePing*(stream: Stream, message: ResponsePing) =
    if hasgameVersion(message):
        protoWriteString(stream, message.gameVersion, 1)
    if hasdataVersion(message):
        protoWriteString(stream, message.dataVersion, 2)
    if hasdataBuild(message):
        protoWriteUInt32(stream, message.dataBuild, 3)
    if hasbaseBuild(message):
        protoWriteUInt32(stream, message.baseBuild, 4)
    writeUnknownFields(stream, message)

proc readResponsePing*(stream: Stream): ResponsePing =
    result = newResponsePing()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            setgameVersion(result, protoReadString(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            setdataVersion(result, protoReadString(stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setdataBuild(result, protoReadUInt32(stream))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setbaseBuild(result, protoReadUInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponsePing): string =
    let
        ss = newStringStream()
    writeResponsePing(ss, message)
    result = ss.data

proc newResponsePing*(data: string): ResponsePing =
    let
        ss = newStringStream(data)
    result = readResponsePing(ss)

proc newResponsePing*(data: seq[byte]): ResponsePing =
    let
        ss = newStringStream(cast[string](data))
    result = readResponsePing(ss)


proc fullyQualifiedName*(T: typedesc[ResponseData]): string = "ResponseData"

proc readResponseDataImpl(stream: Stream): Message = readResponseData(stream)
proc writeResponseDataImpl(stream: Stream, msg: Message) = writeResponseData(stream, ResponseData(msg))

proc ResponseDataProcs*(): MessageProcs =
    result.readImpl = readResponseDataImpl
    result.writeImpl = writeResponseDataImpl

proc newResponseData*(): ResponseData =
    new(result)
    initMessage(result[])
    result.procs = ResponseDataProcs()
    result.abilities = @[]
    result.units = @[]
    result.upgrades = @[]
    result.buffs = @[]
    result.effects = @[]

proc clearabilities*(message: ResponseData) =
    message.abilities = @[]
    clearFields(message, [1])

proc hasabilities*(message: ResponseData): bool =
    result = hasField(message, 1) or (len(message.abilities) > 0)

proc setabilities*(message: ResponseData, value: seq[AbilityData]) =
    message.abilities = value
    setField(message, 1)

proc addabilities*(message: ResponseData, value: AbilityData) =
    add(message.abilities, value)

proc abilities*(message: ResponseData): seq[AbilityData] {.inline.} =
    message.abilities

proc `abilities=`*(message: ResponseData, value: seq[AbilityData]) {.inline.} =
    setabilities(message, value)

proc clearunits*(message: ResponseData) =
    message.units = @[]
    clearFields(message, [2])

proc hasunits*(message: ResponseData): bool =
    result = hasField(message, 2) or (len(message.units) > 0)

proc setunits*(message: ResponseData, value: seq[UnitTypeData]) =
    message.units = value
    setField(message, 2)

proc addunits*(message: ResponseData, value: UnitTypeData) =
    add(message.units, value)

proc units*(message: ResponseData): seq[UnitTypeData] {.inline.} =
    message.units

proc `units=`*(message: ResponseData, value: seq[UnitTypeData]) {.inline.} =
    setunits(message, value)

proc clearupgrades*(message: ResponseData) =
    message.upgrades = @[]
    clearFields(message, [3])

proc hasupgrades*(message: ResponseData): bool =
    result = hasField(message, 3) or (len(message.upgrades) > 0)

proc setupgrades*(message: ResponseData, value: seq[UpgradeData]) =
    message.upgrades = value
    setField(message, 3)

proc addupgrades*(message: ResponseData, value: UpgradeData) =
    add(message.upgrades, value)

proc upgrades*(message: ResponseData): seq[UpgradeData] {.inline.} =
    message.upgrades

proc `upgrades=`*(message: ResponseData, value: seq[UpgradeData]) {.inline.} =
    setupgrades(message, value)

proc clearbuffs*(message: ResponseData) =
    message.buffs = @[]
    clearFields(message, [4])

proc hasbuffs*(message: ResponseData): bool =
    result = hasField(message, 4) or (len(message.buffs) > 0)

proc setbuffs*(message: ResponseData, value: seq[BuffData]) =
    message.buffs = value
    setField(message, 4)

proc addbuffs*(message: ResponseData, value: BuffData) =
    add(message.buffs, value)

proc buffs*(message: ResponseData): seq[BuffData] {.inline.} =
    message.buffs

proc `buffs=`*(message: ResponseData, value: seq[BuffData]) {.inline.} =
    setbuffs(message, value)

proc cleareffects*(message: ResponseData) =
    message.effects = @[]
    clearFields(message, [5])

proc haseffects*(message: ResponseData): bool =
    result = hasField(message, 5) or (len(message.effects) > 0)

proc seteffects*(message: ResponseData, value: seq[EffectData]) =
    message.effects = value
    setField(message, 5)

proc addeffects*(message: ResponseData, value: EffectData) =
    add(message.effects, value)

proc effects*(message: ResponseData): seq[EffectData] {.inline.} =
    message.effects

proc `effects=`*(message: ResponseData, value: seq[EffectData]) {.inline.} =
    seteffects(message, value)

proc `$`*(message: ResponseData): string =
    runnableExamples:
        echo $ResponseData
        echo fmt"{ResponseData}"
        echo &"{ResponseData}"
    var resultSeq: seq[string]
    if message.hasabilities:
        resultSeq.add(&"abilities: {message.abilities}")
    if message.hasunits:
        resultSeq.add(&"units: {message.units}")
    if message.hasupgrades:
        resultSeq.add(&"upgrades: {message.upgrades}")
    if message.hasbuffs:
        resultSeq.add(&"buffs: {message.buffs}")
    if message.haseffects:
        resultSeq.add(&"effects: {message.effects}")
    result = resultSeq.join(", ")
    result = &"ResponseData({result})"

proc sizeOfResponseData*(message: ResponseData): uint64 =
    for value in message.abilities:
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfAbilityData(value))
    for value in message.units:
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfUnitTypeData(value))
    for value in message.upgrades:
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfUpgradeData(value))
    for value in message.buffs:
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfBuffData(value))
    for value in message.effects:
        result = result + sizeOfTag(5, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfEffectData(value))
    result = result + sizeOfUnknownFields(message)

proc writeResponseData*(stream: Stream, message: ResponseData) =
    for value in message.abilities:
        writeMessage(stream, value, 1)
    for value in message.units:
        writeMessage(stream, value, 2)
    for value in message.upgrades:
        writeMessage(stream, value, 3)
    for value in message.buffs:
        writeMessage(stream, value, 4)
    for value in message.effects:
        writeMessage(stream, value, 5)
    writeUnknownFields(stream, message)

proc readResponseData*(stream: Stream): ResponseData =
    result = newResponseData()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addabilities(result, newAbilityData(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addunits(result, newUnitTypeData(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addupgrades(result, newUpgradeData(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addbuffs(result, newBuffData(data))
        of 5:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addeffects(result, newEffectData(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseData): string =
    let
        ss = newStringStream()
    writeResponseData(ss, message)
    result = ss.data

proc newResponseData*(data: string): ResponseData =
    let
        ss = newStringStream(data)
    result = readResponseData(ss)

proc newResponseData*(data: seq[byte]): ResponseData =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseData(ss)


proc fullyQualifiedName*(T: typedesc[ActionChat]): string = "ActionChat"

proc readActionChatImpl(stream: Stream): Message = readActionChat(stream)
proc writeActionChatImpl(stream: Stream, msg: Message) = writeActionChat(stream, ActionChat(msg))

proc ActionChatProcs*(): MessageProcs =
    result.readImpl = readActionChatImpl
    result.writeImpl = writeActionChatImpl

proc newActionChat*(): ActionChat =
    new(result)
    initMessage(result[])
    result.procs = ActionChatProcs()
    result.channel = ActionChat_Channel.Broadcast
    result.message = ""

proc clearchannel*(message: ActionChat) =
    message.channel = ActionChat_Channel.Broadcast
    clearFields(message, [1])

proc haschannel*(message: ActionChat): bool =
    result = hasField(message, 1)

proc setchannel*(message: ActionChat, value: ActionChat_Channel) =
    message.channel = value
    setField(message, 1)

proc channel*(message: ActionChat): ActionChat_Channel {.inline.} =
    message.channel

proc `channel=`*(message: ActionChat, value: ActionChat_Channel) {.inline.} =
    setchannel(message, value)

proc clearmessage*(message: ActionChat) =
    message.message = ""
    clearFields(message, [2])

proc hasmessage*(message: ActionChat): bool =
    result = hasField(message, 2)

proc setmessage*(message: ActionChat, value: string) =
    message.message = value
    setField(message, 2)

proc message*(message: ActionChat): string {.inline.} =
    message.message

proc `message=`*(message: ActionChat, value: string) {.inline.} =
    setmessage(message, value)

proc `$`*(message: ActionChat): string =
    runnableExamples:
        echo $ActionChat
        echo fmt"{ActionChat}"
        echo &"{ActionChat}"
    var resultSeq: seq[string]
    if message.haschannel:
        resultSeq.add(&"channel: {message.channel}")
    if message.hasmessage:
        resultSeq.add(&"message: {message.message}")
    result = resultSeq.join(", ")
    result = &"ActionChat({result})"

proc sizeOfActionChat*(message: ActionChat): uint64 =
    if haschannel(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfEnum[ActionChat_Channel](message.channel)
    if hasmessage(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfString(message.message)
    result = result + sizeOfUnknownFields(message)

proc writeActionChat*(stream: Stream, message: ActionChat) =
    if haschannel(message):
        protoWriteEnum(stream, message.channel, 1)
    if hasmessage(message):
        protoWriteString(stream, message.message, 2)
    writeUnknownFields(stream, message)

proc readActionChat*(stream: Stream): ActionChat =
    result = newActionChat()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setchannel(result, protoReadEnum[ActionChat_Channel](stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            setmessage(result, protoReadString(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionChat): string =
    let
        ss = newStringStream()
    writeActionChat(ss, message)
    result = ss.data

proc newActionChat*(data: string): ActionChat =
    let
        ss = newStringStream(data)
    result = readActionChat(ss)

proc newActionChat*(data: seq[byte]): ActionChat =
    let
        ss = newStringStream(cast[string](data))
    result = readActionChat(ss)


proc fullyQualifiedName*(T: typedesc[Action]): string = "Action"

proc readActionImpl(stream: Stream): Message = readAction(stream)
proc writeActionImpl(stream: Stream, msg: Message) = writeAction(stream, Action(msg))

proc ActionProcs*(): MessageProcs =
    result.readImpl = readActionImpl
    result.writeImpl = writeActionImpl

proc newAction*(): Action =
    new(result)
    initMessage(result[])
    result.procs = ActionProcs()
    result.actionRaw = nil
    result.actionFeatureLayer = nil
    result.actionRender = nil
    result.actionUi = nil
    result.actionChat = nil
    result.gameLoop = 0

proc clearactionRaw*(message: Action) =
    message.actionRaw = nil
    clearFields(message, [1])

proc hasactionRaw*(message: Action): bool =
    result = hasField(message, 1)

proc setactionRaw*(message: Action, value: ActionRaw) =
    message.actionRaw = value
    setField(message, 1)

proc actionRaw*(message: Action): ActionRaw {.inline.} =
    message.actionRaw

proc `actionRaw=`*(message: Action, value: ActionRaw) {.inline.} =
    setactionRaw(message, value)

proc clearactionFeatureLayer*(message: Action) =
    message.actionFeatureLayer = nil
    clearFields(message, [2])

proc hasactionFeatureLayer*(message: Action): bool =
    result = hasField(message, 2)

proc setactionFeatureLayer*(message: Action, value: ActionSpatial) =
    message.actionFeatureLayer = value
    setField(message, 2)

proc actionFeatureLayer*(message: Action): ActionSpatial {.inline.} =
    message.actionFeatureLayer

proc `actionFeatureLayer=`*(message: Action, value: ActionSpatial) {.inline.} =
    setactionFeatureLayer(message, value)

proc clearactionRender*(message: Action) =
    message.actionRender = nil
    clearFields(message, [3])

proc hasactionRender*(message: Action): bool =
    result = hasField(message, 3)

proc setactionRender*(message: Action, value: ActionSpatial) =
    message.actionRender = value
    setField(message, 3)

proc actionRender*(message: Action): ActionSpatial {.inline.} =
    message.actionRender

proc `actionRender=`*(message: Action, value: ActionSpatial) {.inline.} =
    setactionRender(message, value)

proc clearactionUi*(message: Action) =
    message.actionUi = nil
    clearFields(message, [4])

proc hasactionUi*(message: Action): bool =
    result = hasField(message, 4)

proc setactionUi*(message: Action, value: ActionUI) =
    message.actionUi = value
    setField(message, 4)

proc actionUi*(message: Action): ActionUI {.inline.} =
    message.actionUi

proc `actionUi=`*(message: Action, value: ActionUI) {.inline.} =
    setactionUi(message, value)

proc clearactionChat*(message: Action) =
    message.actionChat = nil
    clearFields(message, [6])

proc hasactionChat*(message: Action): bool =
    result = hasField(message, 6)

proc setactionChat*(message: Action, value: ActionChat) =
    message.actionChat = value
    setField(message, 6)

proc actionChat*(message: Action): ActionChat {.inline.} =
    message.actionChat

proc `actionChat=`*(message: Action, value: ActionChat) {.inline.} =
    setactionChat(message, value)

proc cleargameLoop*(message: Action) =
    message.gameLoop = 0
    clearFields(message, [7])

proc hasgameLoop*(message: Action): bool =
    result = hasField(message, 7)

proc setgameLoop*(message: Action, value: uint32) =
    message.gameLoop = value
    setField(message, 7)

proc gameLoop*(message: Action): uint32 {.inline.} =
    message.gameLoop

proc `gameLoop=`*(message: Action, value: uint32) {.inline.} =
    setgameLoop(message, value)

proc `$`*(message: Action): string =
    runnableExamples:
        echo $Action
        echo fmt"{Action}"
        echo &"{Action}"
    var resultSeq: seq[string]
    if message.hasactionRaw:
        resultSeq.add(&"actionRaw: {message.actionRaw}")
    if message.hasactionFeatureLayer:
        resultSeq.add(&"actionFeatureLayer: {message.actionFeatureLayer}")
    if message.hasactionRender:
        resultSeq.add(&"actionRender: {message.actionRender}")
    if message.hasactionUi:
        resultSeq.add(&"actionUi: {message.actionUi}")
    if message.hasactionChat:
        resultSeq.add(&"actionChat: {message.actionChat}")
    if message.hasgameLoop:
        resultSeq.add(&"gameLoop: {message.gameLoop}")
    result = resultSeq.join(", ")
    result = &"Action({result})"

proc sizeOfAction*(message: Action): uint64 =
    if hasactionRaw(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionRaw(message.actionRaw))
    if hasactionFeatureLayer(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionSpatial(message.actionFeatureLayer))
    if hasactionRender(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionSpatial(message.actionRender))
    if hasactionUi(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionUI(message.actionUi))
    if hasactionChat(message):
        result = result + sizeOfTag(6, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionChat(message.actionChat))
    if hasgameLoop(message):
        result = result + sizeOfTag(7, WireType.Varint)
        result = result + sizeOfUInt32(message.gameLoop)
    result = result + sizeOfUnknownFields(message)

proc writeAction*(stream: Stream, message: Action) =
    if hasactionRaw(message):
        writeMessage(stream, message.actionRaw, 1)
    if hasactionFeatureLayer(message):
        writeMessage(stream, message.actionFeatureLayer, 2)
    if hasactionRender(message):
        writeMessage(stream, message.actionRender, 3)
    if hasactionUi(message):
        writeMessage(stream, message.actionUi, 4)
    if hasactionChat(message):
        writeMessage(stream, message.actionChat, 6)
    if hasgameLoop(message):
        protoWriteUInt32(stream, message.gameLoop, 7)
    writeUnknownFields(stream, message)

proc readAction*(stream: Stream): Action =
    result = newAction()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setactionRaw(result, newActionRaw(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setactionFeatureLayer(result, newActionSpatial(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setactionRender(result, newActionSpatial(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setactionUi(result, newActionUI(data))
        of 6:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setactionChat(result, newActionChat(data))
        of 7:
            expectWireType(wireType, WireType.Varint)
            setgameLoop(result, protoReadUInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: Action): string =
    let
        ss = newStringStream()
    writeAction(ss, message)
    result = ss.data

proc newAction*(data: string): Action =
    let
        ss = newStringStream(data)
    result = readAction(ss)

proc newAction*(data: seq[byte]): Action =
    let
        ss = newStringStream(cast[string](data))
    result = readAction(ss)


proc fullyQualifiedName*(T: typedesc[ChatReceived]): string = "ChatReceived"

proc readChatReceivedImpl(stream: Stream): Message = readChatReceived(stream)
proc writeChatReceivedImpl(stream: Stream, msg: Message) = writeChatReceived(stream, ChatReceived(msg))

proc ChatReceivedProcs*(): MessageProcs =
    result.readImpl = readChatReceivedImpl
    result.writeImpl = writeChatReceivedImpl

proc newChatReceived*(): ChatReceived =
    new(result)
    initMessage(result[])
    result.procs = ChatReceivedProcs()
    result.playerId = 0
    result.message = ""

proc clearplayerId*(message: ChatReceived) =
    message.playerId = 0
    clearFields(message, [1])

proc hasplayerId*(message: ChatReceived): bool =
    result = hasField(message, 1)

proc setplayerId*(message: ChatReceived, value: uint32) =
    message.playerId = value
    setField(message, 1)

proc playerId*(message: ChatReceived): uint32 {.inline.} =
    message.playerId

proc `playerId=`*(message: ChatReceived, value: uint32) {.inline.} =
    setplayerId(message, value)

proc clearmessage*(message: ChatReceived) =
    message.message = ""
    clearFields(message, [2])

proc hasmessage*(message: ChatReceived): bool =
    result = hasField(message, 2)

proc setmessage*(message: ChatReceived, value: string) =
    message.message = value
    setField(message, 2)

proc message*(message: ChatReceived): string {.inline.} =
    message.message

proc `message=`*(message: ChatReceived, value: string) {.inline.} =
    setmessage(message, value)

proc `$`*(message: ChatReceived): string =
    runnableExamples:
        echo $ChatReceived
        echo fmt"{ChatReceived}"
        echo &"{ChatReceived}"
    var resultSeq: seq[string]
    if message.hasplayerId:
        resultSeq.add(&"playerId: {message.playerId}")
    if message.hasmessage:
        resultSeq.add(&"message: {message.message}")
    result = resultSeq.join(", ")
    result = &"ChatReceived({result})"

proc sizeOfChatReceived*(message: ChatReceived): uint64 =
    if hasplayerId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.playerId)
    if hasmessage(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfString(message.message)
    result = result + sizeOfUnknownFields(message)

proc writeChatReceived*(stream: Stream, message: ChatReceived) =
    if hasplayerId(message):
        protoWriteUInt32(stream, message.playerId, 1)
    if hasmessage(message):
        protoWriteString(stream, message.message, 2)
    writeUnknownFields(stream, message)

proc readChatReceived*(stream: Stream): ChatReceived =
    result = newChatReceived()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setplayerId(result, protoReadUInt32(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            setmessage(result, protoReadString(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ChatReceived): string =
    let
        ss = newStringStream()
    writeChatReceived(ss, message)
    result = ss.data

proc newChatReceived*(data: string): ChatReceived =
    let
        ss = newStringStream(data)
    result = readChatReceived(ss)

proc newChatReceived*(data: seq[byte]): ChatReceived =
    let
        ss = newStringStream(cast[string](data))
    result = readChatReceived(ss)


proc fullyQualifiedName*(T: typedesc[ActionError]): string = "ActionError"

proc readActionErrorImpl(stream: Stream): Message = readActionError(stream)
proc writeActionErrorImpl(stream: Stream, msg: Message) = writeActionError(stream, ActionError(msg))

proc ActionErrorProcs*(): MessageProcs =
    result.readImpl = readActionErrorImpl
    result.writeImpl = writeActionErrorImpl

proc newActionError*(): ActionError =
    new(result)
    initMessage(result[])
    result.procs = ActionErrorProcs()
    result.unitTag = 0
    result.abilityId = 0
    result.result = ActionResult.Success

proc clearunitTag*(message: ActionError) =
    message.unitTag = 0
    clearFields(message, [1])

proc hasunitTag*(message: ActionError): bool =
    result = hasField(message, 1)

proc setunitTag*(message: ActionError, value: uint64) =
    message.unitTag = value
    setField(message, 1)

proc unitTag*(message: ActionError): uint64 {.inline.} =
    message.unitTag

proc `unitTag=`*(message: ActionError, value: uint64) {.inline.} =
    setunitTag(message, value)

proc clearabilityId*(message: ActionError) =
    message.abilityId = 0
    clearFields(message, [2])

proc hasabilityId*(message: ActionError): bool =
    result = hasField(message, 2)

proc setabilityId*(message: ActionError, value: uint64) =
    message.abilityId = value
    setField(message, 2)

proc abilityId*(message: ActionError): uint64 {.inline.} =
    message.abilityId

proc `abilityId=`*(message: ActionError, value: uint64) {.inline.} =
    setabilityId(message, value)

proc clearresult*(message: ActionError) =
    message.result = ActionResult.Success
    clearFields(message, [3])

proc hasresult*(message: ActionError): bool =
    result = hasField(message, 3)

proc setresult*(message: ActionError, value: ActionResult) =
    message.result = value
    setField(message, 3)

proc result*(message: ActionError): ActionResult {.inline.} =
    message.result

proc `result=`*(message: ActionError, value: ActionResult) {.inline.} =
    setresult(message, value)

proc `$`*(message: ActionError): string =
    runnableExamples:
        echo $ActionError
        echo fmt"{ActionError}"
        echo &"{ActionError}"
    var resultSeq: seq[string]
    if message.hasunitTag:
        resultSeq.add(&"unitTag: {message.unitTag}")
    if message.hasabilityId:
        resultSeq.add(&"abilityId: {message.abilityId}")
    if message.hasresult:
        resultSeq.add(&"result: {message.result}")
    result = resultSeq.join(", ")
    result = &"ActionError({result})"

proc sizeOfActionError*(message: ActionError): uint64 =
    if hasunitTag(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt64(message.unitTag)
    if hasabilityId(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfUInt64(message.abilityId)
    if hasresult(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfEnum[ActionResult](message.result)
    result = result + sizeOfUnknownFields(message)

proc writeActionError*(stream: Stream, message: ActionError) =
    if hasunitTag(message):
        protoWriteUInt64(stream, message.unitTag, 1)
    if hasabilityId(message):
        protoWriteUInt64(stream, message.abilityId, 2)
    if hasresult(message):
        protoWriteEnum(stream, message.result, 3)
    writeUnknownFields(stream, message)

proc readActionError*(stream: Stream): ActionError =
    result = newActionError()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setunitTag(result, protoReadUInt64(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setabilityId(result, protoReadUInt64(stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setresult(result, protoReadEnum[ActionResult](stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionError): string =
    let
        ss = newStringStream()
    writeActionError(ss, message)
    result = ss.data

proc newActionError*(data: string): ActionError =
    let
        ss = newStringStream(data)
    result = readActionError(ss)

proc newActionError*(data: seq[byte]): ActionError =
    let
        ss = newStringStream(cast[string](data))
    result = readActionError(ss)


proc fullyQualifiedName*(T: typedesc[PlayerResult]): string = "PlayerResult"

proc readPlayerResultImpl(stream: Stream): Message = readPlayerResult(stream)
proc writePlayerResultImpl(stream: Stream, msg: Message) = writePlayerResult(stream, PlayerResult(msg))

proc PlayerResultProcs*(): MessageProcs =
    result.readImpl = readPlayerResultImpl
    result.writeImpl = writePlayerResultImpl

proc newPlayerResult*(): PlayerResult =
    new(result)
    initMessage(result[])
    result.procs = PlayerResultProcs()
    result.playerId = 0
    result.result = Result.Victory

proc clearplayerId*(message: PlayerResult) =
    message.playerId = 0
    clearFields(message, [1])

proc hasplayerId*(message: PlayerResult): bool =
    result = hasField(message, 1)

proc setplayerId*(message: PlayerResult, value: uint32) =
    message.playerId = value
    setField(message, 1)

proc playerId*(message: PlayerResult): uint32 {.inline.} =
    message.playerId

proc `playerId=`*(message: PlayerResult, value: uint32) {.inline.} =
    setplayerId(message, value)

proc clearresult*(message: PlayerResult) =
    message.result = Result.Victory
    clearFields(message, [2])

proc hasresult*(message: PlayerResult): bool =
    result = hasField(message, 2)

proc setresult*(message: PlayerResult, value: Result) =
    message.result = value
    setField(message, 2)

proc result*(message: PlayerResult): Result {.inline.} =
    message.result

proc `result=`*(message: PlayerResult, value: Result) {.inline.} =
    setresult(message, value)

proc `$`*(message: PlayerResult): string =
    runnableExamples:
        echo $PlayerResult
        echo fmt"{PlayerResult}"
        echo &"{PlayerResult}"
    var resultSeq: seq[string]
    if message.hasplayerId:
        resultSeq.add(&"playerId: {message.playerId}")
    if message.hasresult:
        resultSeq.add(&"result: {message.result}")
    result = resultSeq.join(", ")
    result = &"PlayerResult({result})"

proc sizeOfPlayerResult*(message: PlayerResult): uint64 =
    if hasplayerId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.playerId)
    if hasresult(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfEnum[Result](message.result)
    result = result + sizeOfUnknownFields(message)

proc writePlayerResult*(stream: Stream, message: PlayerResult) =
    if hasplayerId(message):
        protoWriteUInt32(stream, message.playerId, 1)
    if hasresult(message):
        protoWriteEnum(stream, message.result, 2)
    writeUnknownFields(stream, message)

proc readPlayerResult*(stream: Stream): PlayerResult =
    result = newPlayerResult()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setplayerId(result, protoReadUInt32(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setresult(result, protoReadEnum[Result](stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: PlayerResult): string =
    let
        ss = newStringStream()
    writePlayerResult(ss, message)
    result = ss.data

proc newPlayerResult*(data: string): PlayerResult =
    let
        ss = newStringStream(data)
    result = readPlayerResult(ss)

proc newPlayerResult*(data: seq[byte]): PlayerResult =
    let
        ss = newStringStream(cast[string](data))
    result = readPlayerResult(ss)


proc fullyQualifiedName*(T: typedesc[ResponseObservation]): string = "ResponseObservation"

proc readResponseObservationImpl(stream: Stream): Message = readResponseObservation(stream)
proc writeResponseObservationImpl(stream: Stream, msg: Message) = writeResponseObservation(stream, ResponseObservation(msg))

proc ResponseObservationProcs*(): MessageProcs =
    result.readImpl = readResponseObservationImpl
    result.writeImpl = writeResponseObservationImpl

proc newResponseObservation*(): ResponseObservation =
    new(result)
    initMessage(result[])
    result.procs = ResponseObservationProcs()
    result.actions = @[]
    result.actionErrors = @[]
    result.observation = nil
    result.playerResult = @[]
    result.chat = @[]

proc clearactions*(message: ResponseObservation) =
    message.actions = @[]
    clearFields(message, [1])

proc hasactions*(message: ResponseObservation): bool =
    result = hasField(message, 1) or (len(message.actions) > 0)

proc setactions*(message: ResponseObservation, value: seq[Action]) =
    message.actions = value
    setField(message, 1)

proc addactions*(message: ResponseObservation, value: Action) =
    add(message.actions, value)

proc actions*(message: ResponseObservation): seq[Action] {.inline.} =
    message.actions

proc `actions=`*(message: ResponseObservation, value: seq[Action]) {.inline.} =
    setactions(message, value)

proc clearactionErrors*(message: ResponseObservation) =
    message.actionErrors = @[]
    clearFields(message, [2])

proc hasactionErrors*(message: ResponseObservation): bool =
    result = hasField(message, 2) or (len(message.actionErrors) > 0)

proc setactionErrors*(message: ResponseObservation, value: seq[ActionError]) =
    message.actionErrors = value
    setField(message, 2)

proc addactionErrors*(message: ResponseObservation, value: ActionError) =
    add(message.actionErrors, value)

proc actionErrors*(message: ResponseObservation): seq[ActionError] {.inline.} =
    message.actionErrors

proc `actionErrors=`*(message: ResponseObservation, value: seq[ActionError]) {.inline.} =
    setactionErrors(message, value)

proc clearobservation*(message: ResponseObservation) =
    message.observation = nil
    clearFields(message, [3])

proc hasobservation*(message: ResponseObservation): bool =
    result = hasField(message, 3)

proc setobservation*(message: ResponseObservation, value: Observation) =
    message.observation = value
    setField(message, 3)

proc observation*(message: ResponseObservation): Observation {.inline.} =
    message.observation

proc `observation=`*(message: ResponseObservation, value: Observation) {.inline.} =
    setobservation(message, value)

proc clearplayerResult*(message: ResponseObservation) =
    message.playerResult = @[]
    clearFields(message, [4])

proc hasplayerResult*(message: ResponseObservation): bool =
    result = hasField(message, 4) or (len(message.playerResult) > 0)

proc setplayerResult*(message: ResponseObservation, value: seq[PlayerResult]) =
    message.playerResult = value
    setField(message, 4)

proc addplayerResult*(message: ResponseObservation, value: PlayerResult) =
    add(message.playerResult, value)

proc playerResult*(message: ResponseObservation): seq[PlayerResult] {.inline.} =
    message.playerResult

proc `playerResult=`*(message: ResponseObservation, value: seq[PlayerResult]) {.inline.} =
    setplayerResult(message, value)

proc clearchat*(message: ResponseObservation) =
    message.chat = @[]
    clearFields(message, [5])

proc haschat*(message: ResponseObservation): bool =
    result = hasField(message, 5) or (len(message.chat) > 0)

proc setchat*(message: ResponseObservation, value: seq[ChatReceived]) =
    message.chat = value
    setField(message, 5)

proc addchat*(message: ResponseObservation, value: ChatReceived) =
    add(message.chat, value)

proc chat*(message: ResponseObservation): seq[ChatReceived] {.inline.} =
    message.chat

proc `chat=`*(message: ResponseObservation, value: seq[ChatReceived]) {.inline.} =
    setchat(message, value)

proc `$`*(message: ResponseObservation): string =
    runnableExamples:
        echo $ResponseObservation
        echo fmt"{ResponseObservation}"
        echo &"{ResponseObservation}"
    var resultSeq: seq[string]
    if message.hasactions:
        resultSeq.add(&"actions: {message.actions}")
    if message.hasactionErrors:
        resultSeq.add(&"actionErrors: {message.actionErrors}")
    if message.hasobservation:
        resultSeq.add(&"observation: {message.observation}")
    if message.hasplayerResult:
        resultSeq.add(&"playerResult: {message.playerResult}")
    if message.haschat:
        resultSeq.add(&"chat: {message.chat}")
    result = resultSeq.join(", ")
    result = &"ResponseObservation({result})"

proc sizeOfResponseObservation*(message: ResponseObservation): uint64 =
    for value in message.actions:
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfAction(value))
    for value in message.actionErrors:
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionError(value))
    if hasobservation(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfObservation(message.observation))
    for value in message.playerResult:
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPlayerResult(value))
    for value in message.chat:
        result = result + sizeOfTag(5, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfChatReceived(value))
    result = result + sizeOfUnknownFields(message)

proc writeResponseObservation*(stream: Stream, message: ResponseObservation) =
    for value in message.actions:
        writeMessage(stream, value, 1)
    for value in message.actionErrors:
        writeMessage(stream, value, 2)
    if hasobservation(message):
        writeMessage(stream, message.observation, 3)
    for value in message.playerResult:
        writeMessage(stream, value, 4)
    for value in message.chat:
        writeMessage(stream, value, 5)
    writeUnknownFields(stream, message)

proc readResponseObservation*(stream: Stream): ResponseObservation =
    result = newResponseObservation()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addactions(result, newAction(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addactionErrors(result, newActionError(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setobservation(result, newObservation(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addplayerResult(result, newPlayerResult(data))
        of 5:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addchat(result, newChatReceived(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseObservation): string =
    let
        ss = newStringStream()
    writeResponseObservation(ss, message)
    result = ss.data

proc newResponseObservation*(data: string): ResponseObservation =
    let
        ss = newStringStream(data)
    result = readResponseObservation(ss)

proc newResponseObservation*(data: seq[byte]): ResponseObservation =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseObservation(ss)


proc fullyQualifiedName*(T: typedesc[ResponseMapCommand]): string = "ResponseMapCommand"

proc readResponseMapCommandImpl(stream: Stream): Message = readResponseMapCommand(stream)
proc writeResponseMapCommandImpl(stream: Stream, msg: Message) = writeResponseMapCommand(stream, ResponseMapCommand(msg))

proc ResponseMapCommandProcs*(): MessageProcs =
    result.readImpl = readResponseMapCommandImpl
    result.writeImpl = writeResponseMapCommandImpl

proc newResponseMapCommand*(): ResponseMapCommand =
    new(result)
    initMessage(result[])
    result.procs = ResponseMapCommandProcs()
    result.error = ResponseMapCommand_Error.NoTriggerError
    result.errorDetails = ""

proc clearerror*(message: ResponseMapCommand) =
    message.error = ResponseMapCommand_Error.NoTriggerError
    clearFields(message, [1])

proc haserror*(message: ResponseMapCommand): bool =
    result = hasField(message, 1)

proc seterror*(message: ResponseMapCommand, value: ResponseMapCommand_Error) =
    message.error = value
    setField(message, 1)

proc error*(message: ResponseMapCommand): ResponseMapCommand_Error {.inline.} =
    message.error

proc `error=`*(message: ResponseMapCommand, value: ResponseMapCommand_Error) {.inline.} =
    seterror(message, value)

proc clearerrorDetails*(message: ResponseMapCommand) =
    message.errorDetails = ""
    clearFields(message, [2])

proc haserrorDetails*(message: ResponseMapCommand): bool =
    result = hasField(message, 2)

proc seterrorDetails*(message: ResponseMapCommand, value: string) =
    message.errorDetails = value
    setField(message, 2)

proc errorDetails*(message: ResponseMapCommand): string {.inline.} =
    message.errorDetails

proc `errorDetails=`*(message: ResponseMapCommand, value: string) {.inline.} =
    seterrorDetails(message, value)

proc `$`*(message: ResponseMapCommand): string =
    runnableExamples:
        echo $ResponseMapCommand
        echo fmt"{ResponseMapCommand}"
        echo &"{ResponseMapCommand}"
    var resultSeq: seq[string]
    if message.haserror:
        resultSeq.add(&"error: {message.error}")
    if message.haserrorDetails:
        resultSeq.add(&"errorDetails: {message.errorDetails}")
    result = resultSeq.join(", ")
    result = &"ResponseMapCommand({result})"

proc sizeOfResponseMapCommand*(message: ResponseMapCommand): uint64 =
    if haserror(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfEnum[ResponseMapCommand_Error](message.error)
    if haserrorDetails(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfString(message.errorDetails)
    result = result + sizeOfUnknownFields(message)

proc writeResponseMapCommand*(stream: Stream, message: ResponseMapCommand) =
    if haserror(message):
        protoWriteEnum(stream, message.error, 1)
    if haserrorDetails(message):
        protoWriteString(stream, message.errorDetails, 2)
    writeUnknownFields(stream, message)

proc readResponseMapCommand*(stream: Stream): ResponseMapCommand =
    result = newResponseMapCommand()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            seterror(result, protoReadEnum[ResponseMapCommand_Error](stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            seterrorDetails(result, protoReadString(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseMapCommand): string =
    let
        ss = newStringStream()
    writeResponseMapCommand(ss, message)
    result = ss.data

proc newResponseMapCommand*(data: string): ResponseMapCommand =
    let
        ss = newStringStream(data)
    result = readResponseMapCommand(ss)

proc newResponseMapCommand*(data: seq[byte]): ResponseMapCommand =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseMapCommand(ss)


proc fullyQualifiedName*(T: typedesc[RequestQuickLoad]): string = "RequestQuickLoad"

proc readRequestQuickLoadImpl(stream: Stream): Message = readRequestQuickLoad(stream)
proc writeRequestQuickLoadImpl(stream: Stream, msg: Message) = writeRequestQuickLoad(stream, RequestQuickLoad(msg))

proc RequestQuickLoadProcs*(): MessageProcs =
    result.readImpl = readRequestQuickLoadImpl
    result.writeImpl = writeRequestQuickLoadImpl

proc newRequestQuickLoad*(): RequestQuickLoad =
    new(result)
    initMessage(result[])
    result.procs = RequestQuickLoadProcs()

proc `$`*(message: RequestQuickLoad): string =
    runnableExamples:
        echo $RequestQuickLoad
        echo fmt"{RequestQuickLoad}"
        echo &"{RequestQuickLoad}"
    var resultSeq: seq[string]
    result = resultSeq.join(", ")
    result = &"RequestQuickLoad({result})"

proc sizeOfRequestQuickLoad*(message: RequestQuickLoad): uint64 =
    result = result + sizeOfUnknownFields(message)

proc writeRequestQuickLoad*(stream: Stream, message: RequestQuickLoad) =
    writeUnknownFields(stream, message)

proc readRequestQuickLoad*(stream: Stream): RequestQuickLoad =
    result = newRequestQuickLoad()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestQuickLoad): string =
    let
        ss = newStringStream()
    writeRequestQuickLoad(ss, message)
    result = ss.data

proc newRequestQuickLoad*(data: string): RequestQuickLoad =
    let
        ss = newStringStream(data)
    result = readRequestQuickLoad(ss)

proc newRequestQuickLoad*(data: seq[byte]): RequestQuickLoad =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestQuickLoad(ss)


proc fullyQualifiedName*(T: typedesc[PlayerSetup]): string = "PlayerSetup"

proc readPlayerSetupImpl(stream: Stream): Message = readPlayerSetup(stream)
proc writePlayerSetupImpl(stream: Stream, msg: Message) = writePlayerSetup(stream, PlayerSetup(msg))

proc PlayerSetupProcs*(): MessageProcs =
    result.readImpl = readPlayerSetupImpl
    result.writeImpl = writePlayerSetupImpl

proc newPlayerSetup*(): PlayerSetup =
    new(result)
    initMessage(result[])
    result.procs = PlayerSetupProcs()
    result.ftype = PlayerType.Participant
    result.race = Race.NoRace
    result.difficulty = Difficulty.VeryEasy
    result.playerName = ""
    result.aiBuild = AIBuild.RandomBuild

proc clearftype*(message: PlayerSetup) =
    message.ftype = PlayerType.Participant
    clearFields(message, [1])

proc hasftype*(message: PlayerSetup): bool =
    result = hasField(message, 1)

proc setftype*(message: PlayerSetup, value: PlayerType) =
    message.ftype = value
    setField(message, 1)

proc ftype*(message: PlayerSetup): PlayerType {.inline.} =
    message.ftype

proc `ftype=`*(message: PlayerSetup, value: PlayerType) {.inline.} =
    setftype(message, value)

proc clearrace*(message: PlayerSetup) =
    message.race = Race.NoRace
    clearFields(message, [2])

proc hasrace*(message: PlayerSetup): bool =
    result = hasField(message, 2)

proc setrace*(message: PlayerSetup, value: Race) =
    message.race = value
    setField(message, 2)

proc race*(message: PlayerSetup): Race {.inline.} =
    message.race

proc `race=`*(message: PlayerSetup, value: Race) {.inline.} =
    setrace(message, value)

proc cleardifficulty*(message: PlayerSetup) =
    message.difficulty = Difficulty.VeryEasy
    clearFields(message, [3])

proc hasdifficulty*(message: PlayerSetup): bool =
    result = hasField(message, 3)

proc setdifficulty*(message: PlayerSetup, value: Difficulty) =
    message.difficulty = value
    setField(message, 3)

proc difficulty*(message: PlayerSetup): Difficulty {.inline.} =
    message.difficulty

proc `difficulty=`*(message: PlayerSetup, value: Difficulty) {.inline.} =
    setdifficulty(message, value)

proc clearplayerName*(message: PlayerSetup) =
    message.playerName = ""
    clearFields(message, [4])

proc hasplayerName*(message: PlayerSetup): bool =
    result = hasField(message, 4)

proc setplayerName*(message: PlayerSetup, value: string) =
    message.playerName = value
    setField(message, 4)

proc playerName*(message: PlayerSetup): string {.inline.} =
    message.playerName

proc `playerName=`*(message: PlayerSetup, value: string) {.inline.} =
    setplayerName(message, value)

proc clearaiBuild*(message: PlayerSetup) =
    message.aiBuild = AIBuild.RandomBuild
    clearFields(message, [5])

proc hasaiBuild*(message: PlayerSetup): bool =
    result = hasField(message, 5)

proc setaiBuild*(message: PlayerSetup, value: AIBuild) =
    message.aiBuild = value
    setField(message, 5)

proc aiBuild*(message: PlayerSetup): AIBuild {.inline.} =
    message.aiBuild

proc `aiBuild=`*(message: PlayerSetup, value: AIBuild) {.inline.} =
    setaiBuild(message, value)

proc `$`*(message: PlayerSetup): string =
    runnableExamples:
        echo $PlayerSetup
        echo fmt"{PlayerSetup}"
        echo &"{PlayerSetup}"
    var resultSeq: seq[string]
    if message.hasftype:
        resultSeq.add(&"ftype: {message.ftype}")
    if message.hasrace:
        resultSeq.add(&"race: {message.race}")
    if message.hasdifficulty:
        resultSeq.add(&"difficulty: {message.difficulty}")
    if message.hasplayerName:
        resultSeq.add(&"playerName: {message.playerName}")
    if message.hasaiBuild:
        resultSeq.add(&"aiBuild: {message.aiBuild}")
    result = resultSeq.join(", ")
    result = &"PlayerSetup({result})"

proc sizeOfPlayerSetup*(message: PlayerSetup): uint64 =
    if hasftype(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfEnum[PlayerType](message.ftype)
    if hasrace(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfEnum[Race](message.race)
    if hasdifficulty(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfEnum[Difficulty](message.difficulty)
    if hasplayerName(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfString(message.playerName)
    if hasaiBuild(message):
        result = result + sizeOfTag(5, WireType.Varint)
        result = result + sizeOfEnum[AIBuild](message.aiBuild)
    result = result + sizeOfUnknownFields(message)

proc writePlayerSetup*(stream: Stream, message: PlayerSetup) =
    if hasftype(message):
        protoWriteEnum(stream, message.ftype, 1)
    if hasrace(message):
        protoWriteEnum(stream, message.race, 2)
    if hasdifficulty(message):
        protoWriteEnum(stream, message.difficulty, 3)
    if hasplayerName(message):
        protoWriteString(stream, message.playerName, 4)
    if hasaiBuild(message):
        protoWriteEnum(stream, message.aiBuild, 5)
    writeUnknownFields(stream, message)

proc readPlayerSetup*(stream: Stream): PlayerSetup =
    result = newPlayerSetup()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setftype(result, protoReadEnum[PlayerType](stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setrace(result, protoReadEnum[Race](stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setdifficulty(result, protoReadEnum[Difficulty](stream))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            setplayerName(result, protoReadString(stream))
        of 5:
            expectWireType(wireType, WireType.Varint)
            setaiBuild(result, protoReadEnum[AIBuild](stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: PlayerSetup): string =
    let
        ss = newStringStream()
    writePlayerSetup(ss, message)
    result = ss.data

proc newPlayerSetup*(data: string): PlayerSetup =
    let
        ss = newStringStream(data)
    result = readPlayerSetup(ss)

proc newPlayerSetup*(data: seq[byte]): PlayerSetup =
    let
        ss = newStringStream(cast[string](data))
    result = readPlayerSetup(ss)


proc fullyQualifiedName*(T: typedesc[RequestStep]): string = "RequestStep"

proc readRequestStepImpl(stream: Stream): Message = readRequestStep(stream)
proc writeRequestStepImpl(stream: Stream, msg: Message) = writeRequestStep(stream, RequestStep(msg))

proc RequestStepProcs*(): MessageProcs =
    result.readImpl = readRequestStepImpl
    result.writeImpl = writeRequestStepImpl

proc newRequestStep*(): RequestStep =
    new(result)
    initMessage(result[])
    result.procs = RequestStepProcs()
    result.count = 0

proc clearcount*(message: RequestStep) =
    message.count = 0
    clearFields(message, [1])

proc hascount*(message: RequestStep): bool =
    result = hasField(message, 1)

proc setcount*(message: RequestStep, value: uint32) =
    message.count = value
    setField(message, 1)

proc count*(message: RequestStep): uint32 {.inline.} =
    message.count

proc `count=`*(message: RequestStep, value: uint32) {.inline.} =
    setcount(message, value)

proc `$`*(message: RequestStep): string =
    runnableExamples:
        echo $RequestStep
        echo fmt"{RequestStep}"
        echo &"{RequestStep}"
    var resultSeq: seq[string]
    if message.hascount:
        resultSeq.add(&"count: {message.count}")
    result = resultSeq.join(", ")
    result = &"RequestStep({result})"

proc sizeOfRequestStep*(message: RequestStep): uint64 =
    if hascount(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.count)
    result = result + sizeOfUnknownFields(message)

proc writeRequestStep*(stream: Stream, message: RequestStep) =
    if hascount(message):
        protoWriteUInt32(stream, message.count, 1)
    writeUnknownFields(stream, message)

proc readRequestStep*(stream: Stream): RequestStep =
    result = newRequestStep()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setcount(result, protoReadUInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestStep): string =
    let
        ss = newStringStream()
    writeRequestStep(ss, message)
    result = ss.data

proc newRequestStep*(data: string): RequestStep =
    let
        ss = newStringStream(data)
    result = readRequestStep(ss)

proc newRequestStep*(data: seq[byte]): RequestStep =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestStep(ss)


proc fullyQualifiedName*(T: typedesc[RequestMapCommand]): string = "RequestMapCommand"

proc readRequestMapCommandImpl(stream: Stream): Message = readRequestMapCommand(stream)
proc writeRequestMapCommandImpl(stream: Stream, msg: Message) = writeRequestMapCommand(stream, RequestMapCommand(msg))

proc RequestMapCommandProcs*(): MessageProcs =
    result.readImpl = readRequestMapCommandImpl
    result.writeImpl = writeRequestMapCommandImpl

proc newRequestMapCommand*(): RequestMapCommand =
    new(result)
    initMessage(result[])
    result.procs = RequestMapCommandProcs()
    result.triggerCmd = ""

proc cleartriggerCmd*(message: RequestMapCommand) =
    message.triggerCmd = ""
    clearFields(message, [1])

proc hastriggerCmd*(message: RequestMapCommand): bool =
    result = hasField(message, 1)

proc settriggerCmd*(message: RequestMapCommand, value: string) =
    message.triggerCmd = value
    setField(message, 1)

proc triggerCmd*(message: RequestMapCommand): string {.inline.} =
    message.triggerCmd

proc `triggerCmd=`*(message: RequestMapCommand, value: string) {.inline.} =
    settriggerCmd(message, value)

proc `$`*(message: RequestMapCommand): string =
    runnableExamples:
        echo $RequestMapCommand
        echo fmt"{RequestMapCommand}"
        echo &"{RequestMapCommand}"
    var resultSeq: seq[string]
    if message.hastriggerCmd:
        resultSeq.add(&"triggerCmd: {message.triggerCmd}")
    result = resultSeq.join(", ")
    result = &"RequestMapCommand({result})"

proc sizeOfRequestMapCommand*(message: RequestMapCommand): uint64 =
    if hastriggerCmd(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfString(message.triggerCmd)
    result = result + sizeOfUnknownFields(message)

proc writeRequestMapCommand*(stream: Stream, message: RequestMapCommand) =
    if hastriggerCmd(message):
        protoWriteString(stream, message.triggerCmd, 1)
    writeUnknownFields(stream, message)

proc readRequestMapCommand*(stream: Stream): RequestMapCommand =
    result = newRequestMapCommand()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            settriggerCmd(result, protoReadString(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestMapCommand): string =
    let
        ss = newStringStream()
    writeRequestMapCommand(ss, message)
    result = ss.data

proc newRequestMapCommand*(data: string): RequestMapCommand =
    let
        ss = newStringStream(data)
    result = readRequestMapCommand(ss)

proc newRequestMapCommand*(data: seq[byte]): RequestMapCommand =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestMapCommand(ss)


proc fullyQualifiedName*(T: typedesc[ResponseSaveMap]): string = "ResponseSaveMap"

proc readResponseSaveMapImpl(stream: Stream): Message = readResponseSaveMap(stream)
proc writeResponseSaveMapImpl(stream: Stream, msg: Message) = writeResponseSaveMap(stream, ResponseSaveMap(msg))

proc ResponseSaveMapProcs*(): MessageProcs =
    result.readImpl = readResponseSaveMapImpl
    result.writeImpl = writeResponseSaveMapImpl

proc newResponseSaveMap*(): ResponseSaveMap =
    new(result)
    initMessage(result[])
    result.procs = ResponseSaveMapProcs()
    result.error = ResponseSaveMap_Error.InvalidMapData

proc clearerror*(message: ResponseSaveMap) =
    message.error = ResponseSaveMap_Error.InvalidMapData
    clearFields(message, [1])

proc haserror*(message: ResponseSaveMap): bool =
    result = hasField(message, 1)

proc seterror*(message: ResponseSaveMap, value: ResponseSaveMap_Error) =
    message.error = value
    setField(message, 1)

proc error*(message: ResponseSaveMap): ResponseSaveMap_Error {.inline.} =
    message.error

proc `error=`*(message: ResponseSaveMap, value: ResponseSaveMap_Error) {.inline.} =
    seterror(message, value)

proc `$`*(message: ResponseSaveMap): string =
    runnableExamples:
        echo $ResponseSaveMap
        echo fmt"{ResponseSaveMap}"
        echo &"{ResponseSaveMap}"
    var resultSeq: seq[string]
    if message.haserror:
        resultSeq.add(&"error: {message.error}")
    result = resultSeq.join(", ")
    result = &"ResponseSaveMap({result})"

proc sizeOfResponseSaveMap*(message: ResponseSaveMap): uint64 =
    if haserror(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfEnum[ResponseSaveMap_Error](message.error)
    result = result + sizeOfUnknownFields(message)

proc writeResponseSaveMap*(stream: Stream, message: ResponseSaveMap) =
    if haserror(message):
        protoWriteEnum(stream, message.error, 1)
    writeUnknownFields(stream, message)

proc readResponseSaveMap*(stream: Stream): ResponseSaveMap =
    result = newResponseSaveMap()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            seterror(result, protoReadEnum[ResponseSaveMap_Error](stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseSaveMap): string =
    let
        ss = newStringStream()
    writeResponseSaveMap(ss, message)
    result = ss.data

proc newResponseSaveMap*(data: string): ResponseSaveMap =
    let
        ss = newStringStream(data)
    result = readResponseSaveMap(ss)

proc newResponseSaveMap*(data: seq[byte]): ResponseSaveMap =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseSaveMap(ss)


proc fullyQualifiedName*(T: typedesc[ResponseCreateGame]): string = "ResponseCreateGame"

proc readResponseCreateGameImpl(stream: Stream): Message = readResponseCreateGame(stream)
proc writeResponseCreateGameImpl(stream: Stream, msg: Message) = writeResponseCreateGame(stream, ResponseCreateGame(msg))

proc ResponseCreateGameProcs*(): MessageProcs =
    result.readImpl = readResponseCreateGameImpl
    result.writeImpl = writeResponseCreateGameImpl

proc newResponseCreateGame*(): ResponseCreateGame =
    new(result)
    initMessage(result[])
    result.procs = ResponseCreateGameProcs()
    result.error = ResponseCreateGame_Error.MissingMap
    result.errorDetails = ""

proc clearerror*(message: ResponseCreateGame) =
    message.error = ResponseCreateGame_Error.MissingMap
    clearFields(message, [1])

proc haserror*(message: ResponseCreateGame): bool =
    result = hasField(message, 1)

proc seterror*(message: ResponseCreateGame, value: ResponseCreateGame_Error) =
    message.error = value
    setField(message, 1)

proc error*(message: ResponseCreateGame): ResponseCreateGame_Error {.inline.} =
    message.error

proc `error=`*(message: ResponseCreateGame, value: ResponseCreateGame_Error) {.inline.} =
    seterror(message, value)

proc clearerrorDetails*(message: ResponseCreateGame) =
    message.errorDetails = ""
    clearFields(message, [2])

proc haserrorDetails*(message: ResponseCreateGame): bool =
    result = hasField(message, 2)

proc seterrorDetails*(message: ResponseCreateGame, value: string) =
    message.errorDetails = value
    setField(message, 2)

proc errorDetails*(message: ResponseCreateGame): string {.inline.} =
    message.errorDetails

proc `errorDetails=`*(message: ResponseCreateGame, value: string) {.inline.} =
    seterrorDetails(message, value)

proc `$`*(message: ResponseCreateGame): string =
    runnableExamples:
        echo $ResponseCreateGame
        echo fmt"{ResponseCreateGame}"
        echo &"{ResponseCreateGame}"
    var resultSeq: seq[string]
    if message.haserror:
        resultSeq.add(&"error: {message.error}")
    if message.haserrorDetails:
        resultSeq.add(&"errorDetails: {message.errorDetails}")
    result = resultSeq.join(", ")
    result = &"ResponseCreateGame({result})"

proc sizeOfResponseCreateGame*(message: ResponseCreateGame): uint64 =
    if haserror(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfEnum[ResponseCreateGame_Error](message.error)
    if haserrorDetails(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfString(message.errorDetails)
    result = result + sizeOfUnknownFields(message)

proc writeResponseCreateGame*(stream: Stream, message: ResponseCreateGame) =
    if haserror(message):
        protoWriteEnum(stream, message.error, 1)
    if haserrorDetails(message):
        protoWriteString(stream, message.errorDetails, 2)
    writeUnknownFields(stream, message)

proc readResponseCreateGame*(stream: Stream): ResponseCreateGame =
    result = newResponseCreateGame()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            seterror(result, protoReadEnum[ResponseCreateGame_Error](stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            seterrorDetails(result, protoReadString(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseCreateGame): string =
    let
        ss = newStringStream()
    writeResponseCreateGame(ss, message)
    result = ss.data

proc newResponseCreateGame*(data: string): ResponseCreateGame =
    let
        ss = newStringStream(data)
    result = readResponseCreateGame(ss)

proc newResponseCreateGame*(data: seq[byte]): ResponseCreateGame =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseCreateGame(ss)


proc fullyQualifiedName*(T: typedesc[ResponseLeaveGame]): string = "ResponseLeaveGame"

proc readResponseLeaveGameImpl(stream: Stream): Message = readResponseLeaveGame(stream)
proc writeResponseLeaveGameImpl(stream: Stream, msg: Message) = writeResponseLeaveGame(stream, ResponseLeaveGame(msg))

proc ResponseLeaveGameProcs*(): MessageProcs =
    result.readImpl = readResponseLeaveGameImpl
    result.writeImpl = writeResponseLeaveGameImpl

proc newResponseLeaveGame*(): ResponseLeaveGame =
    new(result)
    initMessage(result[])
    result.procs = ResponseLeaveGameProcs()

proc `$`*(message: ResponseLeaveGame): string =
    runnableExamples:
        echo $ResponseLeaveGame
        echo fmt"{ResponseLeaveGame}"
        echo &"{ResponseLeaveGame}"
    var resultSeq: seq[string]
    result = resultSeq.join(", ")
    result = &"ResponseLeaveGame({result})"

proc sizeOfResponseLeaveGame*(message: ResponseLeaveGame): uint64 =
    result = result + sizeOfUnknownFields(message)

proc writeResponseLeaveGame*(stream: Stream, message: ResponseLeaveGame) =
    writeUnknownFields(stream, message)

proc readResponseLeaveGame*(stream: Stream): ResponseLeaveGame =
    result = newResponseLeaveGame()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseLeaveGame): string =
    let
        ss = newStringStream()
    writeResponseLeaveGame(ss, message)
    result = ss.data

proc newResponseLeaveGame*(data: string): ResponseLeaveGame =
    let
        ss = newStringStream(data)
    result = readResponseLeaveGame(ss)

proc newResponseLeaveGame*(data: seq[byte]): ResponseLeaveGame =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseLeaveGame(ss)


proc fullyQualifiedName*(T: typedesc[PlayerInfo]): string = "PlayerInfo"

proc readPlayerInfoImpl(stream: Stream): Message = readPlayerInfo(stream)
proc writePlayerInfoImpl(stream: Stream, msg: Message) = writePlayerInfo(stream, PlayerInfo(msg))

proc PlayerInfoProcs*(): MessageProcs =
    result.readImpl = readPlayerInfoImpl
    result.writeImpl = writePlayerInfoImpl

proc newPlayerInfo*(): PlayerInfo =
    new(result)
    initMessage(result[])
    result.procs = PlayerInfoProcs()
    result.playerId = 0
    result.ftype = PlayerType.Participant
    result.raceRequested = Race.NoRace
    result.raceActual = Race.NoRace
    result.difficulty = Difficulty.VeryEasy
    result.aiBuild = AIBuild.RandomBuild
    result.playerName = ""

proc clearplayerId*(message: PlayerInfo) =
    message.playerId = 0
    clearFields(message, [1])

proc hasplayerId*(message: PlayerInfo): bool =
    result = hasField(message, 1)

proc setplayerId*(message: PlayerInfo, value: uint32) =
    message.playerId = value
    setField(message, 1)

proc playerId*(message: PlayerInfo): uint32 {.inline.} =
    message.playerId

proc `playerId=`*(message: PlayerInfo, value: uint32) {.inline.} =
    setplayerId(message, value)

proc clearftype*(message: PlayerInfo) =
    message.ftype = PlayerType.Participant
    clearFields(message, [2])

proc hasftype*(message: PlayerInfo): bool =
    result = hasField(message, 2)

proc setftype*(message: PlayerInfo, value: PlayerType) =
    message.ftype = value
    setField(message, 2)

proc ftype*(message: PlayerInfo): PlayerType {.inline.} =
    message.ftype

proc `ftype=`*(message: PlayerInfo, value: PlayerType) {.inline.} =
    setftype(message, value)

proc clearraceRequested*(message: PlayerInfo) =
    message.raceRequested = Race.NoRace
    clearFields(message, [3])

proc hasraceRequested*(message: PlayerInfo): bool =
    result = hasField(message, 3)

proc setraceRequested*(message: PlayerInfo, value: Race) =
    message.raceRequested = value
    setField(message, 3)

proc raceRequested*(message: PlayerInfo): Race {.inline.} =
    message.raceRequested

proc `raceRequested=`*(message: PlayerInfo, value: Race) {.inline.} =
    setraceRequested(message, value)

proc clearraceActual*(message: PlayerInfo) =
    message.raceActual = Race.NoRace
    clearFields(message, [4])

proc hasraceActual*(message: PlayerInfo): bool =
    result = hasField(message, 4)

proc setraceActual*(message: PlayerInfo, value: Race) =
    message.raceActual = value
    setField(message, 4)

proc raceActual*(message: PlayerInfo): Race {.inline.} =
    message.raceActual

proc `raceActual=`*(message: PlayerInfo, value: Race) {.inline.} =
    setraceActual(message, value)

proc cleardifficulty*(message: PlayerInfo) =
    message.difficulty = Difficulty.VeryEasy
    clearFields(message, [5])

proc hasdifficulty*(message: PlayerInfo): bool =
    result = hasField(message, 5)

proc setdifficulty*(message: PlayerInfo, value: Difficulty) =
    message.difficulty = value
    setField(message, 5)

proc difficulty*(message: PlayerInfo): Difficulty {.inline.} =
    message.difficulty

proc `difficulty=`*(message: PlayerInfo, value: Difficulty) {.inline.} =
    setdifficulty(message, value)

proc clearaiBuild*(message: PlayerInfo) =
    message.aiBuild = AIBuild.RandomBuild
    clearFields(message, [7])

proc hasaiBuild*(message: PlayerInfo): bool =
    result = hasField(message, 7)

proc setaiBuild*(message: PlayerInfo, value: AIBuild) =
    message.aiBuild = value
    setField(message, 7)

proc aiBuild*(message: PlayerInfo): AIBuild {.inline.} =
    message.aiBuild

proc `aiBuild=`*(message: PlayerInfo, value: AIBuild) {.inline.} =
    setaiBuild(message, value)

proc clearplayerName*(message: PlayerInfo) =
    message.playerName = ""
    clearFields(message, [6])

proc hasplayerName*(message: PlayerInfo): bool =
    result = hasField(message, 6)

proc setplayerName*(message: PlayerInfo, value: string) =
    message.playerName = value
    setField(message, 6)

proc playerName*(message: PlayerInfo): string {.inline.} =
    message.playerName

proc `playerName=`*(message: PlayerInfo, value: string) {.inline.} =
    setplayerName(message, value)

proc `$`*(message: PlayerInfo): string =
    runnableExamples:
        echo $PlayerInfo
        echo fmt"{PlayerInfo}"
        echo &"{PlayerInfo}"
    var resultSeq: seq[string]
    if message.hasplayerId:
        resultSeq.add(&"playerId: {message.playerId}")
    if message.hasftype:
        resultSeq.add(&"ftype: {message.ftype}")
    if message.hasraceRequested:
        resultSeq.add(&"raceRequested: {message.raceRequested}")
    if message.hasraceActual:
        resultSeq.add(&"raceActual: {message.raceActual}")
    if message.hasdifficulty:
        resultSeq.add(&"difficulty: {message.difficulty}")
    if message.hasaiBuild:
        resultSeq.add(&"aiBuild: {message.aiBuild}")
    if message.hasplayerName:
        resultSeq.add(&"playerName: {message.playerName}")
    result = resultSeq.join(", ")
    result = &"PlayerInfo({result})"

proc sizeOfPlayerInfo*(message: PlayerInfo): uint64 =
    if hasplayerId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.playerId)
    if hasftype(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfEnum[PlayerType](message.ftype)
    if hasraceRequested(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfEnum[Race](message.raceRequested)
    if hasraceActual(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfEnum[Race](message.raceActual)
    if hasdifficulty(message):
        result = result + sizeOfTag(5, WireType.Varint)
        result = result + sizeOfEnum[Difficulty](message.difficulty)
    if hasaiBuild(message):
        result = result + sizeOfTag(7, WireType.Varint)
        result = result + sizeOfEnum[AIBuild](message.aiBuild)
    if hasplayerName(message):
        result = result + sizeOfTag(6, WireType.LengthDelimited)
        result = result + sizeOfString(message.playerName)
    result = result + sizeOfUnknownFields(message)

proc writePlayerInfo*(stream: Stream, message: PlayerInfo) =
    if hasplayerId(message):
        protoWriteUInt32(stream, message.playerId, 1)
    if hasftype(message):
        protoWriteEnum(stream, message.ftype, 2)
    if hasraceRequested(message):
        protoWriteEnum(stream, message.raceRequested, 3)
    if hasraceActual(message):
        protoWriteEnum(stream, message.raceActual, 4)
    if hasdifficulty(message):
        protoWriteEnum(stream, message.difficulty, 5)
    if hasaiBuild(message):
        protoWriteEnum(stream, message.aiBuild, 7)
    if hasplayerName(message):
        protoWriteString(stream, message.playerName, 6)
    writeUnknownFields(stream, message)

proc readPlayerInfo*(stream: Stream): PlayerInfo =
    result = newPlayerInfo()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setplayerId(result, protoReadUInt32(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setftype(result, protoReadEnum[PlayerType](stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setraceRequested(result, protoReadEnum[Race](stream))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setraceActual(result, protoReadEnum[Race](stream))
        of 5:
            expectWireType(wireType, WireType.Varint)
            setdifficulty(result, protoReadEnum[Difficulty](stream))
        of 7:
            expectWireType(wireType, WireType.Varint)
            setaiBuild(result, protoReadEnum[AIBuild](stream))
        of 6:
            expectWireType(wireType, WireType.LengthDelimited)
            setplayerName(result, protoReadString(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: PlayerInfo): string =
    let
        ss = newStringStream()
    writePlayerInfo(ss, message)
    result = ss.data

proc newPlayerInfo*(data: string): PlayerInfo =
    let
        ss = newStringStream(data)
    result = readPlayerInfo(ss)

proc newPlayerInfo*(data: seq[byte]): PlayerInfo =
    let
        ss = newStringStream(cast[string](data))
    result = readPlayerInfo(ss)


proc fullyQualifiedName*(T: typedesc[PlayerInfoExtra]): string = "PlayerInfoExtra"

proc readPlayerInfoExtraImpl(stream: Stream): Message = readPlayerInfoExtra(stream)
proc writePlayerInfoExtraImpl(stream: Stream, msg: Message) = writePlayerInfoExtra(stream, PlayerInfoExtra(msg))

proc PlayerInfoExtraProcs*(): MessageProcs =
    result.readImpl = readPlayerInfoExtraImpl
    result.writeImpl = writePlayerInfoExtraImpl

proc newPlayerInfoExtra*(): PlayerInfoExtra =
    new(result)
    initMessage(result[])
    result.procs = PlayerInfoExtraProcs()
    result.playerInfo = nil
    result.playerResult = nil
    result.playerMmr = 0
    result.playerApm = 0

proc clearplayerInfo*(message: PlayerInfoExtra) =
    message.playerInfo = nil
    clearFields(message, [1])

proc hasplayerInfo*(message: PlayerInfoExtra): bool =
    result = hasField(message, 1)

proc setplayerInfo*(message: PlayerInfoExtra, value: PlayerInfo) =
    message.playerInfo = value
    setField(message, 1)

proc playerInfo*(message: PlayerInfoExtra): PlayerInfo {.inline.} =
    message.playerInfo

proc `playerInfo=`*(message: PlayerInfoExtra, value: PlayerInfo) {.inline.} =
    setplayerInfo(message, value)

proc clearplayerResult*(message: PlayerInfoExtra) =
    message.playerResult = nil
    clearFields(message, [2])

proc hasplayerResult*(message: PlayerInfoExtra): bool =
    result = hasField(message, 2)

proc setplayerResult*(message: PlayerInfoExtra, value: PlayerResult) =
    message.playerResult = value
    setField(message, 2)

proc playerResult*(message: PlayerInfoExtra): PlayerResult {.inline.} =
    message.playerResult

proc `playerResult=`*(message: PlayerInfoExtra, value: PlayerResult) {.inline.} =
    setplayerResult(message, value)

proc clearplayerMmr*(message: PlayerInfoExtra) =
    message.playerMmr = 0
    clearFields(message, [3])

proc hasplayerMmr*(message: PlayerInfoExtra): bool =
    result = hasField(message, 3)

proc setplayerMmr*(message: PlayerInfoExtra, value: int32) =
    message.playerMmr = value
    setField(message, 3)

proc playerMmr*(message: PlayerInfoExtra): int32 {.inline.} =
    message.playerMmr

proc `playerMmr=`*(message: PlayerInfoExtra, value: int32) {.inline.} =
    setplayerMmr(message, value)

proc clearplayerApm*(message: PlayerInfoExtra) =
    message.playerApm = 0
    clearFields(message, [4])

proc hasplayerApm*(message: PlayerInfoExtra): bool =
    result = hasField(message, 4)

proc setplayerApm*(message: PlayerInfoExtra, value: int32) =
    message.playerApm = value
    setField(message, 4)

proc playerApm*(message: PlayerInfoExtra): int32 {.inline.} =
    message.playerApm

proc `playerApm=`*(message: PlayerInfoExtra, value: int32) {.inline.} =
    setplayerApm(message, value)

proc `$`*(message: PlayerInfoExtra): string =
    runnableExamples:
        echo $PlayerInfoExtra
        echo fmt"{PlayerInfoExtra}"
        echo &"{PlayerInfoExtra}"
    var resultSeq: seq[string]
    if message.hasplayerInfo:
        resultSeq.add(&"playerInfo: {message.playerInfo}")
    if message.hasplayerResult:
        resultSeq.add(&"playerResult: {message.playerResult}")
    if message.hasplayerMmr:
        resultSeq.add(&"playerMmr: {message.playerMmr}")
    if message.hasplayerApm:
        resultSeq.add(&"playerApm: {message.playerApm}")
    result = resultSeq.join(", ")
    result = &"PlayerInfoExtra({result})"

proc sizeOfPlayerInfoExtra*(message: PlayerInfoExtra): uint64 =
    if hasplayerInfo(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPlayerInfo(message.playerInfo))
    if hasplayerResult(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPlayerResult(message.playerResult))
    if hasplayerMmr(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfInt32(message.playerMmr)
    if hasplayerApm(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfInt32(message.playerApm)
    result = result + sizeOfUnknownFields(message)

proc writePlayerInfoExtra*(stream: Stream, message: PlayerInfoExtra) =
    if hasplayerInfo(message):
        writeMessage(stream, message.playerInfo, 1)
    if hasplayerResult(message):
        writeMessage(stream, message.playerResult, 2)
    if hasplayerMmr(message):
        protoWriteInt32(stream, message.playerMmr, 3)
    if hasplayerApm(message):
        protoWriteInt32(stream, message.playerApm, 4)
    writeUnknownFields(stream, message)

proc readPlayerInfoExtra*(stream: Stream): PlayerInfoExtra =
    result = newPlayerInfoExtra()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setplayerInfo(result, newPlayerInfo(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setplayerResult(result, newPlayerResult(data))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setplayerMmr(result, protoReadInt32(stream))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setplayerApm(result, protoReadInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: PlayerInfoExtra): string =
    let
        ss = newStringStream()
    writePlayerInfoExtra(ss, message)
    result = ss.data

proc newPlayerInfoExtra*(data: string): PlayerInfoExtra =
    let
        ss = newStringStream(data)
    result = readPlayerInfoExtra(ss)

proc newPlayerInfoExtra*(data: seq[byte]): PlayerInfoExtra =
    let
        ss = newStringStream(cast[string](data))
    result = readPlayerInfoExtra(ss)


proc fullyQualifiedName*(T: typedesc[ResponseReplayInfo]): string = "ResponseReplayInfo"

proc readResponseReplayInfoImpl(stream: Stream): Message = readResponseReplayInfo(stream)
proc writeResponseReplayInfoImpl(stream: Stream, msg: Message) = writeResponseReplayInfo(stream, ResponseReplayInfo(msg))

proc ResponseReplayInfoProcs*(): MessageProcs =
    result.readImpl = readResponseReplayInfoImpl
    result.writeImpl = writeResponseReplayInfoImpl

proc newResponseReplayInfo*(): ResponseReplayInfo =
    new(result)
    initMessage(result[])
    result.procs = ResponseReplayInfoProcs()
    result.mapName = ""
    result.localMapPath = ""
    result.playerInfo = @[]
    result.gameDurationLoops = 0
    result.gameDurationSeconds = 0
    result.gameVersion = ""
    result.dataVersion = ""
    result.dataBuild = 0
    result.baseBuild = 0
    result.error = ResponseReplayInfo_Error.MissingReplay
    result.errorDetails = ""

proc clearmapName*(message: ResponseReplayInfo) =
    message.mapName = ""
    clearFields(message, [1])

proc hasmapName*(message: ResponseReplayInfo): bool =
    result = hasField(message, 1)

proc setmapName*(message: ResponseReplayInfo, value: string) =
    message.mapName = value
    setField(message, 1)

proc mapName*(message: ResponseReplayInfo): string {.inline.} =
    message.mapName

proc `mapName=`*(message: ResponseReplayInfo, value: string) {.inline.} =
    setmapName(message, value)

proc clearlocalMapPath*(message: ResponseReplayInfo) =
    message.localMapPath = ""
    clearFields(message, [2])

proc haslocalMapPath*(message: ResponseReplayInfo): bool =
    result = hasField(message, 2)

proc setlocalMapPath*(message: ResponseReplayInfo, value: string) =
    message.localMapPath = value
    setField(message, 2)

proc localMapPath*(message: ResponseReplayInfo): string {.inline.} =
    message.localMapPath

proc `localMapPath=`*(message: ResponseReplayInfo, value: string) {.inline.} =
    setlocalMapPath(message, value)

proc clearplayerInfo*(message: ResponseReplayInfo) =
    message.playerInfo = @[]
    clearFields(message, [3])

proc hasplayerInfo*(message: ResponseReplayInfo): bool =
    result = hasField(message, 3) or (len(message.playerInfo) > 0)

proc setplayerInfo*(message: ResponseReplayInfo, value: seq[PlayerInfoExtra]) =
    message.playerInfo = value
    setField(message, 3)

proc addplayerInfo*(message: ResponseReplayInfo, value: PlayerInfoExtra) =
    add(message.playerInfo, value)

proc playerInfo*(message: ResponseReplayInfo): seq[PlayerInfoExtra] {.inline.} =
    message.playerInfo

proc `playerInfo=`*(message: ResponseReplayInfo, value: seq[PlayerInfoExtra]) {.inline.} =
    setplayerInfo(message, value)

proc cleargameDurationLoops*(message: ResponseReplayInfo) =
    message.gameDurationLoops = 0
    clearFields(message, [4])

proc hasgameDurationLoops*(message: ResponseReplayInfo): bool =
    result = hasField(message, 4)

proc setgameDurationLoops*(message: ResponseReplayInfo, value: uint32) =
    message.gameDurationLoops = value
    setField(message, 4)

proc gameDurationLoops*(message: ResponseReplayInfo): uint32 {.inline.} =
    message.gameDurationLoops

proc `gameDurationLoops=`*(message: ResponseReplayInfo, value: uint32) {.inline.} =
    setgameDurationLoops(message, value)

proc cleargameDurationSeconds*(message: ResponseReplayInfo) =
    message.gameDurationSeconds = 0
    clearFields(message, [5])

proc hasgameDurationSeconds*(message: ResponseReplayInfo): bool =
    result = hasField(message, 5)

proc setgameDurationSeconds*(message: ResponseReplayInfo, value: float32) =
    message.gameDurationSeconds = value
    setField(message, 5)

proc gameDurationSeconds*(message: ResponseReplayInfo): float32 {.inline.} =
    message.gameDurationSeconds

proc `gameDurationSeconds=`*(message: ResponseReplayInfo, value: float32) {.inline.} =
    setgameDurationSeconds(message, value)

proc cleargameVersion*(message: ResponseReplayInfo) =
    message.gameVersion = ""
    clearFields(message, [6])

proc hasgameVersion*(message: ResponseReplayInfo): bool =
    result = hasField(message, 6)

proc setgameVersion*(message: ResponseReplayInfo, value: string) =
    message.gameVersion = value
    setField(message, 6)

proc gameVersion*(message: ResponseReplayInfo): string {.inline.} =
    message.gameVersion

proc `gameVersion=`*(message: ResponseReplayInfo, value: string) {.inline.} =
    setgameVersion(message, value)

proc cleardataVersion*(message: ResponseReplayInfo) =
    message.dataVersion = ""
    clearFields(message, [11])

proc hasdataVersion*(message: ResponseReplayInfo): bool =
    result = hasField(message, 11)

proc setdataVersion*(message: ResponseReplayInfo, value: string) =
    message.dataVersion = value
    setField(message, 11)

proc dataVersion*(message: ResponseReplayInfo): string {.inline.} =
    message.dataVersion

proc `dataVersion=`*(message: ResponseReplayInfo, value: string) {.inline.} =
    setdataVersion(message, value)

proc cleardataBuild*(message: ResponseReplayInfo) =
    message.dataBuild = 0
    clearFields(message, [7])

proc hasdataBuild*(message: ResponseReplayInfo): bool =
    result = hasField(message, 7)

proc setdataBuild*(message: ResponseReplayInfo, value: uint32) =
    message.dataBuild = value
    setField(message, 7)

proc dataBuild*(message: ResponseReplayInfo): uint32 {.inline.} =
    message.dataBuild

proc `dataBuild=`*(message: ResponseReplayInfo, value: uint32) {.inline.} =
    setdataBuild(message, value)

proc clearbaseBuild*(message: ResponseReplayInfo) =
    message.baseBuild = 0
    clearFields(message, [8])

proc hasbaseBuild*(message: ResponseReplayInfo): bool =
    result = hasField(message, 8)

proc setbaseBuild*(message: ResponseReplayInfo, value: uint32) =
    message.baseBuild = value
    setField(message, 8)

proc baseBuild*(message: ResponseReplayInfo): uint32 {.inline.} =
    message.baseBuild

proc `baseBuild=`*(message: ResponseReplayInfo, value: uint32) {.inline.} =
    setbaseBuild(message, value)

proc clearerror*(message: ResponseReplayInfo) =
    message.error = ResponseReplayInfo_Error.MissingReplay
    clearFields(message, [9])

proc haserror*(message: ResponseReplayInfo): bool =
    result = hasField(message, 9)

proc seterror*(message: ResponseReplayInfo, value: ResponseReplayInfo_Error) =
    message.error = value
    setField(message, 9)

proc error*(message: ResponseReplayInfo): ResponseReplayInfo_Error {.inline.} =
    message.error

proc `error=`*(message: ResponseReplayInfo, value: ResponseReplayInfo_Error) {.inline.} =
    seterror(message, value)

proc clearerrorDetails*(message: ResponseReplayInfo) =
    message.errorDetails = ""
    clearFields(message, [10])

proc haserrorDetails*(message: ResponseReplayInfo): bool =
    result = hasField(message, 10)

proc seterrorDetails*(message: ResponseReplayInfo, value: string) =
    message.errorDetails = value
    setField(message, 10)

proc errorDetails*(message: ResponseReplayInfo): string {.inline.} =
    message.errorDetails

proc `errorDetails=`*(message: ResponseReplayInfo, value: string) {.inline.} =
    seterrorDetails(message, value)

proc `$`*(message: ResponseReplayInfo): string =
    runnableExamples:
        echo $ResponseReplayInfo
        echo fmt"{ResponseReplayInfo}"
        echo &"{ResponseReplayInfo}"
    var resultSeq: seq[string]
    if message.hasmapName:
        resultSeq.add(&"mapName: {message.mapName}")
    if message.haslocalMapPath:
        resultSeq.add(&"localMapPath: {message.localMapPath}")
    if message.hasplayerInfo:
        resultSeq.add(&"playerInfo: {message.playerInfo}")
    if message.hasgameDurationLoops:
        resultSeq.add(&"gameDurationLoops: {message.gameDurationLoops}")
    if message.hasgameDurationSeconds:
        resultSeq.add(&"gameDurationSeconds: {message.gameDurationSeconds}")
    if message.hasgameVersion:
        resultSeq.add(&"gameVersion: {message.gameVersion}")
    if message.hasdataVersion:
        resultSeq.add(&"dataVersion: {message.dataVersion}")
    if message.hasdataBuild:
        resultSeq.add(&"dataBuild: {message.dataBuild}")
    if message.hasbaseBuild:
        resultSeq.add(&"baseBuild: {message.baseBuild}")
    if message.haserror:
        resultSeq.add(&"error: {message.error}")
    if message.haserrorDetails:
        resultSeq.add(&"errorDetails: {message.errorDetails}")
    result = resultSeq.join(", ")
    result = &"ResponseReplayInfo({result})"

proc sizeOfResponseReplayInfo*(message: ResponseReplayInfo): uint64 =
    if hasmapName(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfString(message.mapName)
    if haslocalMapPath(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfString(message.localMapPath)
    for value in message.playerInfo:
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPlayerInfoExtra(value))
    if hasgameDurationLoops(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfUInt32(message.gameDurationLoops)
    if hasgameDurationSeconds(message):
        result = result + sizeOfTag(5, WireType.Fixed32)
        result = result + sizeOfFloat(message.gameDurationSeconds)
    if hasgameVersion(message):
        result = result + sizeOfTag(6, WireType.LengthDelimited)
        result = result + sizeOfString(message.gameVersion)
    if hasdataVersion(message):
        result = result + sizeOfTag(11, WireType.LengthDelimited)
        result = result + sizeOfString(message.dataVersion)
    if hasdataBuild(message):
        result = result + sizeOfTag(7, WireType.Varint)
        result = result + sizeOfUInt32(message.dataBuild)
    if hasbaseBuild(message):
        result = result + sizeOfTag(8, WireType.Varint)
        result = result + sizeOfUInt32(message.baseBuild)
    if haserror(message):
        result = result + sizeOfTag(9, WireType.Varint)
        result = result + sizeOfEnum[ResponseReplayInfo_Error](message.error)
    if haserrorDetails(message):
        result = result + sizeOfTag(10, WireType.LengthDelimited)
        result = result + sizeOfString(message.errorDetails)
    result = result + sizeOfUnknownFields(message)

proc writeResponseReplayInfo*(stream: Stream, message: ResponseReplayInfo) =
    if hasmapName(message):
        protoWriteString(stream, message.mapName, 1)
    if haslocalMapPath(message):
        protoWriteString(stream, message.localMapPath, 2)
    for value in message.playerInfo:
        writeMessage(stream, value, 3)
    if hasgameDurationLoops(message):
        protoWriteUInt32(stream, message.gameDurationLoops, 4)
    if hasgameDurationSeconds(message):
        protoWriteFloat(stream, message.gameDurationSeconds, 5)
    if hasgameVersion(message):
        protoWriteString(stream, message.gameVersion, 6)
    if hasdataVersion(message):
        protoWriteString(stream, message.dataVersion, 11)
    if hasdataBuild(message):
        protoWriteUInt32(stream, message.dataBuild, 7)
    if hasbaseBuild(message):
        protoWriteUInt32(stream, message.baseBuild, 8)
    if haserror(message):
        protoWriteEnum(stream, message.error, 9)
    if haserrorDetails(message):
        protoWriteString(stream, message.errorDetails, 10)
    writeUnknownFields(stream, message)

proc readResponseReplayInfo*(stream: Stream): ResponseReplayInfo =
    result = newResponseReplayInfo()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            setmapName(result, protoReadString(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            setlocalMapPath(result, protoReadString(stream))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addplayerInfo(result, newPlayerInfoExtra(data))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setgameDurationLoops(result, protoReadUInt32(stream))
        of 5:
            expectWireType(wireType, WireType.Fixed32)
            setgameDurationSeconds(result, protoReadFloat(stream))
        of 6:
            expectWireType(wireType, WireType.LengthDelimited)
            setgameVersion(result, protoReadString(stream))
        of 11:
            expectWireType(wireType, WireType.LengthDelimited)
            setdataVersion(result, protoReadString(stream))
        of 7:
            expectWireType(wireType, WireType.Varint)
            setdataBuild(result, protoReadUInt32(stream))
        of 8:
            expectWireType(wireType, WireType.Varint)
            setbaseBuild(result, protoReadUInt32(stream))
        of 9:
            expectWireType(wireType, WireType.Varint)
            seterror(result, protoReadEnum[ResponseReplayInfo_Error](stream))
        of 10:
            expectWireType(wireType, WireType.LengthDelimited)
            seterrorDetails(result, protoReadString(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseReplayInfo): string =
    let
        ss = newStringStream()
    writeResponseReplayInfo(ss, message)
    result = ss.data

proc newResponseReplayInfo*(data: string): ResponseReplayInfo =
    let
        ss = newStringStream(data)
    result = readResponseReplayInfo(ss)

proc newResponseReplayInfo*(data: seq[byte]): ResponseReplayInfo =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseReplayInfo(ss)


proc fullyQualifiedName*(T: typedesc[ResponseStartReplay]): string = "ResponseStartReplay"

proc readResponseStartReplayImpl(stream: Stream): Message = readResponseStartReplay(stream)
proc writeResponseStartReplayImpl(stream: Stream, msg: Message) = writeResponseStartReplay(stream, ResponseStartReplay(msg))

proc ResponseStartReplayProcs*(): MessageProcs =
    result.readImpl = readResponseStartReplayImpl
    result.writeImpl = writeResponseStartReplayImpl

proc newResponseStartReplay*(): ResponseStartReplay =
    new(result)
    initMessage(result[])
    result.procs = ResponseStartReplayProcs()
    result.error = ResponseStartReplay_Error.MissingReplay
    result.errorDetails = ""

proc clearerror*(message: ResponseStartReplay) =
    message.error = ResponseStartReplay_Error.MissingReplay
    clearFields(message, [1])

proc haserror*(message: ResponseStartReplay): bool =
    result = hasField(message, 1)

proc seterror*(message: ResponseStartReplay, value: ResponseStartReplay_Error) =
    message.error = value
    setField(message, 1)

proc error*(message: ResponseStartReplay): ResponseStartReplay_Error {.inline.} =
    message.error

proc `error=`*(message: ResponseStartReplay, value: ResponseStartReplay_Error) {.inline.} =
    seterror(message, value)

proc clearerrorDetails*(message: ResponseStartReplay) =
    message.errorDetails = ""
    clearFields(message, [2])

proc haserrorDetails*(message: ResponseStartReplay): bool =
    result = hasField(message, 2)

proc seterrorDetails*(message: ResponseStartReplay, value: string) =
    message.errorDetails = value
    setField(message, 2)

proc errorDetails*(message: ResponseStartReplay): string {.inline.} =
    message.errorDetails

proc `errorDetails=`*(message: ResponseStartReplay, value: string) {.inline.} =
    seterrorDetails(message, value)

proc `$`*(message: ResponseStartReplay): string =
    runnableExamples:
        echo $ResponseStartReplay
        echo fmt"{ResponseStartReplay}"
        echo &"{ResponseStartReplay}"
    var resultSeq: seq[string]
    if message.haserror:
        resultSeq.add(&"error: {message.error}")
    if message.haserrorDetails:
        resultSeq.add(&"errorDetails: {message.errorDetails}")
    result = resultSeq.join(", ")
    result = &"ResponseStartReplay({result})"

proc sizeOfResponseStartReplay*(message: ResponseStartReplay): uint64 =
    if haserror(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfEnum[ResponseStartReplay_Error](message.error)
    if haserrorDetails(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfString(message.errorDetails)
    result = result + sizeOfUnknownFields(message)

proc writeResponseStartReplay*(stream: Stream, message: ResponseStartReplay) =
    if haserror(message):
        protoWriteEnum(stream, message.error, 1)
    if haserrorDetails(message):
        protoWriteString(stream, message.errorDetails, 2)
    writeUnknownFields(stream, message)

proc readResponseStartReplay*(stream: Stream): ResponseStartReplay =
    result = newResponseStartReplay()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            seterror(result, protoReadEnum[ResponseStartReplay_Error](stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            seterrorDetails(result, protoReadString(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseStartReplay): string =
    let
        ss = newStringStream()
    writeResponseStartReplay(ss, message)
    result = ss.data

proc newResponseStartReplay*(data: string): ResponseStartReplay =
    let
        ss = newStringStream(data)
    result = readResponseStartReplay(ss)

proc newResponseStartReplay*(data: seq[byte]): ResponseStartReplay =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseStartReplay(ss)


proc fullyQualifiedName*(T: typedesc[ResponseAction]): string = "ResponseAction"

proc readResponseActionImpl(stream: Stream): Message = readResponseAction(stream)
proc writeResponseActionImpl(stream: Stream, msg: Message) = writeResponseAction(stream, ResponseAction(msg))

proc ResponseActionProcs*(): MessageProcs =
    result.readImpl = readResponseActionImpl
    result.writeImpl = writeResponseActionImpl

proc newResponseAction*(): ResponseAction =
    new(result)
    initMessage(result[])
    result.procs = ResponseActionProcs()
    result.result = @[]

proc clearresult*(message: ResponseAction) =
    message.result = @[]
    clearFields(message, [1])

proc hasresult*(message: ResponseAction): bool =
    result = hasField(message, 1) or (len(message.result) > 0)

proc setresult*(message: ResponseAction, value: seq[ActionResult]) =
    message.result = value
    setField(message, 1)

proc addresult*(message: ResponseAction, value: ActionResult) =
    add(message.result, value)

proc result*(message: ResponseAction): seq[ActionResult] {.inline.} =
    message.result

proc `result=`*(message: ResponseAction, value: seq[ActionResult]) {.inline.} =
    setresult(message, value)

proc `$`*(message: ResponseAction): string =
    runnableExamples:
        echo $ResponseAction
        echo fmt"{ResponseAction}"
        echo &"{ResponseAction}"
    var resultSeq: seq[string]
    if message.hasresult:
        resultSeq.add(&"result: {message.result}")
    result = resultSeq.join(", ")
    result = &"ResponseAction({result})"

proc sizeOfResponseAction*(message: ResponseAction): uint64 =
    if len(message.result) > 0:
        for value in message.result:
            result = result + sizeOfTag(1, WireType.Varint)
            result = result + sizeOfEnum[ActionResult](value)
    result = result + sizeOfUnknownFields(message)

proc writeResponseAction*(stream: Stream, message: ResponseAction) =
    for value in message.result:
        protoWriteEnum(stream, value, 1)
    writeUnknownFields(stream, message)

proc readResponseAction*(stream: Stream): ResponseAction =
    result = newResponseAction()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint, WireType.LengthDelimited)
            if wireType == WireType.LengthDelimited:
                let
                    size = readVarint(stream)
                    start = uint64(getPosition(stream))
                var consumed = 0'u64
                while consumed < size:
                    addresult(result, protoReadEnum[ActionResult](stream))
                    consumed = uint64(getPosition(stream)) - start
                if consumed != size:
                    raise newException(Exception, "packed field size mismatch")
            else:
                addresult(result, protoReadEnum[ActionResult](stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseAction): string =
    let
        ss = newStringStream()
    writeResponseAction(ss, message)
    result = ss.data

proc newResponseAction*(data: string): ResponseAction =
    let
        ss = newStringStream(data)
    result = readResponseAction(ss)

proc newResponseAction*(data: seq[byte]): ResponseAction =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseAction(ss)


proc fullyQualifiedName*(T: typedesc[ResponseRestartGame]): string = "ResponseRestartGame"

proc readResponseRestartGameImpl(stream: Stream): Message = readResponseRestartGame(stream)
proc writeResponseRestartGameImpl(stream: Stream, msg: Message) = writeResponseRestartGame(stream, ResponseRestartGame(msg))

proc ResponseRestartGameProcs*(): MessageProcs =
    result.readImpl = readResponseRestartGameImpl
    result.writeImpl = writeResponseRestartGameImpl

proc newResponseRestartGame*(): ResponseRestartGame =
    new(result)
    initMessage(result[])
    result.procs = ResponseRestartGameProcs()
    result.error = ResponseRestartGame_Error.LaunchError
    result.errorDetails = ""
    result.needHardReset = false

proc clearerror*(message: ResponseRestartGame) =
    message.error = ResponseRestartGame_Error.LaunchError
    clearFields(message, [1])

proc haserror*(message: ResponseRestartGame): bool =
    result = hasField(message, 1)

proc seterror*(message: ResponseRestartGame, value: ResponseRestartGame_Error) =
    message.error = value
    setField(message, 1)

proc error*(message: ResponseRestartGame): ResponseRestartGame_Error {.inline.} =
    message.error

proc `error=`*(message: ResponseRestartGame, value: ResponseRestartGame_Error) {.inline.} =
    seterror(message, value)

proc clearerrorDetails*(message: ResponseRestartGame) =
    message.errorDetails = ""
    clearFields(message, [2])

proc haserrorDetails*(message: ResponseRestartGame): bool =
    result = hasField(message, 2)

proc seterrorDetails*(message: ResponseRestartGame, value: string) =
    message.errorDetails = value
    setField(message, 2)

proc errorDetails*(message: ResponseRestartGame): string {.inline.} =
    message.errorDetails

proc `errorDetails=`*(message: ResponseRestartGame, value: string) {.inline.} =
    seterrorDetails(message, value)

proc clearneedHardReset*(message: ResponseRestartGame) =
    message.needHardReset = false
    clearFields(message, [3])

proc hasneedHardReset*(message: ResponseRestartGame): bool =
    result = hasField(message, 3)

proc setneedHardReset*(message: ResponseRestartGame, value: bool) =
    message.needHardReset = value
    setField(message, 3)

proc needHardReset*(message: ResponseRestartGame): bool {.inline.} =
    message.needHardReset

proc `needHardReset=`*(message: ResponseRestartGame, value: bool) {.inline.} =
    setneedHardReset(message, value)

proc `$`*(message: ResponseRestartGame): string =
    runnableExamples:
        echo $ResponseRestartGame
        echo fmt"{ResponseRestartGame}"
        echo &"{ResponseRestartGame}"
    var resultSeq: seq[string]
    if message.haserror:
        resultSeq.add(&"error: {message.error}")
    if message.haserrorDetails:
        resultSeq.add(&"errorDetails: {message.errorDetails}")
    if message.hasneedHardReset:
        resultSeq.add(&"needHardReset: {message.needHardReset}")
    result = resultSeq.join(", ")
    result = &"ResponseRestartGame({result})"

proc sizeOfResponseRestartGame*(message: ResponseRestartGame): uint64 =
    if haserror(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfEnum[ResponseRestartGame_Error](message.error)
    if haserrorDetails(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfString(message.errorDetails)
    if hasneedHardReset(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfBool(message.needHardReset)
    result = result + sizeOfUnknownFields(message)

proc writeResponseRestartGame*(stream: Stream, message: ResponseRestartGame) =
    if haserror(message):
        protoWriteEnum(stream, message.error, 1)
    if haserrorDetails(message):
        protoWriteString(stream, message.errorDetails, 2)
    if hasneedHardReset(message):
        protoWriteBool(stream, message.needHardReset, 3)
    writeUnknownFields(stream, message)

proc readResponseRestartGame*(stream: Stream): ResponseRestartGame =
    result = newResponseRestartGame()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            seterror(result, protoReadEnum[ResponseRestartGame_Error](stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            seterrorDetails(result, protoReadString(stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setneedHardReset(result, protoReadBool(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseRestartGame): string =
    let
        ss = newStringStream()
    writeResponseRestartGame(ss, message)
    result = ss.data

proc newResponseRestartGame*(data: string): ResponseRestartGame =
    let
        ss = newStringStream(data)
    result = readResponseRestartGame(ss)

proc newResponseRestartGame*(data: seq[byte]): ResponseRestartGame =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseRestartGame(ss)


proc fullyQualifiedName*(T: typedesc[ResponseJoinGame]): string = "ResponseJoinGame"

proc readResponseJoinGameImpl(stream: Stream): Message = readResponseJoinGame(stream)
proc writeResponseJoinGameImpl(stream: Stream, msg: Message) = writeResponseJoinGame(stream, ResponseJoinGame(msg))

proc ResponseJoinGameProcs*(): MessageProcs =
    result.readImpl = readResponseJoinGameImpl
    result.writeImpl = writeResponseJoinGameImpl

proc newResponseJoinGame*(): ResponseJoinGame =
    new(result)
    initMessage(result[])
    result.procs = ResponseJoinGameProcs()
    result.playerId = 0
    result.error = ResponseJoinGame_Error.MissingParticipation
    result.errorDetails = ""

proc clearplayerId*(message: ResponseJoinGame) =
    message.playerId = 0
    clearFields(message, [1])

proc hasplayerId*(message: ResponseJoinGame): bool =
    result = hasField(message, 1)

proc setplayerId*(message: ResponseJoinGame, value: uint32) =
    message.playerId = value
    setField(message, 1)

proc playerId*(message: ResponseJoinGame): uint32 {.inline.} =
    message.playerId

proc `playerId=`*(message: ResponseJoinGame, value: uint32) {.inline.} =
    setplayerId(message, value)

proc clearerror*(message: ResponseJoinGame) =
    message.error = ResponseJoinGame_Error.MissingParticipation
    clearFields(message, [2])

proc haserror*(message: ResponseJoinGame): bool =
    result = hasField(message, 2)

proc seterror*(message: ResponseJoinGame, value: ResponseJoinGame_Error) =
    message.error = value
    setField(message, 2)

proc error*(message: ResponseJoinGame): ResponseJoinGame_Error {.inline.} =
    message.error

proc `error=`*(message: ResponseJoinGame, value: ResponseJoinGame_Error) {.inline.} =
    seterror(message, value)

proc clearerrorDetails*(message: ResponseJoinGame) =
    message.errorDetails = ""
    clearFields(message, [3])

proc haserrorDetails*(message: ResponseJoinGame): bool =
    result = hasField(message, 3)

proc seterrorDetails*(message: ResponseJoinGame, value: string) =
    message.errorDetails = value
    setField(message, 3)

proc errorDetails*(message: ResponseJoinGame): string {.inline.} =
    message.errorDetails

proc `errorDetails=`*(message: ResponseJoinGame, value: string) {.inline.} =
    seterrorDetails(message, value)

proc `$`*(message: ResponseJoinGame): string =
    runnableExamples:
        echo $ResponseJoinGame
        echo fmt"{ResponseJoinGame}"
        echo &"{ResponseJoinGame}"
    var resultSeq: seq[string]
    if message.hasplayerId:
        resultSeq.add(&"playerId: {message.playerId}")
    if message.haserror:
        resultSeq.add(&"error: {message.error}")
    if message.haserrorDetails:
        resultSeq.add(&"errorDetails: {message.errorDetails}")
    result = resultSeq.join(", ")
    result = &"ResponseJoinGame({result})"

proc sizeOfResponseJoinGame*(message: ResponseJoinGame): uint64 =
    if hasplayerId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.playerId)
    if haserror(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfEnum[ResponseJoinGame_Error](message.error)
    if haserrorDetails(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfString(message.errorDetails)
    result = result + sizeOfUnknownFields(message)

proc writeResponseJoinGame*(stream: Stream, message: ResponseJoinGame) =
    if hasplayerId(message):
        protoWriteUInt32(stream, message.playerId, 1)
    if haserror(message):
        protoWriteEnum(stream, message.error, 2)
    if haserrorDetails(message):
        protoWriteString(stream, message.errorDetails, 3)
    writeUnknownFields(stream, message)

proc readResponseJoinGame*(stream: Stream): ResponseJoinGame =
    result = newResponseJoinGame()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setplayerId(result, protoReadUInt32(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            seterror(result, protoReadEnum[ResponseJoinGame_Error](stream))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            seterrorDetails(result, protoReadString(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseJoinGame): string =
    let
        ss = newStringStream()
    writeResponseJoinGame(ss, message)
    result = ss.data

proc newResponseJoinGame*(data: string): ResponseJoinGame =
    let
        ss = newStringStream(data)
    result = readResponseJoinGame(ss)

proc newResponseJoinGame*(data: seq[byte]): ResponseJoinGame =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseJoinGame(ss)


proc fullyQualifiedName*(T: typedesc[ResponseQuit]): string = "ResponseQuit"

proc readResponseQuitImpl(stream: Stream): Message = readResponseQuit(stream)
proc writeResponseQuitImpl(stream: Stream, msg: Message) = writeResponseQuit(stream, ResponseQuit(msg))

proc ResponseQuitProcs*(): MessageProcs =
    result.readImpl = readResponseQuitImpl
    result.writeImpl = writeResponseQuitImpl

proc newResponseQuit*(): ResponseQuit =
    new(result)
    initMessage(result[])
    result.procs = ResponseQuitProcs()

proc `$`*(message: ResponseQuit): string =
    runnableExamples:
        echo $ResponseQuit
        echo fmt"{ResponseQuit}"
        echo &"{ResponseQuit}"
    var resultSeq: seq[string]
    result = resultSeq.join(", ")
    result = &"ResponseQuit({result})"

proc sizeOfResponseQuit*(message: ResponseQuit): uint64 =
    result = result + sizeOfUnknownFields(message)

proc writeResponseQuit*(stream: Stream, message: ResponseQuit) =
    writeUnknownFields(stream, message)

proc readResponseQuit*(stream: Stream): ResponseQuit =
    result = newResponseQuit()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseQuit): string =
    let
        ss = newStringStream()
    writeResponseQuit(ss, message)
    result = ss.data

proc newResponseQuit*(data: string): ResponseQuit =
    let
        ss = newStringStream(data)
    result = readResponseQuit(ss)

proc newResponseQuit*(data: seq[byte]): ResponseQuit =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseQuit(ss)


proc fullyQualifiedName*(T: typedesc[ResponseStep]): string = "ResponseStep"

proc readResponseStepImpl(stream: Stream): Message = readResponseStep(stream)
proc writeResponseStepImpl(stream: Stream, msg: Message) = writeResponseStep(stream, ResponseStep(msg))

proc ResponseStepProcs*(): MessageProcs =
    result.readImpl = readResponseStepImpl
    result.writeImpl = writeResponseStepImpl

proc newResponseStep*(): ResponseStep =
    new(result)
    initMessage(result[])
    result.procs = ResponseStepProcs()
    result.simulationLoop = 0

proc clearsimulationLoop*(message: ResponseStep) =
    message.simulationLoop = 0
    clearFields(message, [1])

proc hassimulationLoop*(message: ResponseStep): bool =
    result = hasField(message, 1)

proc setsimulationLoop*(message: ResponseStep, value: uint32) =
    message.simulationLoop = value
    setField(message, 1)

proc simulationLoop*(message: ResponseStep): uint32 {.inline.} =
    message.simulationLoop

proc `simulationLoop=`*(message: ResponseStep, value: uint32) {.inline.} =
    setsimulationLoop(message, value)

proc `$`*(message: ResponseStep): string =
    runnableExamples:
        echo $ResponseStep
        echo fmt"{ResponseStep}"
        echo &"{ResponseStep}"
    var resultSeq: seq[string]
    if message.hassimulationLoop:
        resultSeq.add(&"simulationLoop: {message.simulationLoop}")
    result = resultSeq.join(", ")
    result = &"ResponseStep({result})"

proc sizeOfResponseStep*(message: ResponseStep): uint64 =
    if hassimulationLoop(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.simulationLoop)
    result = result + sizeOfUnknownFields(message)

proc writeResponseStep*(stream: Stream, message: ResponseStep) =
    if hassimulationLoop(message):
        protoWriteUInt32(stream, message.simulationLoop, 1)
    writeUnknownFields(stream, message)

proc readResponseStep*(stream: Stream): ResponseStep =
    result = newResponseStep()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setsimulationLoop(result, protoReadUInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseStep): string =
    let
        ss = newStringStream()
    writeResponseStep(ss, message)
    result = ss.data

proc newResponseStep*(data: string): ResponseStep =
    let
        ss = newStringStream(data)
    result = readResponseStep(ss)

proc newResponseStep*(data: seq[byte]): ResponseStep =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseStep(ss)


proc fullyQualifiedName*(T: typedesc[ResponseQuickLoad]): string = "ResponseQuickLoad"

proc readResponseQuickLoadImpl(stream: Stream): Message = readResponseQuickLoad(stream)
proc writeResponseQuickLoadImpl(stream: Stream, msg: Message) = writeResponseQuickLoad(stream, ResponseQuickLoad(msg))

proc ResponseQuickLoadProcs*(): MessageProcs =
    result.readImpl = readResponseQuickLoadImpl
    result.writeImpl = writeResponseQuickLoadImpl

proc newResponseQuickLoad*(): ResponseQuickLoad =
    new(result)
    initMessage(result[])
    result.procs = ResponseQuickLoadProcs()

proc `$`*(message: ResponseQuickLoad): string =
    runnableExamples:
        echo $ResponseQuickLoad
        echo fmt"{ResponseQuickLoad}"
        echo &"{ResponseQuickLoad}"
    var resultSeq: seq[string]
    result = resultSeq.join(", ")
    result = &"ResponseQuickLoad({result})"

proc sizeOfResponseQuickLoad*(message: ResponseQuickLoad): uint64 =
    result = result + sizeOfUnknownFields(message)

proc writeResponseQuickLoad*(stream: Stream, message: ResponseQuickLoad) =
    writeUnknownFields(stream, message)

proc readResponseQuickLoad*(stream: Stream): ResponseQuickLoad =
    result = newResponseQuickLoad()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseQuickLoad): string =
    let
        ss = newStringStream()
    writeResponseQuickLoad(ss, message)
    result = ss.data

proc newResponseQuickLoad*(data: string): ResponseQuickLoad =
    let
        ss = newStringStream(data)
    result = readResponseQuickLoad(ss)

proc newResponseQuickLoad*(data: seq[byte]): ResponseQuickLoad =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseQuickLoad(ss)


proc fullyQualifiedName*(T: typedesc[ResponseSaveReplay]): string = "ResponseSaveReplay"

proc readResponseSaveReplayImpl(stream: Stream): Message = readResponseSaveReplay(stream)
proc writeResponseSaveReplayImpl(stream: Stream, msg: Message) = writeResponseSaveReplay(stream, ResponseSaveReplay(msg))

proc ResponseSaveReplayProcs*(): MessageProcs =
    result.readImpl = readResponseSaveReplayImpl
    result.writeImpl = writeResponseSaveReplayImpl

proc newResponseSaveReplay*(): ResponseSaveReplay =
    new(result)
    initMessage(result[])
    result.procs = ResponseSaveReplayProcs()
    result.data = @[]

proc cleardata*(message: ResponseSaveReplay) =
    message.data = @[]
    clearFields(message, [1])

proc hasdata*(message: ResponseSaveReplay): bool =
    result = hasField(message, 1)

proc setdata*(message: ResponseSaveReplay, value: seq[byte]) =
    message.data = value
    setField(message, 1)

proc data*(message: ResponseSaveReplay): seq[byte] {.inline.} =
    message.data

proc `data=`*(message: ResponseSaveReplay, value: seq[byte]) {.inline.} =
    setdata(message, value)

proc `$`*(message: ResponseSaveReplay): string =
    runnableExamples:
        echo $ResponseSaveReplay
        echo fmt"{ResponseSaveReplay}"
        echo &"{ResponseSaveReplay}"
    var resultSeq: seq[string]
    if message.hasdata:
        resultSeq.add(&"data: {message.data}")
    result = resultSeq.join(", ")
    result = &"ResponseSaveReplay({result})"

proc sizeOfResponseSaveReplay*(message: ResponseSaveReplay): uint64 =
    if hasdata(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfBytes(message.data)
    result = result + sizeOfUnknownFields(message)

proc writeResponseSaveReplay*(stream: Stream, message: ResponseSaveReplay) =
    if hasdata(message):
        protoWriteBytes(stream, message.data, 1)
    writeUnknownFields(stream, message)

proc readResponseSaveReplay*(stream: Stream): ResponseSaveReplay =
    result = newResponseSaveReplay()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            setdata(result, protoReadBytes(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseSaveReplay): string =
    let
        ss = newStringStream()
    writeResponseSaveReplay(ss, message)
    result = ss.data

proc newResponseSaveReplay*(data: string): ResponseSaveReplay =
    let
        ss = newStringStream(data)
    result = readResponseSaveReplay(ss)

proc newResponseSaveReplay*(data: seq[byte]): ResponseSaveReplay =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseSaveReplay(ss)


proc fullyQualifiedName*(T: typedesc[ResponseQuickSave]): string = "ResponseQuickSave"

proc readResponseQuickSaveImpl(stream: Stream): Message = readResponseQuickSave(stream)
proc writeResponseQuickSaveImpl(stream: Stream, msg: Message) = writeResponseQuickSave(stream, ResponseQuickSave(msg))

proc ResponseQuickSaveProcs*(): MessageProcs =
    result.readImpl = readResponseQuickSaveImpl
    result.writeImpl = writeResponseQuickSaveImpl

proc newResponseQuickSave*(): ResponseQuickSave =
    new(result)
    initMessage(result[])
    result.procs = ResponseQuickSaveProcs()

proc `$`*(message: ResponseQuickSave): string =
    runnableExamples:
        echo $ResponseQuickSave
        echo fmt"{ResponseQuickSave}"
        echo &"{ResponseQuickSave}"
    var resultSeq: seq[string]
    result = resultSeq.join(", ")
    result = &"ResponseQuickSave({result})"

proc sizeOfResponseQuickSave*(message: ResponseQuickSave): uint64 =
    result = result + sizeOfUnknownFields(message)

proc writeResponseQuickSave*(stream: Stream, message: ResponseQuickSave) =
    writeUnknownFields(stream, message)

proc readResponseQuickSave*(stream: Stream): ResponseQuickSave =
    result = newResponseQuickSave()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseQuickSave): string =
    let
        ss = newStringStream()
    writeResponseQuickSave(ss, message)
    result = ss.data

proc newResponseQuickSave*(data: string): ResponseQuickSave =
    let
        ss = newStringStream(data)
    result = readResponseQuickSave(ss)

proc newResponseQuickSave*(data: seq[byte]): ResponseQuickSave =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseQuickSave(ss)


proc fullyQualifiedName*(T: typedesc[ResponseAvailableMaps]): string = "ResponseAvailableMaps"

proc readResponseAvailableMapsImpl(stream: Stream): Message = readResponseAvailableMaps(stream)
proc writeResponseAvailableMapsImpl(stream: Stream, msg: Message) = writeResponseAvailableMaps(stream, ResponseAvailableMaps(msg))

proc ResponseAvailableMapsProcs*(): MessageProcs =
    result.readImpl = readResponseAvailableMapsImpl
    result.writeImpl = writeResponseAvailableMapsImpl

proc newResponseAvailableMaps*(): ResponseAvailableMaps =
    new(result)
    initMessage(result[])
    result.procs = ResponseAvailableMapsProcs()
    result.localMapPaths = @[]
    result.battlenetMapNames = @[]

proc clearlocalMapPaths*(message: ResponseAvailableMaps) =
    message.localMapPaths = @[]
    clearFields(message, [1])

proc haslocalMapPaths*(message: ResponseAvailableMaps): bool =
    result = hasField(message, 1) or (len(message.localMapPaths) > 0)

proc setlocalMapPaths*(message: ResponseAvailableMaps, value: seq[string]) =
    message.localMapPaths = value
    setField(message, 1)

proc addlocalMapPaths*(message: ResponseAvailableMaps, value: string) =
    add(message.localMapPaths, value)

proc localMapPaths*(message: ResponseAvailableMaps): seq[string] {.inline.} =
    message.localMapPaths

proc `localMapPaths=`*(message: ResponseAvailableMaps, value: seq[string]) {.inline.} =
    setlocalMapPaths(message, value)

proc clearbattlenetMapNames*(message: ResponseAvailableMaps) =
    message.battlenetMapNames = @[]
    clearFields(message, [2])

proc hasbattlenetMapNames*(message: ResponseAvailableMaps): bool =
    result = hasField(message, 2) or (len(message.battlenetMapNames) > 0)

proc setbattlenetMapNames*(message: ResponseAvailableMaps, value: seq[string]) =
    message.battlenetMapNames = value
    setField(message, 2)

proc addbattlenetMapNames*(message: ResponseAvailableMaps, value: string) =
    add(message.battlenetMapNames, value)

proc battlenetMapNames*(message: ResponseAvailableMaps): seq[string] {.inline.} =
    message.battlenetMapNames

proc `battlenetMapNames=`*(message: ResponseAvailableMaps, value: seq[string]) {.inline.} =
    setbattlenetMapNames(message, value)

proc `$`*(message: ResponseAvailableMaps): string =
    runnableExamples:
        echo $ResponseAvailableMaps
        echo fmt"{ResponseAvailableMaps}"
        echo &"{ResponseAvailableMaps}"
    var resultSeq: seq[string]
    if message.haslocalMapPaths:
        resultSeq.add(&"localMapPaths: {message.localMapPaths}")
    if message.hasbattlenetMapNames:
        resultSeq.add(&"battlenetMapNames: {message.battlenetMapNames}")
    result = resultSeq.join(", ")
    result = &"ResponseAvailableMaps({result})"

proc sizeOfResponseAvailableMaps*(message: ResponseAvailableMaps): uint64 =
    for value in message.localMapPaths:
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfString(value)
    for value in message.battlenetMapNames:
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfString(value)
    result = result + sizeOfUnknownFields(message)

proc writeResponseAvailableMaps*(stream: Stream, message: ResponseAvailableMaps) =
    for value in message.localMapPaths:
        protoWriteString(stream, value, 1)
    for value in message.battlenetMapNames:
        protoWriteString(stream, value, 2)
    writeUnknownFields(stream, message)

proc readResponseAvailableMaps*(stream: Stream): ResponseAvailableMaps =
    result = newResponseAvailableMaps()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            addlocalMapPaths(result, protoReadString(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            addbattlenetMapNames(result, protoReadString(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseAvailableMaps): string =
    let
        ss = newStringStream()
    writeResponseAvailableMaps(ss, message)
    result = ss.data

proc newResponseAvailableMaps*(data: string): ResponseAvailableMaps =
    let
        ss = newStringStream(data)
    result = readResponseAvailableMaps(ss)

proc newResponseAvailableMaps*(data: seq[byte]): ResponseAvailableMaps =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseAvailableMaps(ss)


proc fullyQualifiedName*(T: typedesc[ResponseGameInfo]): string = "ResponseGameInfo"

proc readResponseGameInfoImpl(stream: Stream): Message = readResponseGameInfo(stream)
proc writeResponseGameInfoImpl(stream: Stream, msg: Message) = writeResponseGameInfo(stream, ResponseGameInfo(msg))

proc ResponseGameInfoProcs*(): MessageProcs =
    result.readImpl = readResponseGameInfoImpl
    result.writeImpl = writeResponseGameInfoImpl

proc newResponseGameInfo*(): ResponseGameInfo =
    new(result)
    initMessage(result[])
    result.procs = ResponseGameInfoProcs()
    result.mapName = ""
    result.modNames = @[]
    result.localMapPath = ""
    result.playerInfo = @[]
    result.startRaw = nil
    result.options = nil

proc clearmapName*(message: ResponseGameInfo) =
    message.mapName = ""
    clearFields(message, [1])

proc hasmapName*(message: ResponseGameInfo): bool =
    result = hasField(message, 1)

proc setmapName*(message: ResponseGameInfo, value: string) =
    message.mapName = value
    setField(message, 1)

proc mapName*(message: ResponseGameInfo): string {.inline.} =
    message.mapName

proc `mapName=`*(message: ResponseGameInfo, value: string) {.inline.} =
    setmapName(message, value)

proc clearmodNames*(message: ResponseGameInfo) =
    message.modNames = @[]
    clearFields(message, [6])

proc hasmodNames*(message: ResponseGameInfo): bool =
    result = hasField(message, 6) or (len(message.modNames) > 0)

proc setmodNames*(message: ResponseGameInfo, value: seq[string]) =
    message.modNames = value
    setField(message, 6)

proc addmodNames*(message: ResponseGameInfo, value: string) =
    add(message.modNames, value)

proc modNames*(message: ResponseGameInfo): seq[string] {.inline.} =
    message.modNames

proc `modNames=`*(message: ResponseGameInfo, value: seq[string]) {.inline.} =
    setmodNames(message, value)

proc clearlocalMapPath*(message: ResponseGameInfo) =
    message.localMapPath = ""
    clearFields(message, [2])

proc haslocalMapPath*(message: ResponseGameInfo): bool =
    result = hasField(message, 2)

proc setlocalMapPath*(message: ResponseGameInfo, value: string) =
    message.localMapPath = value
    setField(message, 2)

proc localMapPath*(message: ResponseGameInfo): string {.inline.} =
    message.localMapPath

proc `localMapPath=`*(message: ResponseGameInfo, value: string) {.inline.} =
    setlocalMapPath(message, value)

proc clearplayerInfo*(message: ResponseGameInfo) =
    message.playerInfo = @[]
    clearFields(message, [3])

proc hasplayerInfo*(message: ResponseGameInfo): bool =
    result = hasField(message, 3) or (len(message.playerInfo) > 0)

proc setplayerInfo*(message: ResponseGameInfo, value: seq[PlayerInfo]) =
    message.playerInfo = value
    setField(message, 3)

proc addplayerInfo*(message: ResponseGameInfo, value: PlayerInfo) =
    add(message.playerInfo, value)

proc playerInfo*(message: ResponseGameInfo): seq[PlayerInfo] {.inline.} =
    message.playerInfo

proc `playerInfo=`*(message: ResponseGameInfo, value: seq[PlayerInfo]) {.inline.} =
    setplayerInfo(message, value)

proc clearstartRaw*(message: ResponseGameInfo) =
    message.startRaw = nil
    clearFields(message, [4])

proc hasstartRaw*(message: ResponseGameInfo): bool =
    result = hasField(message, 4)

proc setstartRaw*(message: ResponseGameInfo, value: StartRaw) =
    message.startRaw = value
    setField(message, 4)

proc startRaw*(message: ResponseGameInfo): StartRaw {.inline.} =
    message.startRaw

proc `startRaw=`*(message: ResponseGameInfo, value: StartRaw) {.inline.} =
    setstartRaw(message, value)

proc clearoptions*(message: ResponseGameInfo) =
    message.options = nil
    clearFields(message, [5])

proc hasoptions*(message: ResponseGameInfo): bool =
    result = hasField(message, 5)

proc setoptions*(message: ResponseGameInfo, value: InterfaceOptions) =
    message.options = value
    setField(message, 5)

proc options*(message: ResponseGameInfo): InterfaceOptions {.inline.} =
    message.options

proc `options=`*(message: ResponseGameInfo, value: InterfaceOptions) {.inline.} =
    setoptions(message, value)

proc `$`*(message: ResponseGameInfo): string =
    runnableExamples:
        echo $ResponseGameInfo
        echo fmt"{ResponseGameInfo}"
        echo &"{ResponseGameInfo}"
    var resultSeq: seq[string]
    if message.hasmapName:
        resultSeq.add(&"mapName: {message.mapName}")
    if message.hasmodNames:
        resultSeq.add(&"modNames: {message.modNames}")
    if message.haslocalMapPath:
        resultSeq.add(&"localMapPath: {message.localMapPath}")
    if message.hasplayerInfo:
        resultSeq.add(&"playerInfo: {message.playerInfo}")
    if message.hasstartRaw:
        resultSeq.add(&"startRaw: {message.startRaw}")
    if message.hasoptions:
        resultSeq.add(&"options: {message.options}")
    result = resultSeq.join(", ")
    result = &"ResponseGameInfo({result})"

proc sizeOfResponseGameInfo*(message: ResponseGameInfo): uint64 =
    if hasmapName(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfString(message.mapName)
    for value in message.modNames:
        result = result + sizeOfTag(6, WireType.LengthDelimited)
        result = result + sizeOfString(value)
    if haslocalMapPath(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfString(message.localMapPath)
    for value in message.playerInfo:
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPlayerInfo(value))
    if hasstartRaw(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfStartRaw(message.startRaw))
    if hasoptions(message):
        result = result + sizeOfTag(5, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfInterfaceOptions(message.options))
    result = result + sizeOfUnknownFields(message)

proc writeResponseGameInfo*(stream: Stream, message: ResponseGameInfo) =
    if hasmapName(message):
        protoWriteString(stream, message.mapName, 1)
    for value in message.modNames:
        protoWriteString(stream, value, 6)
    if haslocalMapPath(message):
        protoWriteString(stream, message.localMapPath, 2)
    for value in message.playerInfo:
        writeMessage(stream, value, 3)
    if hasstartRaw(message):
        writeMessage(stream, message.startRaw, 4)
    if hasoptions(message):
        writeMessage(stream, message.options, 5)
    writeUnknownFields(stream, message)

proc readResponseGameInfo*(stream: Stream): ResponseGameInfo =
    result = newResponseGameInfo()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            setmapName(result, protoReadString(stream))
        of 6:
            expectWireType(wireType, WireType.LengthDelimited)
            addmodNames(result, protoReadString(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            setlocalMapPath(result, protoReadString(stream))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addplayerInfo(result, newPlayerInfo(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setstartRaw(result, newStartRaw(data))
        of 5:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setoptions(result, newInterfaceOptions(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseGameInfo): string =
    let
        ss = newStringStream()
    writeResponseGameInfo(ss, message)
    result = ss.data

proc newResponseGameInfo*(data: string): ResponseGameInfo =
    let
        ss = newStringStream(data)
    result = readResponseGameInfo(ss)

proc newResponseGameInfo*(data: seq[byte]): ResponseGameInfo =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseGameInfo(ss)


proc fullyQualifiedName*(T: typedesc[ResponseObserverAction]): string = "ResponseObserverAction"

proc readResponseObserverActionImpl(stream: Stream): Message = readResponseObserverAction(stream)
proc writeResponseObserverActionImpl(stream: Stream, msg: Message) = writeResponseObserverAction(stream, ResponseObserverAction(msg))

proc ResponseObserverActionProcs*(): MessageProcs =
    result.readImpl = readResponseObserverActionImpl
    result.writeImpl = writeResponseObserverActionImpl

proc newResponseObserverAction*(): ResponseObserverAction =
    new(result)
    initMessage(result[])
    result.procs = ResponseObserverActionProcs()

proc `$`*(message: ResponseObserverAction): string =
    runnableExamples:
        echo $ResponseObserverAction
        echo fmt"{ResponseObserverAction}"
        echo &"{ResponseObserverAction}"
    var resultSeq: seq[string]
    result = resultSeq.join(", ")
    result = &"ResponseObserverAction({result})"

proc sizeOfResponseObserverAction*(message: ResponseObserverAction): uint64 =
    result = result + sizeOfUnknownFields(message)

proc writeResponseObserverAction*(stream: Stream, message: ResponseObserverAction) =
    writeUnknownFields(stream, message)

proc readResponseObserverAction*(stream: Stream): ResponseObserverAction =
    result = newResponseObserverAction()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ResponseObserverAction): string =
    let
        ss = newStringStream()
    writeResponseObserverAction(ss, message)
    result = ss.data

proc newResponseObserverAction*(data: string): ResponseObserverAction =
    let
        ss = newStringStream(data)
    result = readResponseObserverAction(ss)

proc newResponseObserverAction*(data: seq[byte]): ResponseObserverAction =
    let
        ss = newStringStream(cast[string](data))
    result = readResponseObserverAction(ss)


proc fullyQualifiedName*(T: typedesc[Response]): string = "Response"

proc readResponseImpl(stream: Stream): Message = readResponse(stream)
proc writeResponseImpl(stream: Stream, msg: Message) = writeResponse(stream, Response(msg))

proc ResponseProcs*(): MessageProcs =
    result.readImpl = readResponseImpl
    result.writeImpl = writeResponseImpl

proc newResponse*(): Response =
    new(result)
    initMessage(result[])
    result.procs = ResponseProcs()
    result.id = 0
    result.error = @[]
    result.status = Status.launched
    result.response = Response_response_OneOf(kind: Response_response_Kind.NotSet)

proc clearcreateGame*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc hascreateGame*(message: Response): bool =
    result = hasField(message, 1)

proc setcreateGame*(message: Response, value: ResponseCreateGame) =
    if message.response.kind != Response_response_Kind.CreateGame:
        message.response = Response_response_OneOf(kind: Response_response_Kind.CreateGame, createGame: value)
    else:
        message.response.createGame = value
    setField(message, 1)
    clearFields(message, [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc createGame*(message: Response): ResponseCreateGame {.inline.} =
    message.response.createGame

proc `createGame=`*(message: Response, value: ResponseCreateGame) {.inline.} =
    setcreateGame(message, value)

proc clearjoinGame*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [2, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc hasjoinGame*(message: Response): bool =
    result = hasField(message, 2)

proc setjoinGame*(message: Response, value: ResponseJoinGame) =
    if message.response.kind != Response_response_Kind.JoinGame:
        message.response = Response_response_OneOf(kind: Response_response_Kind.JoinGame, joinGame: value)
    else:
        message.response.joinGame = value
    setField(message, 2)
    clearFields(message, [1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc joinGame*(message: Response): ResponseJoinGame {.inline.} =
    message.response.joinGame

proc `joinGame=`*(message: Response, value: ResponseJoinGame) {.inline.} =
    setjoinGame(message, value)

proc clearrestartGame*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [3, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc hasrestartGame*(message: Response): bool =
    result = hasField(message, 3)

proc setrestartGame*(message: Response, value: ResponseRestartGame) =
    if message.response.kind != Response_response_Kind.RestartGame:
        message.response = Response_response_OneOf(kind: Response_response_Kind.RestartGame, restartGame: value)
    else:
        message.response.restartGame = value
    setField(message, 3)
    clearFields(message, [1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc restartGame*(message: Response): ResponseRestartGame {.inline.} =
    message.response.restartGame

proc `restartGame=`*(message: Response, value: ResponseRestartGame) {.inline.} =
    setrestartGame(message, value)

proc clearstartReplay*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [4, 1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc hasstartReplay*(message: Response): bool =
    result = hasField(message, 4)

proc setstartReplay*(message: Response, value: ResponseStartReplay) =
    if message.response.kind != Response_response_Kind.StartReplay:
        message.response = Response_response_OneOf(kind: Response_response_Kind.StartReplay, startReplay: value)
    else:
        message.response.startReplay = value
    setField(message, 4)
    clearFields(message, [1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc startReplay*(message: Response): ResponseStartReplay {.inline.} =
    message.response.startReplay

proc `startReplay=`*(message: Response, value: ResponseStartReplay) {.inline.} =
    setstartReplay(message, value)

proc clearleaveGame*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [5, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc hasleaveGame*(message: Response): bool =
    result = hasField(message, 5)

proc setleaveGame*(message: Response, value: ResponseLeaveGame) =
    if message.response.kind != Response_response_Kind.LeaveGame:
        message.response = Response_response_OneOf(kind: Response_response_Kind.LeaveGame, leaveGame: value)
    else:
        message.response.leaveGame = value
    setField(message, 5)
    clearFields(message, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc leaveGame*(message: Response): ResponseLeaveGame {.inline.} =
    message.response.leaveGame

proc `leaveGame=`*(message: Response, value: ResponseLeaveGame) {.inline.} =
    setleaveGame(message, value)

proc clearquickSave*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [6, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc hasquickSave*(message: Response): bool =
    result = hasField(message, 6)

proc setquickSave*(message: Response, value: ResponseQuickSave) =
    if message.response.kind != Response_response_Kind.QuickSave:
        message.response = Response_response_OneOf(kind: Response_response_Kind.QuickSave, quickSave: value)
    else:
        message.response.quickSave = value
    setField(message, 6)
    clearFields(message, [1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc quickSave*(message: Response): ResponseQuickSave {.inline.} =
    message.response.quickSave

proc `quickSave=`*(message: Response, value: ResponseQuickSave) {.inline.} =
    setquickSave(message, value)

proc clearquickLoad*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [7, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc hasquickLoad*(message: Response): bool =
    result = hasField(message, 7)

proc setquickLoad*(message: Response, value: ResponseQuickLoad) =
    if message.response.kind != Response_response_Kind.QuickLoad:
        message.response = Response_response_OneOf(kind: Response_response_Kind.QuickLoad, quickLoad: value)
    else:
        message.response.quickLoad = value
    setField(message, 7)
    clearFields(message, [1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc quickLoad*(message: Response): ResponseQuickLoad {.inline.} =
    message.response.quickLoad

proc `quickLoad=`*(message: Response, value: ResponseQuickLoad) {.inline.} =
    setquickLoad(message, value)

proc clearquit*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [8, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc hasquit*(message: Response): bool =
    result = hasField(message, 8)

proc setquit*(message: Response, value: ResponseQuit) =
    if message.response.kind != Response_response_Kind.Quit:
        message.response = Response_response_OneOf(kind: Response_response_Kind.Quit, quit: value)
    else:
        message.response.quit = value
    setField(message, 8)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc quit*(message: Response): ResponseQuit {.inline.} =
    message.response.quit

proc `quit=`*(message: Response, value: ResponseQuit) {.inline.} =
    setquit(message, value)

proc cleargameInfo*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [9, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc hasgameInfo*(message: Response): bool =
    result = hasField(message, 9)

proc setgameInfo*(message: Response, value: ResponseGameInfo) =
    if message.response.kind != Response_response_Kind.GameInfo:
        message.response = Response_response_OneOf(kind: Response_response_Kind.GameInfo, gameInfo: value)
    else:
        message.response.gameInfo = value
    setField(message, 9)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc gameInfo*(message: Response): ResponseGameInfo {.inline.} =
    message.response.gameInfo

proc `gameInfo=`*(message: Response, value: ResponseGameInfo) {.inline.} =
    setgameInfo(message, value)

proc clearobservation*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc hasobservation*(message: Response): bool =
    result = hasField(message, 10)

proc setobservation*(message: Response, value: ResponseObservation) =
    if message.response.kind != Response_response_Kind.Observation:
        message.response = Response_response_OneOf(kind: Response_response_Kind.Observation, observation: value)
    else:
        message.response.observation = value
    setField(message, 10)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc observation*(message: Response): ResponseObservation {.inline.} =
    message.response.observation

proc `observation=`*(message: Response, value: ResponseObservation) {.inline.} =
    setobservation(message, value)

proc clearaction*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc hasaction*(message: Response): bool =
    result = hasField(message, 11)

proc setaction*(message: Response, value: ResponseAction) =
    if message.response.kind != Response_response_Kind.Action:
        message.response = Response_response_OneOf(kind: Response_response_Kind.Action, action: value)
    else:
        message.response.action = value
    setField(message, 11)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc action*(message: Response): ResponseAction {.inline.} =
    message.response.action

proc `action=`*(message: Response, value: ResponseAction) {.inline.} =
    setaction(message, value)

proc clearobsAction*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [21, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc hasobsAction*(message: Response): bool =
    result = hasField(message, 21)

proc setobsAction*(message: Response, value: ResponseObserverAction) =
    if message.response.kind != Response_response_Kind.ObsAction:
        message.response = Response_response_OneOf(kind: Response_response_Kind.ObsAction, obsAction: value)
    else:
        message.response.obsAction = value
    setField(message, 21)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc obsAction*(message: Response): ResponseObserverAction {.inline.} =
    message.response.obsAction

proc `obsAction=`*(message: Response, value: ResponseObserverAction) {.inline.} =
    setobsAction(message, value)

proc clearstep*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc hasstep*(message: Response): bool =
    result = hasField(message, 12)

proc setstep*(message: Response, value: ResponseStep) =
    if message.response.kind != Response_response_Kind.Step:
        message.response = Response_response_OneOf(kind: Response_response_Kind.Step, step: value)
    else:
        message.response.step = value
    setField(message, 12)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 13, 14, 15, 16, 17, 18, 22, 19, 20])

proc step*(message: Response): ResponseStep {.inline.} =
    message.response.step

proc `step=`*(message: Response, value: ResponseStep) {.inline.} =
    setstep(message, value)

proc cleardata*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [13, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 14, 15, 16, 17, 18, 22, 19, 20])

proc hasdata*(message: Response): bool =
    result = hasField(message, 13)

proc setdata*(message: Response, value: ResponseData) =
    if message.response.kind != Response_response_Kind.Data:
        message.response = Response_response_OneOf(kind: Response_response_Kind.Data, data: value)
    else:
        message.response.data = value
    setField(message, 13)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 14, 15, 16, 17, 18, 22, 19, 20])

proc data*(message: Response): ResponseData {.inline.} =
    message.response.data

proc `data=`*(message: Response, value: ResponseData) {.inline.} =
    setdata(message, value)

proc clearquery*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [14, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 15, 16, 17, 18, 22, 19, 20])

proc hasquery*(message: Response): bool =
    result = hasField(message, 14)

proc setquery*(message: Response, value: ResponseQuery) =
    if message.response.kind != Response_response_Kind.Query:
        message.response = Response_response_OneOf(kind: Response_response_Kind.Query, query: value)
    else:
        message.response.query = value
    setField(message, 14)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 15, 16, 17, 18, 22, 19, 20])

proc query*(message: Response): ResponseQuery {.inline.} =
    message.response.query

proc `query=`*(message: Response, value: ResponseQuery) {.inline.} =
    setquery(message, value)

proc clearsaveReplay*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 16, 17, 18, 22, 19, 20])

proc hassaveReplay*(message: Response): bool =
    result = hasField(message, 15)

proc setsaveReplay*(message: Response, value: ResponseSaveReplay) =
    if message.response.kind != Response_response_Kind.SaveReplay:
        message.response = Response_response_OneOf(kind: Response_response_Kind.SaveReplay, saveReplay: value)
    else:
        message.response.saveReplay = value
    setField(message, 15)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 16, 17, 18, 22, 19, 20])

proc saveReplay*(message: Response): ResponseSaveReplay {.inline.} =
    message.response.saveReplay

proc `saveReplay=`*(message: Response, value: ResponseSaveReplay) {.inline.} =
    setsaveReplay(message, value)

proc clearreplayInfo*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [16, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 17, 18, 22, 19, 20])

proc hasreplayInfo*(message: Response): bool =
    result = hasField(message, 16)

proc setreplayInfo*(message: Response, value: ResponseReplayInfo) =
    if message.response.kind != Response_response_Kind.ReplayInfo:
        message.response = Response_response_OneOf(kind: Response_response_Kind.ReplayInfo, replayInfo: value)
    else:
        message.response.replayInfo = value
    setField(message, 16)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 17, 18, 22, 19, 20])

proc replayInfo*(message: Response): ResponseReplayInfo {.inline.} =
    message.response.replayInfo

proc `replayInfo=`*(message: Response, value: ResponseReplayInfo) {.inline.} =
    setreplayInfo(message, value)

proc clearavailableMaps*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [17, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 18, 22, 19, 20])

proc hasavailableMaps*(message: Response): bool =
    result = hasField(message, 17)

proc setavailableMaps*(message: Response, value: ResponseAvailableMaps) =
    if message.response.kind != Response_response_Kind.AvailableMaps:
        message.response = Response_response_OneOf(kind: Response_response_Kind.AvailableMaps, availableMaps: value)
    else:
        message.response.availableMaps = value
    setField(message, 17)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 18, 22, 19, 20])

proc availableMaps*(message: Response): ResponseAvailableMaps {.inline.} =
    message.response.availableMaps

proc `availableMaps=`*(message: Response, value: ResponseAvailableMaps) {.inline.} =
    setavailableMaps(message, value)

proc clearsaveMap*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [18, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 22, 19, 20])

proc hassaveMap*(message: Response): bool =
    result = hasField(message, 18)

proc setsaveMap*(message: Response, value: ResponseSaveMap) =
    if message.response.kind != Response_response_Kind.SaveMap:
        message.response = Response_response_OneOf(kind: Response_response_Kind.SaveMap, saveMap: value)
    else:
        message.response.saveMap = value
    setField(message, 18)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 22, 19, 20])

proc saveMap*(message: Response): ResponseSaveMap {.inline.} =
    message.response.saveMap

proc `saveMap=`*(message: Response, value: ResponseSaveMap) {.inline.} =
    setsaveMap(message, value)

proc clearmapCommand*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [22, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 19, 20])

proc hasmapCommand*(message: Response): bool =
    result = hasField(message, 22)

proc setmapCommand*(message: Response, value: ResponseMapCommand) =
    if message.response.kind != Response_response_Kind.MapCommand:
        message.response = Response_response_OneOf(kind: Response_response_Kind.MapCommand, mapCommand: value)
    else:
        message.response.mapCommand = value
    setField(message, 22)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 19, 20])

proc mapCommand*(message: Response): ResponseMapCommand {.inline.} =
    message.response.mapCommand

proc `mapCommand=`*(message: Response, value: ResponseMapCommand) {.inline.} =
    setmapCommand(message, value)

proc clearping*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [19, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 20])

proc hasping*(message: Response): bool =
    result = hasField(message, 19)

proc setping*(message: Response, value: ResponsePing) =
    if message.response.kind != Response_response_Kind.Ping:
        message.response = Response_response_OneOf(kind: Response_response_Kind.Ping, ping: value)
    else:
        message.response.ping = value
    setField(message, 19)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 20])

proc ping*(message: Response): ResponsePing {.inline.} =
    message.response.ping

proc `ping=`*(message: Response, value: ResponsePing) {.inline.} =
    setping(message, value)

proc cleardebug*(message: Response) =
    reset(message.response)
    message.response.kind = Response_response_Kind.NotSet
    clearFields(message, [20, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19])

proc hasdebug*(message: Response): bool =
    result = hasField(message, 20)

proc setdebug*(message: Response, value: ResponseDebug) =
    if message.response.kind != Response_response_Kind.Debug:
        message.response = Response_response_OneOf(kind: Response_response_Kind.Debug, debug: value)
    else:
        message.response.debug = value
    setField(message, 20)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 22, 19])

proc debug*(message: Response): ResponseDebug {.inline.} =
    message.response.debug

proc `debug=`*(message: Response, value: ResponseDebug) {.inline.} =
    setdebug(message, value)

proc clearid*(message: Response) =
    message.id = 0
    clearFields(message, [97])

proc hasid*(message: Response): bool =
    result = hasField(message, 97)

proc setid*(message: Response, value: uint32) =
    message.id = value
    setField(message, 97)

proc id*(message: Response): uint32 {.inline.} =
    message.id

proc `id=`*(message: Response, value: uint32) {.inline.} =
    setid(message, value)

proc clearerror*(message: Response) =
    message.error = @[]
    clearFields(message, [98])

proc haserror*(message: Response): bool =
    result = hasField(message, 98) or (len(message.error) > 0)

proc seterror*(message: Response, value: seq[string]) =
    message.error = value
    setField(message, 98)

proc adderror*(message: Response, value: string) =
    add(message.error, value)

proc error*(message: Response): seq[string] {.inline.} =
    message.error

proc `error=`*(message: Response, value: seq[string]) {.inline.} =
    seterror(message, value)

proc clearstatus*(message: Response) =
    message.status = Status.launched
    clearFields(message, [99])

proc hasstatus*(message: Response): bool =
    result = hasField(message, 99)

proc setstatus*(message: Response, value: Status) =
    message.status = value
    setField(message, 99)

proc status*(message: Response): Status {.inline.} =
    message.status

proc `status=`*(message: Response, value: Status) {.inline.} =
    setstatus(message, value)

proc `$`*(message: Response): string =
    runnableExamples:
        echo $Response
        echo fmt"{Response}"
        echo &"{Response}"
    var resultSeq: seq[string]
    if message.hasid:
        resultSeq.add(&"id: {message.id}")
    if message.haserror:
        resultSeq.add(&"error: {message.error}")
    if message.hasstatus:
        resultSeq.add(&"status: {message.status}")
    if message.hascreateGame:
        resultSeq.add(&"createGame: {message.createGame}")
    if message.hasjoinGame:
        resultSeq.add(&"joinGame: {message.joinGame}")
    if message.hasrestartGame:
        resultSeq.add(&"restartGame: {message.restartGame}")
    if message.hasstartReplay:
        resultSeq.add(&"startReplay: {message.startReplay}")
    if message.hasleaveGame:
        resultSeq.add(&"leaveGame: {message.leaveGame}")
    if message.hasquickSave:
        resultSeq.add(&"quickSave: {message.quickSave}")
    if message.hasquickLoad:
        resultSeq.add(&"quickLoad: {message.quickLoad}")
    if message.hasquit:
        resultSeq.add(&"quit: {message.quit}")
    if message.hasgameInfo:
        resultSeq.add(&"gameInfo: {message.gameInfo}")
    if message.hasobservation:
        resultSeq.add(&"observation: {message.observation}")
    if message.hasaction:
        resultSeq.add(&"action: {message.action}")
    if message.hasobsAction:
        resultSeq.add(&"obsAction: {message.obsAction}")
    if message.hasstep:
        resultSeq.add(&"step: {message.step}")
    if message.hasdata:
        resultSeq.add(&"data: {message.data}")
    if message.hasquery:
        resultSeq.add(&"query: {message.query}")
    if message.hassaveReplay:
        resultSeq.add(&"saveReplay: {message.saveReplay}")
    if message.hasreplayInfo:
        resultSeq.add(&"replayInfo: {message.replayInfo}")
    if message.hasavailableMaps:
        resultSeq.add(&"availableMaps: {message.availableMaps}")
    if message.hassaveMap:
        resultSeq.add(&"saveMap: {message.saveMap}")
    if message.hasmapCommand:
        resultSeq.add(&"mapCommand: {message.mapCommand}")
    if message.hasping:
        resultSeq.add(&"ping: {message.ping}")
    if message.hasdebug:
        resultSeq.add(&"debug: {message.debug}")
    result = resultSeq.join(", ")
    result = &"Response({result})"

proc sizeOfResponse*(message: Response): uint64 =
    if hascreateGame(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseCreateGame(message.response.createGame))
    if hasjoinGame(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseJoinGame(message.response.joinGame))
    if hasrestartGame(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseRestartGame(message.response.restartGame))
    if hasstartReplay(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseStartReplay(message.response.startReplay))
    if hasleaveGame(message):
        result = result + sizeOfTag(5, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseLeaveGame(message.response.leaveGame))
    if hasquickSave(message):
        result = result + sizeOfTag(6, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseQuickSave(message.response.quickSave))
    if hasquickLoad(message):
        result = result + sizeOfTag(7, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseQuickLoad(message.response.quickLoad))
    if hasquit(message):
        result = result + sizeOfTag(8, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseQuit(message.response.quit))
    if hasgameInfo(message):
        result = result + sizeOfTag(9, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseGameInfo(message.response.gameInfo))
    if hasobservation(message):
        result = result + sizeOfTag(10, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseObservation(message.response.observation))
    if hasaction(message):
        result = result + sizeOfTag(11, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseAction(message.response.action))
    if hasobsAction(message):
        result = result + sizeOfTag(21, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseObserverAction(message.response.obsAction))
    if hasstep(message):
        result = result + sizeOfTag(12, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseStep(message.response.step))
    if hasdata(message):
        result = result + sizeOfTag(13, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseData(message.response.data))
    if hasquery(message):
        result = result + sizeOfTag(14, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseQuery(message.response.query))
    if hassaveReplay(message):
        result = result + sizeOfTag(15, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseSaveReplay(message.response.saveReplay))
    if hasreplayInfo(message):
        result = result + sizeOfTag(16, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseReplayInfo(message.response.replayInfo))
    if hasavailableMaps(message):
        result = result + sizeOfTag(17, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseAvailableMaps(message.response.availableMaps))
    if hassaveMap(message):
        result = result + sizeOfTag(18, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseSaveMap(message.response.saveMap))
    if hasmapCommand(message):
        result = result + sizeOfTag(22, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseMapCommand(message.response.mapCommand))
    if hasping(message):
        result = result + sizeOfTag(19, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponsePing(message.response.ping))
    if hasdebug(message):
        result = result + sizeOfTag(20, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfResponseDebug(message.response.debug))
    if hasid(message):
        result = result + sizeOfTag(97, WireType.Varint)
        result = result + sizeOfUInt32(message.id)
    for value in message.error:
        result = result + sizeOfTag(98, WireType.LengthDelimited)
        result = result + sizeOfString(value)
    if hasstatus(message):
        result = result + sizeOfTag(99, WireType.Varint)
        result = result + sizeOfEnum[Status](message.status)
    result = result + sizeOfUnknownFields(message)

proc writeResponse*(stream: Stream, message: Response) =
    if hascreateGame(message):
        writeMessage(stream, message.response.createGame, 1)
    if hasjoinGame(message):
        writeMessage(stream, message.response.joinGame, 2)
    if hasrestartGame(message):
        writeMessage(stream, message.response.restartGame, 3)
    if hasstartReplay(message):
        writeMessage(stream, message.response.startReplay, 4)
    if hasleaveGame(message):
        writeMessage(stream, message.response.leaveGame, 5)
    if hasquickSave(message):
        writeMessage(stream, message.response.quickSave, 6)
    if hasquickLoad(message):
        writeMessage(stream, message.response.quickLoad, 7)
    if hasquit(message):
        writeMessage(stream, message.response.quit, 8)
    if hasgameInfo(message):
        writeMessage(stream, message.response.gameInfo, 9)
    if hasobservation(message):
        writeMessage(stream, message.response.observation, 10)
    if hasaction(message):
        writeMessage(stream, message.response.action, 11)
    if hasobsAction(message):
        writeMessage(stream, message.response.obsAction, 21)
    if hasstep(message):
        writeMessage(stream, message.response.step, 12)
    if hasdata(message):
        writeMessage(stream, message.response.data, 13)
    if hasquery(message):
        writeMessage(stream, message.response.query, 14)
    if hassaveReplay(message):
        writeMessage(stream, message.response.saveReplay, 15)
    if hasreplayInfo(message):
        writeMessage(stream, message.response.replayInfo, 16)
    if hasavailableMaps(message):
        writeMessage(stream, message.response.availableMaps, 17)
    if hassaveMap(message):
        writeMessage(stream, message.response.saveMap, 18)
    if hasmapCommand(message):
        writeMessage(stream, message.response.mapCommand, 22)
    if hasping(message):
        writeMessage(stream, message.response.ping, 19)
    if hasdebug(message):
        writeMessage(stream, message.response.debug, 20)
    if hasid(message):
        protoWriteUInt32(stream, message.id, 97)
    for value in message.error:
        protoWriteString(stream, value, 98)
    if hasstatus(message):
        protoWriteEnum(stream, message.status, 99)
    writeUnknownFields(stream, message)

proc readResponse*(stream: Stream): Response =
    result = newResponse()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcreateGame(result, newResponseCreateGame(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setjoinGame(result, newResponseJoinGame(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setrestartGame(result, newResponseRestartGame(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setstartReplay(result, newResponseStartReplay(data))
        of 5:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setleaveGame(result, newResponseLeaveGame(data))
        of 6:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setquickSave(result, newResponseQuickSave(data))
        of 7:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setquickLoad(result, newResponseQuickLoad(data))
        of 8:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setquit(result, newResponseQuit(data))
        of 9:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setgameInfo(result, newResponseGameInfo(data))
        of 10:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setobservation(result, newResponseObservation(data))
        of 11:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setaction(result, newResponseAction(data))
        of 21:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setobsAction(result, newResponseObserverAction(data))
        of 12:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setstep(result, newResponseStep(data))
        of 13:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setdata(result, newResponseData(data))
        of 14:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setquery(result, newResponseQuery(data))
        of 15:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setsaveReplay(result, newResponseSaveReplay(data))
        of 16:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setreplayInfo(result, newResponseReplayInfo(data))
        of 17:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setavailableMaps(result, newResponseAvailableMaps(data))
        of 18:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setsaveMap(result, newResponseSaveMap(data))
        of 22:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setmapCommand(result, newResponseMapCommand(data))
        of 19:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setping(result, newResponsePing(data))
        of 20:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setdebug(result, newResponseDebug(data))
        of 97:
            expectWireType(wireType, WireType.Varint)
            setid(result, protoReadUInt32(stream))
        of 98:
            expectWireType(wireType, WireType.LengthDelimited)
            adderror(result, protoReadString(stream))
        of 99:
            expectWireType(wireType, WireType.Varint)
            setstatus(result, protoReadEnum[Status](stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: Response): string =
    let
        ss = newStringStream()
    writeResponse(ss, message)
    result = ss.data

proc newResponse*(data: string): Response =
    let
        ss = newStringStream(data)
    result = readResponse(ss)

proc newResponse*(data: seq[byte]): Response =
    let
        ss = newStringStream(cast[string](data))
    result = readResponse(ss)


proc fullyQualifiedName*(T: typedesc[RequestPing]): string = "RequestPing"

proc readRequestPingImpl(stream: Stream): Message = readRequestPing(stream)
proc writeRequestPingImpl(stream: Stream, msg: Message) = writeRequestPing(stream, RequestPing(msg))

proc RequestPingProcs*(): MessageProcs =
    result.readImpl = readRequestPingImpl
    result.writeImpl = writeRequestPingImpl

proc newRequestPing*(): RequestPing =
    new(result)
    initMessage(result[])
    result.procs = RequestPingProcs()

proc `$`*(message: RequestPing): string =
    runnableExamples:
        echo $RequestPing
        echo fmt"{RequestPing}"
        echo &"{RequestPing}"
    var resultSeq: seq[string]
    result = resultSeq.join(", ")
    result = &"RequestPing({result})"

proc sizeOfRequestPing*(message: RequestPing): uint64 =
    result = result + sizeOfUnknownFields(message)

proc writeRequestPing*(stream: Stream, message: RequestPing) =
    writeUnknownFields(stream, message)

proc readRequestPing*(stream: Stream): RequestPing =
    result = newRequestPing()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestPing): string =
    let
        ss = newStringStream()
    writeRequestPing(ss, message)
    result = ss.data

proc newRequestPing*(data: string): RequestPing =
    let
        ss = newStringStream(data)
    result = readRequestPing(ss)

proc newRequestPing*(data: seq[byte]): RequestPing =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestPing(ss)


proc fullyQualifiedName*(T: typedesc[RequestQuickSave]): string = "RequestQuickSave"

proc readRequestQuickSaveImpl(stream: Stream): Message = readRequestQuickSave(stream)
proc writeRequestQuickSaveImpl(stream: Stream, msg: Message) = writeRequestQuickSave(stream, RequestQuickSave(msg))

proc RequestQuickSaveProcs*(): MessageProcs =
    result.readImpl = readRequestQuickSaveImpl
    result.writeImpl = writeRequestQuickSaveImpl

proc newRequestQuickSave*(): RequestQuickSave =
    new(result)
    initMessage(result[])
    result.procs = RequestQuickSaveProcs()

proc `$`*(message: RequestQuickSave): string =
    runnableExamples:
        echo $RequestQuickSave
        echo fmt"{RequestQuickSave}"
        echo &"{RequestQuickSave}"
    var resultSeq: seq[string]
    result = resultSeq.join(", ")
    result = &"RequestQuickSave({result})"

proc sizeOfRequestQuickSave*(message: RequestQuickSave): uint64 =
    result = result + sizeOfUnknownFields(message)

proc writeRequestQuickSave*(stream: Stream, message: RequestQuickSave) =
    writeUnknownFields(stream, message)

proc readRequestQuickSave*(stream: Stream): RequestQuickSave =
    result = newRequestQuickSave()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestQuickSave): string =
    let
        ss = newStringStream()
    writeRequestQuickSave(ss, message)
    result = ss.data

proc newRequestQuickSave*(data: string): RequestQuickSave =
    let
        ss = newStringStream(data)
    result = readRequestQuickSave(ss)

proc newRequestQuickSave*(data: seq[byte]): RequestQuickSave =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestQuickSave(ss)


proc fullyQualifiedName*(T: typedesc[RequestGameInfo]): string = "RequestGameInfo"

proc readRequestGameInfoImpl(stream: Stream): Message = readRequestGameInfo(stream)
proc writeRequestGameInfoImpl(stream: Stream, msg: Message) = writeRequestGameInfo(stream, RequestGameInfo(msg))

proc RequestGameInfoProcs*(): MessageProcs =
    result.readImpl = readRequestGameInfoImpl
    result.writeImpl = writeRequestGameInfoImpl

proc newRequestGameInfo*(): RequestGameInfo =
    new(result)
    initMessage(result[])
    result.procs = RequestGameInfoProcs()

proc `$`*(message: RequestGameInfo): string =
    runnableExamples:
        echo $RequestGameInfo
        echo fmt"{RequestGameInfo}"
        echo &"{RequestGameInfo}"
    var resultSeq: seq[string]
    result = resultSeq.join(", ")
    result = &"RequestGameInfo({result})"

proc sizeOfRequestGameInfo*(message: RequestGameInfo): uint64 =
    result = result + sizeOfUnknownFields(message)

proc writeRequestGameInfo*(stream: Stream, message: RequestGameInfo) =
    writeUnknownFields(stream, message)

proc readRequestGameInfo*(stream: Stream): RequestGameInfo =
    result = newRequestGameInfo()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestGameInfo): string =
    let
        ss = newStringStream()
    writeRequestGameInfo(ss, message)
    result = ss.data

proc newRequestGameInfo*(data: string): RequestGameInfo =
    let
        ss = newStringStream(data)
    result = readRequestGameInfo(ss)

proc newRequestGameInfo*(data: seq[byte]): RequestGameInfo =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestGameInfo(ss)


proc fullyQualifiedName*(T: typedesc[RequestDebug]): string = "RequestDebug"

proc readRequestDebugImpl(stream: Stream): Message = readRequestDebug(stream)
proc writeRequestDebugImpl(stream: Stream, msg: Message) = writeRequestDebug(stream, RequestDebug(msg))

proc RequestDebugProcs*(): MessageProcs =
    result.readImpl = readRequestDebugImpl
    result.writeImpl = writeRequestDebugImpl

proc newRequestDebug*(): RequestDebug =
    new(result)
    initMessage(result[])
    result.procs = RequestDebugProcs()
    result.debug = @[]

proc cleardebug*(message: RequestDebug) =
    message.debug = @[]
    clearFields(message, [1])

proc hasdebug*(message: RequestDebug): bool =
    result = hasField(message, 1) or (len(message.debug) > 0)

proc setdebug*(message: RequestDebug, value: seq[DebugCommand]) =
    message.debug = value
    setField(message, 1)

proc adddebug*(message: RequestDebug, value: DebugCommand) =
    add(message.debug, value)

proc debug*(message: RequestDebug): seq[DebugCommand] {.inline.} =
    message.debug

proc `debug=`*(message: RequestDebug, value: seq[DebugCommand]) {.inline.} =
    setdebug(message, value)

proc `$`*(message: RequestDebug): string =
    runnableExamples:
        echo $RequestDebug
        echo fmt"{RequestDebug}"
        echo &"{RequestDebug}"
    var resultSeq: seq[string]
    if message.hasdebug:
        resultSeq.add(&"debug: {message.debug}")
    result = resultSeq.join(", ")
    result = &"RequestDebug({result})"

proc sizeOfRequestDebug*(message: RequestDebug): uint64 =
    for value in message.debug:
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfDebugCommand(value))
    result = result + sizeOfUnknownFields(message)

proc writeRequestDebug*(stream: Stream, message: RequestDebug) =
    for value in message.debug:
        writeMessage(stream, value, 1)
    writeUnknownFields(stream, message)

proc readRequestDebug*(stream: Stream): RequestDebug =
    result = newRequestDebug()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            adddebug(result, newDebugCommand(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestDebug): string =
    let
        ss = newStringStream()
    writeRequestDebug(ss, message)
    result = ss.data

proc newRequestDebug*(data: string): RequestDebug =
    let
        ss = newStringStream(data)
    result = readRequestDebug(ss)

proc newRequestDebug*(data: seq[byte]): RequestDebug =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestDebug(ss)


proc fullyQualifiedName*(T: typedesc[RequestCreateGame]): string = "RequestCreateGame"

proc readRequestCreateGameImpl(stream: Stream): Message = readRequestCreateGame(stream)
proc writeRequestCreateGameImpl(stream: Stream, msg: Message) = writeRequestCreateGame(stream, RequestCreateGame(msg))

proc RequestCreateGameProcs*(): MessageProcs =
    result.readImpl = readRequestCreateGameImpl
    result.writeImpl = writeRequestCreateGameImpl

proc newRequestCreateGame*(): RequestCreateGame =
    new(result)
    initMessage(result[])
    result.procs = RequestCreateGameProcs()
    result.playerSetup = @[]
    result.disableFog = false
    result.randomSeed = 0
    result.realtime = false
    result.map = RequestCreateGame_map_OneOf(kind: RequestCreateGame_map_Kind.NotSet)

proc clearlocalMap*(message: RequestCreateGame) =
    reset(message.map)
    message.map.kind = RequestCreateGame_map_Kind.NotSet
    clearFields(message, [1, 2])

proc haslocalMap*(message: RequestCreateGame): bool =
    result = hasField(message, 1)

proc setlocalMap*(message: RequestCreateGame, value: LocalMap) =
    if message.map.kind != RequestCreateGame_map_Kind.LocalMap:
        message.map = RequestCreateGame_map_OneOf(kind: RequestCreateGame_map_Kind.LocalMap, localMap: value)
    else:
        message.map.localMap = value
    setField(message, 1)
    clearFields(message, [2])

proc localMap*(message: RequestCreateGame): LocalMap {.inline.} =
    message.map.localMap

proc `localMap=`*(message: RequestCreateGame, value: LocalMap) {.inline.} =
    setlocalMap(message, value)

proc clearbattlenetMapName*(message: RequestCreateGame) =
    reset(message.map)
    message.map.kind = RequestCreateGame_map_Kind.NotSet
    clearFields(message, [2, 1])

proc hasbattlenetMapName*(message: RequestCreateGame): bool =
    result = hasField(message, 2)

proc setbattlenetMapName*(message: RequestCreateGame, value: string) =
    if message.map.kind != RequestCreateGame_map_Kind.BattlenetMapName:
        message.map = RequestCreateGame_map_OneOf(kind: RequestCreateGame_map_Kind.BattlenetMapName, battlenetMapName: value)
    else:
        message.map.battlenetMapName = value
    setField(message, 2)
    clearFields(message, [1])

proc battlenetMapName*(message: RequestCreateGame): string {.inline.} =
    message.map.battlenetMapName

proc `battlenetMapName=`*(message: RequestCreateGame, value: string) {.inline.} =
    setbattlenetMapName(message, value)

proc clearplayerSetup*(message: RequestCreateGame) =
    message.playerSetup = @[]
    clearFields(message, [3])

proc hasplayerSetup*(message: RequestCreateGame): bool =
    result = hasField(message, 3) or (len(message.playerSetup) > 0)

proc setplayerSetup*(message: RequestCreateGame, value: seq[PlayerSetup]) =
    message.playerSetup = value
    setField(message, 3)

proc addplayerSetup*(message: RequestCreateGame, value: PlayerSetup) =
    add(message.playerSetup, value)

proc playerSetup*(message: RequestCreateGame): seq[PlayerSetup] {.inline.} =
    message.playerSetup

proc `playerSetup=`*(message: RequestCreateGame, value: seq[PlayerSetup]) {.inline.} =
    setplayerSetup(message, value)

proc cleardisableFog*(message: RequestCreateGame) =
    message.disableFog = false
    clearFields(message, [4])

proc hasdisableFog*(message: RequestCreateGame): bool =
    result = hasField(message, 4)

proc setdisableFog*(message: RequestCreateGame, value: bool) =
    message.disableFog = value
    setField(message, 4)

proc disableFog*(message: RequestCreateGame): bool {.inline.} =
    message.disableFog

proc `disableFog=`*(message: RequestCreateGame, value: bool) {.inline.} =
    setdisableFog(message, value)

proc clearrandomSeed*(message: RequestCreateGame) =
    message.randomSeed = 0
    clearFields(message, [5])

proc hasrandomSeed*(message: RequestCreateGame): bool =
    result = hasField(message, 5)

proc setrandomSeed*(message: RequestCreateGame, value: uint32) =
    message.randomSeed = value
    setField(message, 5)

proc randomSeed*(message: RequestCreateGame): uint32 {.inline.} =
    message.randomSeed

proc `randomSeed=`*(message: RequestCreateGame, value: uint32) {.inline.} =
    setrandomSeed(message, value)

proc clearrealtime*(message: RequestCreateGame) =
    message.realtime = false
    clearFields(message, [6])

proc hasrealtime*(message: RequestCreateGame): bool =
    result = hasField(message, 6)

proc setrealtime*(message: RequestCreateGame, value: bool) =
    message.realtime = value
    setField(message, 6)

proc realtime*(message: RequestCreateGame): bool {.inline.} =
    message.realtime

proc `realtime=`*(message: RequestCreateGame, value: bool) {.inline.} =
    setrealtime(message, value)

proc `$`*(message: RequestCreateGame): string =
    runnableExamples:
        echo $RequestCreateGame
        echo fmt"{RequestCreateGame}"
        echo &"{RequestCreateGame}"
    var resultSeq: seq[string]
    if message.hasplayerSetup:
        resultSeq.add(&"playerSetup: {message.playerSetup}")
    if message.hasdisableFog:
        resultSeq.add(&"disableFog: {message.disableFog}")
    if message.hasrandomSeed:
        resultSeq.add(&"randomSeed: {message.randomSeed}")
    if message.hasrealtime:
        resultSeq.add(&"realtime: {message.realtime}")
    if message.haslocalMap:
        resultSeq.add(&"localMap: {message.localMap}")
    if message.hasbattlenetMapName:
        resultSeq.add(&"battlenetMapName: {message.battlenetMapName}")
    result = resultSeq.join(", ")
    result = &"RequestCreateGame({result})"

proc sizeOfRequestCreateGame*(message: RequestCreateGame): uint64 =
    if haslocalMap(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfLocalMap(message.map.localMap))
    if hasbattlenetMapName(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfString(message.map.battlenetMapName)
    for value in message.playerSetup:
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPlayerSetup(value))
    if hasdisableFog(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfBool(message.disableFog)
    if hasrandomSeed(message):
        result = result + sizeOfTag(5, WireType.Varint)
        result = result + sizeOfUInt32(message.randomSeed)
    if hasrealtime(message):
        result = result + sizeOfTag(6, WireType.Varint)
        result = result + sizeOfBool(message.realtime)
    result = result + sizeOfUnknownFields(message)

proc writeRequestCreateGame*(stream: Stream, message: RequestCreateGame) =
    if haslocalMap(message):
        writeMessage(stream, message.map.localMap, 1)
    if hasbattlenetMapName(message):
        protoWriteString(stream, message.map.battlenetMapName, 2)
    for value in message.playerSetup:
        writeMessage(stream, value, 3)
    if hasdisableFog(message):
        protoWriteBool(stream, message.disableFog, 4)
    if hasrandomSeed(message):
        protoWriteUInt32(stream, message.randomSeed, 5)
    if hasrealtime(message):
        protoWriteBool(stream, message.realtime, 6)
    writeUnknownFields(stream, message)

proc readRequestCreateGame*(stream: Stream): RequestCreateGame =
    result = newRequestCreateGame()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setlocalMap(result, newLocalMap(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            setbattlenetMapName(result, protoReadString(stream))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addplayerSetup(result, newPlayerSetup(data))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setdisableFog(result, protoReadBool(stream))
        of 5:
            expectWireType(wireType, WireType.Varint)
            setrandomSeed(result, protoReadUInt32(stream))
        of 6:
            expectWireType(wireType, WireType.Varint)
            setrealtime(result, protoReadBool(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestCreateGame): string =
    let
        ss = newStringStream()
    writeRequestCreateGame(ss, message)
    result = ss.data

proc newRequestCreateGame*(data: string): RequestCreateGame =
    let
        ss = newStringStream(data)
    result = readRequestCreateGame(ss)

proc newRequestCreateGame*(data: seq[byte]): RequestCreateGame =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestCreateGame(ss)


proc fullyQualifiedName*(T: typedesc[RequestReplayInfo]): string = "RequestReplayInfo"

proc readRequestReplayInfoImpl(stream: Stream): Message = readRequestReplayInfo(stream)
proc writeRequestReplayInfoImpl(stream: Stream, msg: Message) = writeRequestReplayInfo(stream, RequestReplayInfo(msg))

proc RequestReplayInfoProcs*(): MessageProcs =
    result.readImpl = readRequestReplayInfoImpl
    result.writeImpl = writeRequestReplayInfoImpl

proc newRequestReplayInfo*(): RequestReplayInfo =
    new(result)
    initMessage(result[])
    result.procs = RequestReplayInfoProcs()
    result.downloadData = false
    result.replay = RequestReplayInfo_replay_OneOf(kind: RequestReplayInfo_replay_Kind.NotSet)

proc clearreplayPath*(message: RequestReplayInfo) =
    reset(message.replay)
    message.replay.kind = RequestReplayInfo_replay_Kind.NotSet
    clearFields(message, [1, 2])

proc hasreplayPath*(message: RequestReplayInfo): bool =
    result = hasField(message, 1)

proc setreplayPath*(message: RequestReplayInfo, value: string) =
    if message.replay.kind != RequestReplayInfo_replay_Kind.ReplayPath:
        message.replay = RequestReplayInfo_replay_OneOf(kind: RequestReplayInfo_replay_Kind.ReplayPath, replayPath: value)
    else:
        message.replay.replayPath = value
    setField(message, 1)
    clearFields(message, [2])

proc replayPath*(message: RequestReplayInfo): string {.inline.} =
    message.replay.replayPath

proc `replayPath=`*(message: RequestReplayInfo, value: string) {.inline.} =
    setreplayPath(message, value)

proc clearreplayData*(message: RequestReplayInfo) =
    reset(message.replay)
    message.replay.kind = RequestReplayInfo_replay_Kind.NotSet
    clearFields(message, [2, 1])

proc hasreplayData*(message: RequestReplayInfo): bool =
    result = hasField(message, 2)

proc setreplayData*(message: RequestReplayInfo, value: seq[byte]) =
    if message.replay.kind != RequestReplayInfo_replay_Kind.ReplayData:
        message.replay = RequestReplayInfo_replay_OneOf(kind: RequestReplayInfo_replay_Kind.ReplayData, replayData: value)
    else:
        message.replay.replayData = value
    setField(message, 2)
    clearFields(message, [1])

proc replayData*(message: RequestReplayInfo): seq[byte] {.inline.} =
    message.replay.replayData

proc `replayData=`*(message: RequestReplayInfo, value: seq[byte]) {.inline.} =
    setreplayData(message, value)

proc cleardownloadData*(message: RequestReplayInfo) =
    message.downloadData = false
    clearFields(message, [3])

proc hasdownloadData*(message: RequestReplayInfo): bool =
    result = hasField(message, 3)

proc setdownloadData*(message: RequestReplayInfo, value: bool) =
    message.downloadData = value
    setField(message, 3)

proc downloadData*(message: RequestReplayInfo): bool {.inline.} =
    message.downloadData

proc `downloadData=`*(message: RequestReplayInfo, value: bool) {.inline.} =
    setdownloadData(message, value)

proc `$`*(message: RequestReplayInfo): string =
    runnableExamples:
        echo $RequestReplayInfo
        echo fmt"{RequestReplayInfo}"
        echo &"{RequestReplayInfo}"
    var resultSeq: seq[string]
    if message.hasdownloadData:
        resultSeq.add(&"downloadData: {message.downloadData}")
    if message.hasreplayPath:
        resultSeq.add(&"replayPath: {message.replayPath}")
    if message.hasreplayData:
        resultSeq.add(&"replayData: {message.replayData}")
    result = resultSeq.join(", ")
    result = &"RequestReplayInfo({result})"

proc sizeOfRequestReplayInfo*(message: RequestReplayInfo): uint64 =
    if hasreplayPath(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfString(message.replay.replayPath)
    if hasreplayData(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfBytes(message.replay.replayData)
    if hasdownloadData(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfBool(message.downloadData)
    result = result + sizeOfUnknownFields(message)

proc writeRequestReplayInfo*(stream: Stream, message: RequestReplayInfo) =
    if hasreplayPath(message):
        protoWriteString(stream, message.replay.replayPath, 1)
    if hasreplayData(message):
        protoWriteBytes(stream, message.replay.replayData, 2)
    if hasdownloadData(message):
        protoWriteBool(stream, message.downloadData, 3)
    writeUnknownFields(stream, message)

proc readRequestReplayInfo*(stream: Stream): RequestReplayInfo =
    result = newRequestReplayInfo()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            setreplayPath(result, protoReadString(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            setreplayData(result, protoReadBytes(stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setdownloadData(result, protoReadBool(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestReplayInfo): string =
    let
        ss = newStringStream()
    writeRequestReplayInfo(ss, message)
    result = ss.data

proc newRequestReplayInfo*(data: string): RequestReplayInfo =
    let
        ss = newStringStream(data)
    result = readRequestReplayInfo(ss)

proc newRequestReplayInfo*(data: seq[byte]): RequestReplayInfo =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestReplayInfo(ss)


proc fullyQualifiedName*(T: typedesc[RequestSaveMap]): string = "RequestSaveMap"

proc readRequestSaveMapImpl(stream: Stream): Message = readRequestSaveMap(stream)
proc writeRequestSaveMapImpl(stream: Stream, msg: Message) = writeRequestSaveMap(stream, RequestSaveMap(msg))

proc RequestSaveMapProcs*(): MessageProcs =
    result.readImpl = readRequestSaveMapImpl
    result.writeImpl = writeRequestSaveMapImpl

proc newRequestSaveMap*(): RequestSaveMap =
    new(result)
    initMessage(result[])
    result.procs = RequestSaveMapProcs()
    result.mapPath = ""
    result.mapData = @[]

proc clearmapPath*(message: RequestSaveMap) =
    message.mapPath = ""
    clearFields(message, [1])

proc hasmapPath*(message: RequestSaveMap): bool =
    result = hasField(message, 1)

proc setmapPath*(message: RequestSaveMap, value: string) =
    message.mapPath = value
    setField(message, 1)

proc mapPath*(message: RequestSaveMap): string {.inline.} =
    message.mapPath

proc `mapPath=`*(message: RequestSaveMap, value: string) {.inline.} =
    setmapPath(message, value)

proc clearmapData*(message: RequestSaveMap) =
    message.mapData = @[]
    clearFields(message, [2])

proc hasmapData*(message: RequestSaveMap): bool =
    result = hasField(message, 2)

proc setmapData*(message: RequestSaveMap, value: seq[byte]) =
    message.mapData = value
    setField(message, 2)

proc mapData*(message: RequestSaveMap): seq[byte] {.inline.} =
    message.mapData

proc `mapData=`*(message: RequestSaveMap, value: seq[byte]) {.inline.} =
    setmapData(message, value)

proc `$`*(message: RequestSaveMap): string =
    runnableExamples:
        echo $RequestSaveMap
        echo fmt"{RequestSaveMap}"
        echo &"{RequestSaveMap}"
    var resultSeq: seq[string]
    if message.hasmapPath:
        resultSeq.add(&"mapPath: {message.mapPath}")
    if message.hasmapData:
        resultSeq.add(&"mapData: {message.mapData}")
    result = resultSeq.join(", ")
    result = &"RequestSaveMap({result})"

proc sizeOfRequestSaveMap*(message: RequestSaveMap): uint64 =
    if hasmapPath(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfString(message.mapPath)
    if hasmapData(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfBytes(message.mapData)
    result = result + sizeOfUnknownFields(message)

proc writeRequestSaveMap*(stream: Stream, message: RequestSaveMap) =
    if hasmapPath(message):
        protoWriteString(stream, message.mapPath, 1)
    if hasmapData(message):
        protoWriteBytes(stream, message.mapData, 2)
    writeUnknownFields(stream, message)

proc readRequestSaveMap*(stream: Stream): RequestSaveMap =
    result = newRequestSaveMap()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            setmapPath(result, protoReadString(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            setmapData(result, protoReadBytes(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestSaveMap): string =
    let
        ss = newStringStream()
    writeRequestSaveMap(ss, message)
    result = ss.data

proc newRequestSaveMap*(data: string): RequestSaveMap =
    let
        ss = newStringStream(data)
    result = readRequestSaveMap(ss)

proc newRequestSaveMap*(data: seq[byte]): RequestSaveMap =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestSaveMap(ss)


proc fullyQualifiedName*(T: typedesc[RequestQuit]): string = "RequestQuit"

proc readRequestQuitImpl(stream: Stream): Message = readRequestQuit(stream)
proc writeRequestQuitImpl(stream: Stream, msg: Message) = writeRequestQuit(stream, RequestQuit(msg))

proc RequestQuitProcs*(): MessageProcs =
    result.readImpl = readRequestQuitImpl
    result.writeImpl = writeRequestQuitImpl

proc newRequestQuit*(): RequestQuit =
    new(result)
    initMessage(result[])
    result.procs = RequestQuitProcs()

proc `$`*(message: RequestQuit): string =
    runnableExamples:
        echo $RequestQuit
        echo fmt"{RequestQuit}"
        echo &"{RequestQuit}"
    var resultSeq: seq[string]
    result = resultSeq.join(", ")
    result = &"RequestQuit({result})"

proc sizeOfRequestQuit*(message: RequestQuit): uint64 =
    result = result + sizeOfUnknownFields(message)

proc writeRequestQuit*(stream: Stream, message: RequestQuit) =
    writeUnknownFields(stream, message)

proc readRequestQuit*(stream: Stream): RequestQuit =
    result = newRequestQuit()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestQuit): string =
    let
        ss = newStringStream()
    writeRequestQuit(ss, message)
    result = ss.data

proc newRequestQuit*(data: string): RequestQuit =
    let
        ss = newStringStream(data)
    result = readRequestQuit(ss)

proc newRequestQuit*(data: seq[byte]): RequestQuit =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestQuit(ss)


proc fullyQualifiedName*(T: typedesc[RequestAvailableMaps]): string = "RequestAvailableMaps"

proc readRequestAvailableMapsImpl(stream: Stream): Message = readRequestAvailableMaps(stream)
proc writeRequestAvailableMapsImpl(stream: Stream, msg: Message) = writeRequestAvailableMaps(stream, RequestAvailableMaps(msg))

proc RequestAvailableMapsProcs*(): MessageProcs =
    result.readImpl = readRequestAvailableMapsImpl
    result.writeImpl = writeRequestAvailableMapsImpl

proc newRequestAvailableMaps*(): RequestAvailableMaps =
    new(result)
    initMessage(result[])
    result.procs = RequestAvailableMapsProcs()

proc `$`*(message: RequestAvailableMaps): string =
    runnableExamples:
        echo $RequestAvailableMaps
        echo fmt"{RequestAvailableMaps}"
        echo &"{RequestAvailableMaps}"
    var resultSeq: seq[string]
    result = resultSeq.join(", ")
    result = &"RequestAvailableMaps({result})"

proc sizeOfRequestAvailableMaps*(message: RequestAvailableMaps): uint64 =
    result = result + sizeOfUnknownFields(message)

proc writeRequestAvailableMaps*(stream: Stream, message: RequestAvailableMaps) =
    writeUnknownFields(stream, message)

proc readRequestAvailableMaps*(stream: Stream): RequestAvailableMaps =
    result = newRequestAvailableMaps()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestAvailableMaps): string =
    let
        ss = newStringStream()
    writeRequestAvailableMaps(ss, message)
    result = ss.data

proc newRequestAvailableMaps*(data: string): RequestAvailableMaps =
    let
        ss = newStringStream(data)
    result = readRequestAvailableMaps(ss)

proc newRequestAvailableMaps*(data: seq[byte]): RequestAvailableMaps =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestAvailableMaps(ss)


proc fullyQualifiedName*(T: typedesc[RequestLeaveGame]): string = "RequestLeaveGame"

proc readRequestLeaveGameImpl(stream: Stream): Message = readRequestLeaveGame(stream)
proc writeRequestLeaveGameImpl(stream: Stream, msg: Message) = writeRequestLeaveGame(stream, RequestLeaveGame(msg))

proc RequestLeaveGameProcs*(): MessageProcs =
    result.readImpl = readRequestLeaveGameImpl
    result.writeImpl = writeRequestLeaveGameImpl

proc newRequestLeaveGame*(): RequestLeaveGame =
    new(result)
    initMessage(result[])
    result.procs = RequestLeaveGameProcs()

proc `$`*(message: RequestLeaveGame): string =
    runnableExamples:
        echo $RequestLeaveGame
        echo fmt"{RequestLeaveGame}"
        echo &"{RequestLeaveGame}"
    var resultSeq: seq[string]
    result = resultSeq.join(", ")
    result = &"RequestLeaveGame({result})"

proc sizeOfRequestLeaveGame*(message: RequestLeaveGame): uint64 =
    result = result + sizeOfUnknownFields(message)

proc writeRequestLeaveGame*(stream: Stream, message: RequestLeaveGame) =
    writeUnknownFields(stream, message)

proc readRequestLeaveGame*(stream: Stream): RequestLeaveGame =
    result = newRequestLeaveGame()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestLeaveGame): string =
    let
        ss = newStringStream()
    writeRequestLeaveGame(ss, message)
    result = ss.data

proc newRequestLeaveGame*(data: string): RequestLeaveGame =
    let
        ss = newStringStream(data)
    result = readRequestLeaveGame(ss)

proc newRequestLeaveGame*(data: seq[byte]): RequestLeaveGame =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestLeaveGame(ss)


proc fullyQualifiedName*(T: typedesc[RequestSaveReplay]): string = "RequestSaveReplay"

proc readRequestSaveReplayImpl(stream: Stream): Message = readRequestSaveReplay(stream)
proc writeRequestSaveReplayImpl(stream: Stream, msg: Message) = writeRequestSaveReplay(stream, RequestSaveReplay(msg))

proc RequestSaveReplayProcs*(): MessageProcs =
    result.readImpl = readRequestSaveReplayImpl
    result.writeImpl = writeRequestSaveReplayImpl

proc newRequestSaveReplay*(): RequestSaveReplay =
    new(result)
    initMessage(result[])
    result.procs = RequestSaveReplayProcs()

proc `$`*(message: RequestSaveReplay): string =
    runnableExamples:
        echo $RequestSaveReplay
        echo fmt"{RequestSaveReplay}"
        echo &"{RequestSaveReplay}"
    var resultSeq: seq[string]
    result = resultSeq.join(", ")
    result = &"RequestSaveReplay({result})"

proc sizeOfRequestSaveReplay*(message: RequestSaveReplay): uint64 =
    result = result + sizeOfUnknownFields(message)

proc writeRequestSaveReplay*(stream: Stream, message: RequestSaveReplay) =
    writeUnknownFields(stream, message)

proc readRequestSaveReplay*(stream: Stream): RequestSaveReplay =
    result = newRequestSaveReplay()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestSaveReplay): string =
    let
        ss = newStringStream()
    writeRequestSaveReplay(ss, message)
    result = ss.data

proc newRequestSaveReplay*(data: string): RequestSaveReplay =
    let
        ss = newStringStream(data)
    result = readRequestSaveReplay(ss)

proc newRequestSaveReplay*(data: seq[byte]): RequestSaveReplay =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestSaveReplay(ss)


proc fullyQualifiedName*(T: typedesc[RequestAction]): string = "RequestAction"

proc readRequestActionImpl(stream: Stream): Message = readRequestAction(stream)
proc writeRequestActionImpl(stream: Stream, msg: Message) = writeRequestAction(stream, RequestAction(msg))

proc RequestActionProcs*(): MessageProcs =
    result.readImpl = readRequestActionImpl
    result.writeImpl = writeRequestActionImpl

proc newRequestAction*(): RequestAction =
    new(result)
    initMessage(result[])
    result.procs = RequestActionProcs()
    result.actions = @[]

proc clearactions*(message: RequestAction) =
    message.actions = @[]
    clearFields(message, [1])

proc hasactions*(message: RequestAction): bool =
    result = hasField(message, 1) or (len(message.actions) > 0)

proc setactions*(message: RequestAction, value: seq[Action]) =
    message.actions = value
    setField(message, 1)

proc addactions*(message: RequestAction, value: Action) =
    add(message.actions, value)

proc actions*(message: RequestAction): seq[Action] {.inline.} =
    message.actions

proc `actions=`*(message: RequestAction, value: seq[Action]) {.inline.} =
    setactions(message, value)

proc `$`*(message: RequestAction): string =
    runnableExamples:
        echo $RequestAction
        echo fmt"{RequestAction}"
        echo &"{RequestAction}"
    var resultSeq: seq[string]
    if message.hasactions:
        resultSeq.add(&"actions: {message.actions}")
    result = resultSeq.join(", ")
    result = &"RequestAction({result})"

proc sizeOfRequestAction*(message: RequestAction): uint64 =
    for value in message.actions:
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfAction(value))
    result = result + sizeOfUnknownFields(message)

proc writeRequestAction*(stream: Stream, message: RequestAction) =
    for value in message.actions:
        writeMessage(stream, value, 1)
    writeUnknownFields(stream, message)

proc readRequestAction*(stream: Stream): RequestAction =
    result = newRequestAction()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addactions(result, newAction(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestAction): string =
    let
        ss = newStringStream()
    writeRequestAction(ss, message)
    result = ss.data

proc newRequestAction*(data: string): RequestAction =
    let
        ss = newStringStream(data)
    result = readRequestAction(ss)

proc newRequestAction*(data: seq[byte]): RequestAction =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestAction(ss)


proc fullyQualifiedName*(T: typedesc[RequestStartReplay]): string = "RequestStartReplay"

proc readRequestStartReplayImpl(stream: Stream): Message = readRequestStartReplay(stream)
proc writeRequestStartReplayImpl(stream: Stream, msg: Message) = writeRequestStartReplay(stream, RequestStartReplay(msg))

proc RequestStartReplayProcs*(): MessageProcs =
    result.readImpl = readRequestStartReplayImpl
    result.writeImpl = writeRequestStartReplayImpl

proc newRequestStartReplay*(): RequestStartReplay =
    new(result)
    initMessage(result[])
    result.procs = RequestStartReplayProcs()
    result.mapData = @[]
    result.observedPlayerId = 0
    result.options = nil
    result.disableFog = false
    result.realtime = false
    result.recordReplay = false
    result.replay = RequestStartReplay_replay_OneOf(kind: RequestStartReplay_replay_Kind.NotSet)

proc clearreplayPath*(message: RequestStartReplay) =
    reset(message.replay)
    message.replay.kind = RequestStartReplay_replay_Kind.NotSet
    clearFields(message, [1, 5])

proc hasreplayPath*(message: RequestStartReplay): bool =
    result = hasField(message, 1)

proc setreplayPath*(message: RequestStartReplay, value: string) =
    if message.replay.kind != RequestStartReplay_replay_Kind.ReplayPath:
        message.replay = RequestStartReplay_replay_OneOf(kind: RequestStartReplay_replay_Kind.ReplayPath, replayPath: value)
    else:
        message.replay.replayPath = value
    setField(message, 1)
    clearFields(message, [5])

proc replayPath*(message: RequestStartReplay): string {.inline.} =
    message.replay.replayPath

proc `replayPath=`*(message: RequestStartReplay, value: string) {.inline.} =
    setreplayPath(message, value)

proc clearreplayData*(message: RequestStartReplay) =
    reset(message.replay)
    message.replay.kind = RequestStartReplay_replay_Kind.NotSet
    clearFields(message, [5, 1])

proc hasreplayData*(message: RequestStartReplay): bool =
    result = hasField(message, 5)

proc setreplayData*(message: RequestStartReplay, value: seq[byte]) =
    if message.replay.kind != RequestStartReplay_replay_Kind.ReplayData:
        message.replay = RequestStartReplay_replay_OneOf(kind: RequestStartReplay_replay_Kind.ReplayData, replayData: value)
    else:
        message.replay.replayData = value
    setField(message, 5)
    clearFields(message, [1])

proc replayData*(message: RequestStartReplay): seq[byte] {.inline.} =
    message.replay.replayData

proc `replayData=`*(message: RequestStartReplay, value: seq[byte]) {.inline.} =
    setreplayData(message, value)

proc clearmapData*(message: RequestStartReplay) =
    message.mapData = @[]
    clearFields(message, [6])

proc hasmapData*(message: RequestStartReplay): bool =
    result = hasField(message, 6)

proc setmapData*(message: RequestStartReplay, value: seq[byte]) =
    message.mapData = value
    setField(message, 6)

proc mapData*(message: RequestStartReplay): seq[byte] {.inline.} =
    message.mapData

proc `mapData=`*(message: RequestStartReplay, value: seq[byte]) {.inline.} =
    setmapData(message, value)

proc clearobservedPlayerId*(message: RequestStartReplay) =
    message.observedPlayerId = 0
    clearFields(message, [2])

proc hasobservedPlayerId*(message: RequestStartReplay): bool =
    result = hasField(message, 2)

proc setobservedPlayerId*(message: RequestStartReplay, value: int32) =
    message.observedPlayerId = value
    setField(message, 2)

proc observedPlayerId*(message: RequestStartReplay): int32 {.inline.} =
    message.observedPlayerId

proc `observedPlayerId=`*(message: RequestStartReplay, value: int32) {.inline.} =
    setobservedPlayerId(message, value)

proc clearoptions*(message: RequestStartReplay) =
    message.options = nil
    clearFields(message, [3])

proc hasoptions*(message: RequestStartReplay): bool =
    result = hasField(message, 3)

proc setoptions*(message: RequestStartReplay, value: InterfaceOptions) =
    message.options = value
    setField(message, 3)

proc options*(message: RequestStartReplay): InterfaceOptions {.inline.} =
    message.options

proc `options=`*(message: RequestStartReplay, value: InterfaceOptions) {.inline.} =
    setoptions(message, value)

proc cleardisableFog*(message: RequestStartReplay) =
    message.disableFog = false
    clearFields(message, [4])

proc hasdisableFog*(message: RequestStartReplay): bool =
    result = hasField(message, 4)

proc setdisableFog*(message: RequestStartReplay, value: bool) =
    message.disableFog = value
    setField(message, 4)

proc disableFog*(message: RequestStartReplay): bool {.inline.} =
    message.disableFog

proc `disableFog=`*(message: RequestStartReplay, value: bool) {.inline.} =
    setdisableFog(message, value)

proc clearrealtime*(message: RequestStartReplay) =
    message.realtime = false
    clearFields(message, [7])

proc hasrealtime*(message: RequestStartReplay): bool =
    result = hasField(message, 7)

proc setrealtime*(message: RequestStartReplay, value: bool) =
    message.realtime = value
    setField(message, 7)

proc realtime*(message: RequestStartReplay): bool {.inline.} =
    message.realtime

proc `realtime=`*(message: RequestStartReplay, value: bool) {.inline.} =
    setrealtime(message, value)

proc clearrecordReplay*(message: RequestStartReplay) =
    message.recordReplay = false
    clearFields(message, [8])

proc hasrecordReplay*(message: RequestStartReplay): bool =
    result = hasField(message, 8)

proc setrecordReplay*(message: RequestStartReplay, value: bool) =
    message.recordReplay = value
    setField(message, 8)

proc recordReplay*(message: RequestStartReplay): bool {.inline.} =
    message.recordReplay

proc `recordReplay=`*(message: RequestStartReplay, value: bool) {.inline.} =
    setrecordReplay(message, value)

proc `$`*(message: RequestStartReplay): string =
    runnableExamples:
        echo $RequestStartReplay
        echo fmt"{RequestStartReplay}"
        echo &"{RequestStartReplay}"
    var resultSeq: seq[string]
    if message.hasmapData:
        resultSeq.add(&"mapData: {message.mapData}")
    if message.hasobservedPlayerId:
        resultSeq.add(&"observedPlayerId: {message.observedPlayerId}")
    if message.hasoptions:
        resultSeq.add(&"options: {message.options}")
    if message.hasdisableFog:
        resultSeq.add(&"disableFog: {message.disableFog}")
    if message.hasrealtime:
        resultSeq.add(&"realtime: {message.realtime}")
    if message.hasrecordReplay:
        resultSeq.add(&"recordReplay: {message.recordReplay}")
    if message.hasreplayPath:
        resultSeq.add(&"replayPath: {message.replayPath}")
    if message.hasreplayData:
        resultSeq.add(&"replayData: {message.replayData}")
    result = resultSeq.join(", ")
    result = &"RequestStartReplay({result})"

proc sizeOfRequestStartReplay*(message: RequestStartReplay): uint64 =
    if hasreplayPath(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfString(message.replay.replayPath)
    if hasreplayData(message):
        result = result + sizeOfTag(5, WireType.LengthDelimited)
        result = result + sizeOfBytes(message.replay.replayData)
    if hasmapData(message):
        result = result + sizeOfTag(6, WireType.LengthDelimited)
        result = result + sizeOfBytes(message.mapData)
    if hasobservedPlayerId(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfInt32(message.observedPlayerId)
    if hasoptions(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfInterfaceOptions(message.options))
    if hasdisableFog(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfBool(message.disableFog)
    if hasrealtime(message):
        result = result + sizeOfTag(7, WireType.Varint)
        result = result + sizeOfBool(message.realtime)
    if hasrecordReplay(message):
        result = result + sizeOfTag(8, WireType.Varint)
        result = result + sizeOfBool(message.recordReplay)
    result = result + sizeOfUnknownFields(message)

proc writeRequestStartReplay*(stream: Stream, message: RequestStartReplay) =
    if hasreplayPath(message):
        protoWriteString(stream, message.replay.replayPath, 1)
    if hasreplayData(message):
        protoWriteBytes(stream, message.replay.replayData, 5)
    if hasmapData(message):
        protoWriteBytes(stream, message.mapData, 6)
    if hasobservedPlayerId(message):
        protoWriteInt32(stream, message.observedPlayerId, 2)
    if hasoptions(message):
        writeMessage(stream, message.options, 3)
    if hasdisableFog(message):
        protoWriteBool(stream, message.disableFog, 4)
    if hasrealtime(message):
        protoWriteBool(stream, message.realtime, 7)
    if hasrecordReplay(message):
        protoWriteBool(stream, message.recordReplay, 8)
    writeUnknownFields(stream, message)

proc readRequestStartReplay*(stream: Stream): RequestStartReplay =
    result = newRequestStartReplay()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            setreplayPath(result, protoReadString(stream))
        of 5:
            expectWireType(wireType, WireType.LengthDelimited)
            setreplayData(result, protoReadBytes(stream))
        of 6:
            expectWireType(wireType, WireType.LengthDelimited)
            setmapData(result, protoReadBytes(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setobservedPlayerId(result, protoReadInt32(stream))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setoptions(result, newInterfaceOptions(data))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setdisableFog(result, protoReadBool(stream))
        of 7:
            expectWireType(wireType, WireType.Varint)
            setrealtime(result, protoReadBool(stream))
        of 8:
            expectWireType(wireType, WireType.Varint)
            setrecordReplay(result, protoReadBool(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestStartReplay): string =
    let
        ss = newStringStream()
    writeRequestStartReplay(ss, message)
    result = ss.data

proc newRequestStartReplay*(data: string): RequestStartReplay =
    let
        ss = newStringStream(data)
    result = readRequestStartReplay(ss)

proc newRequestStartReplay*(data: seq[byte]): RequestStartReplay =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestStartReplay(ss)


proc fullyQualifiedName*(T: typedesc[RequestData]): string = "RequestData"

proc readRequestDataImpl(stream: Stream): Message = readRequestData(stream)
proc writeRequestDataImpl(stream: Stream, msg: Message) = writeRequestData(stream, RequestData(msg))

proc RequestDataProcs*(): MessageProcs =
    result.readImpl = readRequestDataImpl
    result.writeImpl = writeRequestDataImpl

proc newRequestData*(): RequestData =
    new(result)
    initMessage(result[])
    result.procs = RequestDataProcs()
    result.abilityId = false
    result.unitTypeId = false
    result.upgradeId = false
    result.buffId = false
    result.effectId = false

proc clearabilityId*(message: RequestData) =
    message.abilityId = false
    clearFields(message, [1])

proc hasabilityId*(message: RequestData): bool =
    result = hasField(message, 1)

proc setabilityId*(message: RequestData, value: bool) =
    message.abilityId = value
    setField(message, 1)

proc abilityId*(message: RequestData): bool {.inline.} =
    message.abilityId

proc `abilityId=`*(message: RequestData, value: bool) {.inline.} =
    setabilityId(message, value)

proc clearunitTypeId*(message: RequestData) =
    message.unitTypeId = false
    clearFields(message, [2])

proc hasunitTypeId*(message: RequestData): bool =
    result = hasField(message, 2)

proc setunitTypeId*(message: RequestData, value: bool) =
    message.unitTypeId = value
    setField(message, 2)

proc unitTypeId*(message: RequestData): bool {.inline.} =
    message.unitTypeId

proc `unitTypeId=`*(message: RequestData, value: bool) {.inline.} =
    setunitTypeId(message, value)

proc clearupgradeId*(message: RequestData) =
    message.upgradeId = false
    clearFields(message, [3])

proc hasupgradeId*(message: RequestData): bool =
    result = hasField(message, 3)

proc setupgradeId*(message: RequestData, value: bool) =
    message.upgradeId = value
    setField(message, 3)

proc upgradeId*(message: RequestData): bool {.inline.} =
    message.upgradeId

proc `upgradeId=`*(message: RequestData, value: bool) {.inline.} =
    setupgradeId(message, value)

proc clearbuffId*(message: RequestData) =
    message.buffId = false
    clearFields(message, [4])

proc hasbuffId*(message: RequestData): bool =
    result = hasField(message, 4)

proc setbuffId*(message: RequestData, value: bool) =
    message.buffId = value
    setField(message, 4)

proc buffId*(message: RequestData): bool {.inline.} =
    message.buffId

proc `buffId=`*(message: RequestData, value: bool) {.inline.} =
    setbuffId(message, value)

proc cleareffectId*(message: RequestData) =
    message.effectId = false
    clearFields(message, [5])

proc haseffectId*(message: RequestData): bool =
    result = hasField(message, 5)

proc seteffectId*(message: RequestData, value: bool) =
    message.effectId = value
    setField(message, 5)

proc effectId*(message: RequestData): bool {.inline.} =
    message.effectId

proc `effectId=`*(message: RequestData, value: bool) {.inline.} =
    seteffectId(message, value)

proc `$`*(message: RequestData): string =
    runnableExamples:
        echo $RequestData
        echo fmt"{RequestData}"
        echo &"{RequestData}"
    var resultSeq: seq[string]
    if message.hasabilityId:
        resultSeq.add(&"abilityId: {message.abilityId}")
    if message.hasunitTypeId:
        resultSeq.add(&"unitTypeId: {message.unitTypeId}")
    if message.hasupgradeId:
        resultSeq.add(&"upgradeId: {message.upgradeId}")
    if message.hasbuffId:
        resultSeq.add(&"buffId: {message.buffId}")
    if message.haseffectId:
        resultSeq.add(&"effectId: {message.effectId}")
    result = resultSeq.join(", ")
    result = &"RequestData({result})"

proc sizeOfRequestData*(message: RequestData): uint64 =
    if hasabilityId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfBool(message.abilityId)
    if hasunitTypeId(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfBool(message.unitTypeId)
    if hasupgradeId(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfBool(message.upgradeId)
    if hasbuffId(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfBool(message.buffId)
    if haseffectId(message):
        result = result + sizeOfTag(5, WireType.Varint)
        result = result + sizeOfBool(message.effectId)
    result = result + sizeOfUnknownFields(message)

proc writeRequestData*(stream: Stream, message: RequestData) =
    if hasabilityId(message):
        protoWriteBool(stream, message.abilityId, 1)
    if hasunitTypeId(message):
        protoWriteBool(stream, message.unitTypeId, 2)
    if hasupgradeId(message):
        protoWriteBool(stream, message.upgradeId, 3)
    if hasbuffId(message):
        protoWriteBool(stream, message.buffId, 4)
    if haseffectId(message):
        protoWriteBool(stream, message.effectId, 5)
    writeUnknownFields(stream, message)

proc readRequestData*(stream: Stream): RequestData =
    result = newRequestData()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setabilityId(result, protoReadBool(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setunitTypeId(result, protoReadBool(stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setupgradeId(result, protoReadBool(stream))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setbuffId(result, protoReadBool(stream))
        of 5:
            expectWireType(wireType, WireType.Varint)
            seteffectId(result, protoReadBool(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestData): string =
    let
        ss = newStringStream()
    writeRequestData(ss, message)
    result = ss.data

proc newRequestData*(data: string): RequestData =
    let
        ss = newStringStream(data)
    result = readRequestData(ss)

proc newRequestData*(data: seq[byte]): RequestData =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestData(ss)


proc fullyQualifiedName*(T: typedesc[PortSet]): string = "PortSet"

proc readPortSetImpl(stream: Stream): Message = readPortSet(stream)
proc writePortSetImpl(stream: Stream, msg: Message) = writePortSet(stream, PortSet(msg))

proc PortSetProcs*(): MessageProcs =
    result.readImpl = readPortSetImpl
    result.writeImpl = writePortSetImpl

proc newPortSet*(): PortSet =
    new(result)
    initMessage(result[])
    result.procs = PortSetProcs()
    result.gamePort = 0
    result.basePort = 0

proc cleargamePort*(message: PortSet) =
    message.gamePort = 0
    clearFields(message, [1])

proc hasgamePort*(message: PortSet): bool =
    result = hasField(message, 1)

proc setgamePort*(message: PortSet, value: int32) =
    message.gamePort = value
    setField(message, 1)

proc gamePort*(message: PortSet): int32 {.inline.} =
    message.gamePort

proc `gamePort=`*(message: PortSet, value: int32) {.inline.} =
    setgamePort(message, value)

proc clearbasePort*(message: PortSet) =
    message.basePort = 0
    clearFields(message, [2])

proc hasbasePort*(message: PortSet): bool =
    result = hasField(message, 2)

proc setbasePort*(message: PortSet, value: int32) =
    message.basePort = value
    setField(message, 2)

proc basePort*(message: PortSet): int32 {.inline.} =
    message.basePort

proc `basePort=`*(message: PortSet, value: int32) {.inline.} =
    setbasePort(message, value)

proc `$`*(message: PortSet): string =
    runnableExamples:
        echo $PortSet
        echo fmt"{PortSet}"
        echo &"{PortSet}"
    var resultSeq: seq[string]
    if message.hasgamePort:
        resultSeq.add(&"gamePort: {message.gamePort}")
    if message.hasbasePort:
        resultSeq.add(&"basePort: {message.basePort}")
    result = resultSeq.join(", ")
    result = &"PortSet({result})"

proc sizeOfPortSet*(message: PortSet): uint64 =
    if hasgamePort(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfInt32(message.gamePort)
    if hasbasePort(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfInt32(message.basePort)
    result = result + sizeOfUnknownFields(message)

proc writePortSet*(stream: Stream, message: PortSet) =
    if hasgamePort(message):
        protoWriteInt32(stream, message.gamePort, 1)
    if hasbasePort(message):
        protoWriteInt32(stream, message.basePort, 2)
    writeUnknownFields(stream, message)

proc readPortSet*(stream: Stream): PortSet =
    result = newPortSet()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setgamePort(result, protoReadInt32(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setbasePort(result, protoReadInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: PortSet): string =
    let
        ss = newStringStream()
    writePortSet(ss, message)
    result = ss.data

proc newPortSet*(data: string): PortSet =
    let
        ss = newStringStream(data)
    result = readPortSet(ss)

proc newPortSet*(data: seq[byte]): PortSet =
    let
        ss = newStringStream(cast[string](data))
    result = readPortSet(ss)


proc fullyQualifiedName*(T: typedesc[RequestJoinGame]): string = "RequestJoinGame"

proc readRequestJoinGameImpl(stream: Stream): Message = readRequestJoinGame(stream)
proc writeRequestJoinGameImpl(stream: Stream, msg: Message) = writeRequestJoinGame(stream, RequestJoinGame(msg))

proc RequestJoinGameProcs*(): MessageProcs =
    result.readImpl = readRequestJoinGameImpl
    result.writeImpl = writeRequestJoinGameImpl

proc newRequestJoinGame*(): RequestJoinGame =
    new(result)
    initMessage(result[])
    result.procs = RequestJoinGameProcs()
    result.options = nil
    result.serverPorts = nil
    result.clientPorts = @[]
    result.sharedPort = 0
    result.playerName = ""
    result.hostIp = ""
    result.participation = RequestJoinGame_participation_OneOf(kind: RequestJoinGame_participation_Kind.NotSet)

proc clearrace*(message: RequestJoinGame) =
    reset(message.participation)
    message.participation.kind = RequestJoinGame_participation_Kind.NotSet
    clearFields(message, [1, 2])

proc hasrace*(message: RequestJoinGame): bool =
    result = hasField(message, 1)

proc setrace*(message: RequestJoinGame, value: Race) =
    if message.participation.kind != RequestJoinGame_participation_Kind.Race:
        message.participation = RequestJoinGame_participation_OneOf(kind: RequestJoinGame_participation_Kind.Race, race: value)
    else:
        message.participation.race = value
    setField(message, 1)
    clearFields(message, [2])

proc race*(message: RequestJoinGame): Race {.inline.} =
    message.participation.race

proc `race=`*(message: RequestJoinGame, value: Race) {.inline.} =
    setrace(message, value)

proc clearobservedPlayerId*(message: RequestJoinGame) =
    reset(message.participation)
    message.participation.kind = RequestJoinGame_participation_Kind.NotSet
    clearFields(message, [2, 1])

proc hasobservedPlayerId*(message: RequestJoinGame): bool =
    result = hasField(message, 2)

proc setobservedPlayerId*(message: RequestJoinGame, value: uint32) =
    if message.participation.kind != RequestJoinGame_participation_Kind.ObservedPlayerId:
        message.participation = RequestJoinGame_participation_OneOf(kind: RequestJoinGame_participation_Kind.ObservedPlayerId, observedPlayerId: value)
    else:
        message.participation.observedPlayerId = value
    setField(message, 2)
    clearFields(message, [1])

proc observedPlayerId*(message: RequestJoinGame): uint32 {.inline.} =
    message.participation.observedPlayerId

proc `observedPlayerId=`*(message: RequestJoinGame, value: uint32) {.inline.} =
    setobservedPlayerId(message, value)

proc clearoptions*(message: RequestJoinGame) =
    message.options = nil
    clearFields(message, [3])

proc hasoptions*(message: RequestJoinGame): bool =
    result = hasField(message, 3)

proc setoptions*(message: RequestJoinGame, value: InterfaceOptions) =
    message.options = value
    setField(message, 3)

proc options*(message: RequestJoinGame): InterfaceOptions {.inline.} =
    message.options

proc `options=`*(message: RequestJoinGame, value: InterfaceOptions) {.inline.} =
    setoptions(message, value)

proc clearserverPorts*(message: RequestJoinGame) =
    message.serverPorts = nil
    clearFields(message, [4])

proc hasserverPorts*(message: RequestJoinGame): bool =
    result = hasField(message, 4)

proc setserverPorts*(message: RequestJoinGame, value: PortSet) =
    message.serverPorts = value
    setField(message, 4)

proc serverPorts*(message: RequestJoinGame): PortSet {.inline.} =
    message.serverPorts

proc `serverPorts=`*(message: RequestJoinGame, value: PortSet) {.inline.} =
    setserverPorts(message, value)

proc clearclientPorts*(message: RequestJoinGame) =
    message.clientPorts = @[]
    clearFields(message, [5])

proc hasclientPorts*(message: RequestJoinGame): bool =
    result = hasField(message, 5) or (len(message.clientPorts) > 0)

proc setclientPorts*(message: RequestJoinGame, value: seq[PortSet]) =
    message.clientPorts = value
    setField(message, 5)

proc addclientPorts*(message: RequestJoinGame, value: PortSet) =
    add(message.clientPorts, value)

proc clientPorts*(message: RequestJoinGame): seq[PortSet] {.inline.} =
    message.clientPorts

proc `clientPorts=`*(message: RequestJoinGame, value: seq[PortSet]) {.inline.} =
    setclientPorts(message, value)

proc clearsharedPort*(message: RequestJoinGame) =
    message.sharedPort = 0
    clearFields(message, [6])

proc hassharedPort*(message: RequestJoinGame): bool =
    result = hasField(message, 6)

proc setsharedPort*(message: RequestJoinGame, value: int32) =
    message.sharedPort = value
    setField(message, 6)

proc sharedPort*(message: RequestJoinGame): int32 {.inline.} =
    message.sharedPort

proc `sharedPort=`*(message: RequestJoinGame, value: int32) {.inline.} =
    setsharedPort(message, value)

proc clearplayerName*(message: RequestJoinGame) =
    message.playerName = ""
    clearFields(message, [7])

proc hasplayerName*(message: RequestJoinGame): bool =
    result = hasField(message, 7)

proc setplayerName*(message: RequestJoinGame, value: string) =
    message.playerName = value
    setField(message, 7)

proc playerName*(message: RequestJoinGame): string {.inline.} =
    message.playerName

proc `playerName=`*(message: RequestJoinGame, value: string) {.inline.} =
    setplayerName(message, value)

proc clearhostIp*(message: RequestJoinGame) =
    message.hostIp = ""
    clearFields(message, [8])

proc hashostIp*(message: RequestJoinGame): bool =
    result = hasField(message, 8)

proc sethostIp*(message: RequestJoinGame, value: string) =
    message.hostIp = value
    setField(message, 8)

proc hostIp*(message: RequestJoinGame): string {.inline.} =
    message.hostIp

proc `hostIp=`*(message: RequestJoinGame, value: string) {.inline.} =
    sethostIp(message, value)

proc `$`*(message: RequestJoinGame): string =
    runnableExamples:
        echo $RequestJoinGame
        echo fmt"{RequestJoinGame}"
        echo &"{RequestJoinGame}"
    var resultSeq: seq[string]
    if message.hasoptions:
        resultSeq.add(&"options: {message.options}")
    if message.hasserverPorts:
        resultSeq.add(&"serverPorts: {message.serverPorts}")
    if message.hasclientPorts:
        resultSeq.add(&"clientPorts: {message.clientPorts}")
    if message.hassharedPort:
        resultSeq.add(&"sharedPort: {message.sharedPort}")
    if message.hasplayerName:
        resultSeq.add(&"playerName: {message.playerName}")
    if message.hashostIp:
        resultSeq.add(&"hostIp: {message.hostIp}")
    if message.hasrace:
        resultSeq.add(&"race: {message.race}")
    if message.hasobservedPlayerId:
        resultSeq.add(&"observedPlayerId: {message.observedPlayerId}")
    result = resultSeq.join(", ")
    result = &"RequestJoinGame({result})"

proc sizeOfRequestJoinGame*(message: RequestJoinGame): uint64 =
    if hasrace(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfEnum[Race](message.participation.race)
    if hasobservedPlayerId(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfUInt32(message.participation.observedPlayerId)
    if hasoptions(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfInterfaceOptions(message.options))
    if hasserverPorts(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPortSet(message.serverPorts))
    for value in message.clientPorts:
        result = result + sizeOfTag(5, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPortSet(value))
    if hassharedPort(message):
        result = result + sizeOfTag(6, WireType.Varint)
        result = result + sizeOfInt32(message.sharedPort)
    if hasplayerName(message):
        result = result + sizeOfTag(7, WireType.LengthDelimited)
        result = result + sizeOfString(message.playerName)
    if hashostIp(message):
        result = result + sizeOfTag(8, WireType.LengthDelimited)
        result = result + sizeOfString(message.hostIp)
    result = result + sizeOfUnknownFields(message)

proc writeRequestJoinGame*(stream: Stream, message: RequestJoinGame) =
    if hasrace(message):
        protoWriteEnum(stream, message.participation.race, 1)
    if hasobservedPlayerId(message):
        protoWriteUInt32(stream, message.participation.observedPlayerId, 2)
    if hasoptions(message):
        writeMessage(stream, message.options, 3)
    if hasserverPorts(message):
        writeMessage(stream, message.serverPorts, 4)
    for value in message.clientPorts:
        writeMessage(stream, value, 5)
    if hassharedPort(message):
        protoWriteInt32(stream, message.sharedPort, 6)
    if hasplayerName(message):
        protoWriteString(stream, message.playerName, 7)
    if hashostIp(message):
        protoWriteString(stream, message.hostIp, 8)
    writeUnknownFields(stream, message)

proc readRequestJoinGame*(stream: Stream): RequestJoinGame =
    result = newRequestJoinGame()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setrace(result, protoReadEnum[Race](stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setobservedPlayerId(result, protoReadUInt32(stream))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setoptions(result, newInterfaceOptions(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setserverPorts(result, newPortSet(data))
        of 5:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addclientPorts(result, newPortSet(data))
        of 6:
            expectWireType(wireType, WireType.Varint)
            setsharedPort(result, protoReadInt32(stream))
        of 7:
            expectWireType(wireType, WireType.LengthDelimited)
            setplayerName(result, protoReadString(stream))
        of 8:
            expectWireType(wireType, WireType.LengthDelimited)
            sethostIp(result, protoReadString(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestJoinGame): string =
    let
        ss = newStringStream()
    writeRequestJoinGame(ss, message)
    result = ss.data

proc newRequestJoinGame*(data: string): RequestJoinGame =
    let
        ss = newStringStream(data)
    result = readRequestJoinGame(ss)

proc newRequestJoinGame*(data: seq[byte]): RequestJoinGame =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestJoinGame(ss)


proc fullyQualifiedName*(T: typedesc[RequestObservation]): string = "RequestObservation"

proc readRequestObservationImpl(stream: Stream): Message = readRequestObservation(stream)
proc writeRequestObservationImpl(stream: Stream, msg: Message) = writeRequestObservation(stream, RequestObservation(msg))

proc RequestObservationProcs*(): MessageProcs =
    result.readImpl = readRequestObservationImpl
    result.writeImpl = writeRequestObservationImpl

proc newRequestObservation*(): RequestObservation =
    new(result)
    initMessage(result[])
    result.procs = RequestObservationProcs()
    result.disableFog = false
    result.gameLoop = 0

proc cleardisableFog*(message: RequestObservation) =
    message.disableFog = false
    clearFields(message, [1])

proc hasdisableFog*(message: RequestObservation): bool =
    result = hasField(message, 1)

proc setdisableFog*(message: RequestObservation, value: bool) =
    message.disableFog = value
    setField(message, 1)

proc disableFog*(message: RequestObservation): bool {.inline.} =
    message.disableFog

proc `disableFog=`*(message: RequestObservation, value: bool) {.inline.} =
    setdisableFog(message, value)

proc cleargameLoop*(message: RequestObservation) =
    message.gameLoop = 0
    clearFields(message, [2])

proc hasgameLoop*(message: RequestObservation): bool =
    result = hasField(message, 2)

proc setgameLoop*(message: RequestObservation, value: uint32) =
    message.gameLoop = value
    setField(message, 2)

proc gameLoop*(message: RequestObservation): uint32 {.inline.} =
    message.gameLoop

proc `gameLoop=`*(message: RequestObservation, value: uint32) {.inline.} =
    setgameLoop(message, value)

proc `$`*(message: RequestObservation): string =
    runnableExamples:
        echo $RequestObservation
        echo fmt"{RequestObservation}"
        echo &"{RequestObservation}"
    var resultSeq: seq[string]
    if message.hasdisableFog:
        resultSeq.add(&"disableFog: {message.disableFog}")
    if message.hasgameLoop:
        resultSeq.add(&"gameLoop: {message.gameLoop}")
    result = resultSeq.join(", ")
    result = &"RequestObservation({result})"

proc sizeOfRequestObservation*(message: RequestObservation): uint64 =
    if hasdisableFog(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfBool(message.disableFog)
    if hasgameLoop(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfUInt32(message.gameLoop)
    result = result + sizeOfUnknownFields(message)

proc writeRequestObservation*(stream: Stream, message: RequestObservation) =
    if hasdisableFog(message):
        protoWriteBool(stream, message.disableFog, 1)
    if hasgameLoop(message):
        protoWriteUInt32(stream, message.gameLoop, 2)
    writeUnknownFields(stream, message)

proc readRequestObservation*(stream: Stream): RequestObservation =
    result = newRequestObservation()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setdisableFog(result, protoReadBool(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setgameLoop(result, protoReadUInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RequestObservation): string =
    let
        ss = newStringStream()
    writeRequestObservation(ss, message)
    result = ss.data

proc newRequestObservation*(data: string): RequestObservation =
    let
        ss = newStringStream(data)
    result = readRequestObservation(ss)

proc newRequestObservation*(data: seq[byte]): RequestObservation =
    let
        ss = newStringStream(cast[string](data))
    result = readRequestObservation(ss)


proc fullyQualifiedName*(T: typedesc[Request]): string = "Request"

proc readRequestImpl(stream: Stream): Message = readRequest(stream)
proc writeRequestImpl(stream: Stream, msg: Message) = writeRequest(stream, Request(msg))

proc RequestProcs*(): MessageProcs =
    result.readImpl = readRequestImpl
    result.writeImpl = writeRequestImpl

proc newRequest*(): Request =
    new(result)
    initMessage(result[])
    result.procs = RequestProcs()
    result.id = 0
    result.request = Request_request_OneOf(kind: Request_request_Kind.NotSet)

proc clearcreateGame*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc hascreateGame*(message: Request): bool =
    result = hasField(message, 1)

proc setcreateGame*(message: Request, value: RequestCreateGame) =
    if message.request.kind != Request_request_Kind.CreateGame:
        message.request = Request_request_OneOf(kind: Request_request_Kind.CreateGame, createGame: value)
    else:
        message.request.createGame = value
    setField(message, 1)
    clearFields(message, [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc createGame*(message: Request): RequestCreateGame {.inline.} =
    message.request.createGame

proc `createGame=`*(message: Request, value: RequestCreateGame) {.inline.} =
    setcreateGame(message, value)

proc clearjoinGame*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [2, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc hasjoinGame*(message: Request): bool =
    result = hasField(message, 2)

proc setjoinGame*(message: Request, value: RequestJoinGame) =
    if message.request.kind != Request_request_Kind.JoinGame:
        message.request = Request_request_OneOf(kind: Request_request_Kind.JoinGame, joinGame: value)
    else:
        message.request.joinGame = value
    setField(message, 2)
    clearFields(message, [1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc joinGame*(message: Request): RequestJoinGame {.inline.} =
    message.request.joinGame

proc `joinGame=`*(message: Request, value: RequestJoinGame) {.inline.} =
    setjoinGame(message, value)

proc clearrestartGame*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [3, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc hasrestartGame*(message: Request): bool =
    result = hasField(message, 3)

proc setrestartGame*(message: Request, value: RequestRestartGame) =
    if message.request.kind != Request_request_Kind.RestartGame:
        message.request = Request_request_OneOf(kind: Request_request_Kind.RestartGame, restartGame: value)
    else:
        message.request.restartGame = value
    setField(message, 3)
    clearFields(message, [1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc restartGame*(message: Request): RequestRestartGame {.inline.} =
    message.request.restartGame

proc `restartGame=`*(message: Request, value: RequestRestartGame) {.inline.} =
    setrestartGame(message, value)

proc clearstartReplay*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [4, 1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc hasstartReplay*(message: Request): bool =
    result = hasField(message, 4)

proc setstartReplay*(message: Request, value: RequestStartReplay) =
    if message.request.kind != Request_request_Kind.StartReplay:
        message.request = Request_request_OneOf(kind: Request_request_Kind.StartReplay, startReplay: value)
    else:
        message.request.startReplay = value
    setField(message, 4)
    clearFields(message, [1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc startReplay*(message: Request): RequestStartReplay {.inline.} =
    message.request.startReplay

proc `startReplay=`*(message: Request, value: RequestStartReplay) {.inline.} =
    setstartReplay(message, value)

proc clearleaveGame*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [5, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc hasleaveGame*(message: Request): bool =
    result = hasField(message, 5)

proc setleaveGame*(message: Request, value: RequestLeaveGame) =
    if message.request.kind != Request_request_Kind.LeaveGame:
        message.request = Request_request_OneOf(kind: Request_request_Kind.LeaveGame, leaveGame: value)
    else:
        message.request.leaveGame = value
    setField(message, 5)
    clearFields(message, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc leaveGame*(message: Request): RequestLeaveGame {.inline.} =
    message.request.leaveGame

proc `leaveGame=`*(message: Request, value: RequestLeaveGame) {.inline.} =
    setleaveGame(message, value)

proc clearquickSave*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [6, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc hasquickSave*(message: Request): bool =
    result = hasField(message, 6)

proc setquickSave*(message: Request, value: RequestQuickSave) =
    if message.request.kind != Request_request_Kind.QuickSave:
        message.request = Request_request_OneOf(kind: Request_request_Kind.QuickSave, quickSave: value)
    else:
        message.request.quickSave = value
    setField(message, 6)
    clearFields(message, [1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc quickSave*(message: Request): RequestQuickSave {.inline.} =
    message.request.quickSave

proc `quickSave=`*(message: Request, value: RequestQuickSave) {.inline.} =
    setquickSave(message, value)

proc clearquickLoad*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [7, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc hasquickLoad*(message: Request): bool =
    result = hasField(message, 7)

proc setquickLoad*(message: Request, value: RequestQuickLoad) =
    if message.request.kind != Request_request_Kind.QuickLoad:
        message.request = Request_request_OneOf(kind: Request_request_Kind.QuickLoad, quickLoad: value)
    else:
        message.request.quickLoad = value
    setField(message, 7)
    clearFields(message, [1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc quickLoad*(message: Request): RequestQuickLoad {.inline.} =
    message.request.quickLoad

proc `quickLoad=`*(message: Request, value: RequestQuickLoad) {.inline.} =
    setquickLoad(message, value)

proc clearquit*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [8, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc hasquit*(message: Request): bool =
    result = hasField(message, 8)

proc setquit*(message: Request, value: RequestQuit) =
    if message.request.kind != Request_request_Kind.Quit:
        message.request = Request_request_OneOf(kind: Request_request_Kind.Quit, quit: value)
    else:
        message.request.quit = value
    setField(message, 8)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc quit*(message: Request): RequestQuit {.inline.} =
    message.request.quit

proc `quit=`*(message: Request, value: RequestQuit) {.inline.} =
    setquit(message, value)

proc cleargameInfo*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [9, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc hasgameInfo*(message: Request): bool =
    result = hasField(message, 9)

proc setgameInfo*(message: Request, value: RequestGameInfo) =
    if message.request.kind != Request_request_Kind.GameInfo:
        message.request = Request_request_OneOf(kind: Request_request_Kind.GameInfo, gameInfo: value)
    else:
        message.request.gameInfo = value
    setField(message, 9)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc gameInfo*(message: Request): RequestGameInfo {.inline.} =
    message.request.gameInfo

proc `gameInfo=`*(message: Request, value: RequestGameInfo) {.inline.} =
    setgameInfo(message, value)

proc clearobservation*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc hasobservation*(message: Request): bool =
    result = hasField(message, 10)

proc setobservation*(message: Request, value: RequestObservation) =
    if message.request.kind != Request_request_Kind.Observation:
        message.request = Request_request_OneOf(kind: Request_request_Kind.Observation, observation: value)
    else:
        message.request.observation = value
    setField(message, 10)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc observation*(message: Request): RequestObservation {.inline.} =
    message.request.observation

proc `observation=`*(message: Request, value: RequestObservation) {.inline.} =
    setobservation(message, value)

proc clearaction*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc hasaction*(message: Request): bool =
    result = hasField(message, 11)

proc setaction*(message: Request, value: RequestAction) =
    if message.request.kind != Request_request_Kind.Action:
        message.request = Request_request_OneOf(kind: Request_request_Kind.Action, action: value)
    else:
        message.request.action = value
    setField(message, 11)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc action*(message: Request): RequestAction {.inline.} =
    message.request.action

proc `action=`*(message: Request, value: RequestAction) {.inline.} =
    setaction(message, value)

proc clearobsAction*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [21, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc hasobsAction*(message: Request): bool =
    result = hasField(message, 21)

proc setobsAction*(message: Request, value: RequestObserverAction) =
    if message.request.kind != Request_request_Kind.ObsAction:
        message.request = Request_request_OneOf(kind: Request_request_Kind.ObsAction, obsAction: value)
    else:
        message.request.obsAction = value
    setField(message, 21)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc obsAction*(message: Request): RequestObserverAction {.inline.} =
    message.request.obsAction

proc `obsAction=`*(message: Request, value: RequestObserverAction) {.inline.} =
    setobsAction(message, value)

proc clearstep*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc hasstep*(message: Request): bool =
    result = hasField(message, 12)

proc setstep*(message: Request, value: RequestStep) =
    if message.request.kind != Request_request_Kind.Step:
        message.request = Request_request_OneOf(kind: Request_request_Kind.Step, step: value)
    else:
        message.request.step = value
    setField(message, 12)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 13, 14, 15, 22, 16, 17, 18, 19, 20])

proc step*(message: Request): RequestStep {.inline.} =
    message.request.step

proc `step=`*(message: Request, value: RequestStep) {.inline.} =
    setstep(message, value)

proc cleardata*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [13, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 14, 15, 22, 16, 17, 18, 19, 20])

proc hasdata*(message: Request): bool =
    result = hasField(message, 13)

proc setdata*(message: Request, value: RequestData) =
    if message.request.kind != Request_request_Kind.Data:
        message.request = Request_request_OneOf(kind: Request_request_Kind.Data, data: value)
    else:
        message.request.data = value
    setField(message, 13)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 14, 15, 22, 16, 17, 18, 19, 20])

proc data*(message: Request): RequestData {.inline.} =
    message.request.data

proc `data=`*(message: Request, value: RequestData) {.inline.} =
    setdata(message, value)

proc clearquery*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [14, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 15, 22, 16, 17, 18, 19, 20])

proc hasquery*(message: Request): bool =
    result = hasField(message, 14)

proc setquery*(message: Request, value: RequestQuery) =
    if message.request.kind != Request_request_Kind.Query:
        message.request = Request_request_OneOf(kind: Request_request_Kind.Query, query: value)
    else:
        message.request.query = value
    setField(message, 14)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 15, 22, 16, 17, 18, 19, 20])

proc query*(message: Request): RequestQuery {.inline.} =
    message.request.query

proc `query=`*(message: Request, value: RequestQuery) {.inline.} =
    setquery(message, value)

proc clearsaveReplay*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 22, 16, 17, 18, 19, 20])

proc hassaveReplay*(message: Request): bool =
    result = hasField(message, 15)

proc setsaveReplay*(message: Request, value: RequestSaveReplay) =
    if message.request.kind != Request_request_Kind.SaveReplay:
        message.request = Request_request_OneOf(kind: Request_request_Kind.SaveReplay, saveReplay: value)
    else:
        message.request.saveReplay = value
    setField(message, 15)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 22, 16, 17, 18, 19, 20])

proc saveReplay*(message: Request): RequestSaveReplay {.inline.} =
    message.request.saveReplay

proc `saveReplay=`*(message: Request, value: RequestSaveReplay) {.inline.} =
    setsaveReplay(message, value)

proc clearmapCommand*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [22, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 19, 20])

proc hasmapCommand*(message: Request): bool =
    result = hasField(message, 22)

proc setmapCommand*(message: Request, value: RequestMapCommand) =
    if message.request.kind != Request_request_Kind.MapCommand:
        message.request = Request_request_OneOf(kind: Request_request_Kind.MapCommand, mapCommand: value)
    else:
        message.request.mapCommand = value
    setField(message, 22)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 19, 20])

proc mapCommand*(message: Request): RequestMapCommand {.inline.} =
    message.request.mapCommand

proc `mapCommand=`*(message: Request, value: RequestMapCommand) {.inline.} =
    setmapCommand(message, value)

proc clearreplayInfo*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [16, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 17, 18, 19, 20])

proc hasreplayInfo*(message: Request): bool =
    result = hasField(message, 16)

proc setreplayInfo*(message: Request, value: RequestReplayInfo) =
    if message.request.kind != Request_request_Kind.ReplayInfo:
        message.request = Request_request_OneOf(kind: Request_request_Kind.ReplayInfo, replayInfo: value)
    else:
        message.request.replayInfo = value
    setField(message, 16)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 17, 18, 19, 20])

proc replayInfo*(message: Request): RequestReplayInfo {.inline.} =
    message.request.replayInfo

proc `replayInfo=`*(message: Request, value: RequestReplayInfo) {.inline.} =
    setreplayInfo(message, value)

proc clearavailableMaps*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [17, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 18, 19, 20])

proc hasavailableMaps*(message: Request): bool =
    result = hasField(message, 17)

proc setavailableMaps*(message: Request, value: RequestAvailableMaps) =
    if message.request.kind != Request_request_Kind.AvailableMaps:
        message.request = Request_request_OneOf(kind: Request_request_Kind.AvailableMaps, availableMaps: value)
    else:
        message.request.availableMaps = value
    setField(message, 17)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 18, 19, 20])

proc availableMaps*(message: Request): RequestAvailableMaps {.inline.} =
    message.request.availableMaps

proc `availableMaps=`*(message: Request, value: RequestAvailableMaps) {.inline.} =
    setavailableMaps(message, value)

proc clearsaveMap*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [18, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 19, 20])

proc hassaveMap*(message: Request): bool =
    result = hasField(message, 18)

proc setsaveMap*(message: Request, value: RequestSaveMap) =
    if message.request.kind != Request_request_Kind.SaveMap:
        message.request = Request_request_OneOf(kind: Request_request_Kind.SaveMap, saveMap: value)
    else:
        message.request.saveMap = value
    setField(message, 18)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 19, 20])

proc saveMap*(message: Request): RequestSaveMap {.inline.} =
    message.request.saveMap

proc `saveMap=`*(message: Request, value: RequestSaveMap) {.inline.} =
    setsaveMap(message, value)

proc clearping*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [19, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 20])

proc hasping*(message: Request): bool =
    result = hasField(message, 19)

proc setping*(message: Request, value: RequestPing) =
    if message.request.kind != Request_request_Kind.Ping:
        message.request = Request_request_OneOf(kind: Request_request_Kind.Ping, ping: value)
    else:
        message.request.ping = value
    setField(message, 19)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 20])

proc ping*(message: Request): RequestPing {.inline.} =
    message.request.ping

proc `ping=`*(message: Request, value: RequestPing) {.inline.} =
    setping(message, value)

proc cleardebug*(message: Request) =
    reset(message.request)
    message.request.kind = Request_request_Kind.NotSet
    clearFields(message, [20, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19])

proc hasdebug*(message: Request): bool =
    result = hasField(message, 20)

proc setdebug*(message: Request, value: RequestDebug) =
    if message.request.kind != Request_request_Kind.Debug:
        message.request = Request_request_OneOf(kind: Request_request_Kind.Debug, debug: value)
    else:
        message.request.debug = value
    setField(message, 20)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21, 12, 13, 14, 15, 22, 16, 17, 18, 19])

proc debug*(message: Request): RequestDebug {.inline.} =
    message.request.debug

proc `debug=`*(message: Request, value: RequestDebug) {.inline.} =
    setdebug(message, value)

proc clearid*(message: Request) =
    message.id = 0
    clearFields(message, [97])

proc hasid*(message: Request): bool =
    result = hasField(message, 97)

proc setid*(message: Request, value: uint32) =
    message.id = value
    setField(message, 97)

proc id*(message: Request): uint32 {.inline.} =
    message.id

proc `id=`*(message: Request, value: uint32) {.inline.} =
    setid(message, value)

proc `$`*(message: Request): string =
    runnableExamples:
        echo $Request
        echo fmt"{Request}"
        echo &"{Request}"
    var resultSeq: seq[string]
    if message.hasid:
        resultSeq.add(&"id: {message.id}")
    if message.hascreateGame:
        resultSeq.add(&"createGame: {message.createGame}")
    if message.hasjoinGame:
        resultSeq.add(&"joinGame: {message.joinGame}")
    if message.hasrestartGame:
        resultSeq.add(&"restartGame: {message.restartGame}")
    if message.hasstartReplay:
        resultSeq.add(&"startReplay: {message.startReplay}")
    if message.hasleaveGame:
        resultSeq.add(&"leaveGame: {message.leaveGame}")
    if message.hasquickSave:
        resultSeq.add(&"quickSave: {message.quickSave}")
    if message.hasquickLoad:
        resultSeq.add(&"quickLoad: {message.quickLoad}")
    if message.hasquit:
        resultSeq.add(&"quit: {message.quit}")
    if message.hasgameInfo:
        resultSeq.add(&"gameInfo: {message.gameInfo}")
    if message.hasobservation:
        resultSeq.add(&"observation: {message.observation}")
    if message.hasaction:
        resultSeq.add(&"action: {message.action}")
    if message.hasobsAction:
        resultSeq.add(&"obsAction: {message.obsAction}")
    if message.hasstep:
        resultSeq.add(&"step: {message.step}")
    if message.hasdata:
        resultSeq.add(&"data: {message.data}")
    if message.hasquery:
        resultSeq.add(&"query: {message.query}")
    if message.hassaveReplay:
        resultSeq.add(&"saveReplay: {message.saveReplay}")
    if message.hasmapCommand:
        resultSeq.add(&"mapCommand: {message.mapCommand}")
    if message.hasreplayInfo:
        resultSeq.add(&"replayInfo: {message.replayInfo}")
    if message.hasavailableMaps:
        resultSeq.add(&"availableMaps: {message.availableMaps}")
    if message.hassaveMap:
        resultSeq.add(&"saveMap: {message.saveMap}")
    if message.hasping:
        resultSeq.add(&"ping: {message.ping}")
    if message.hasdebug:
        resultSeq.add(&"debug: {message.debug}")
    result = resultSeq.join(", ")
    result = &"Request({result})"

proc sizeOfRequest*(message: Request): uint64 =
    if hascreateGame(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestCreateGame(message.request.createGame))
    if hasjoinGame(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestJoinGame(message.request.joinGame))
    if hasrestartGame(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestRestartGame(message.request.restartGame))
    if hasstartReplay(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestStartReplay(message.request.startReplay))
    if hasleaveGame(message):
        result = result + sizeOfTag(5, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestLeaveGame(message.request.leaveGame))
    if hasquickSave(message):
        result = result + sizeOfTag(6, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestQuickSave(message.request.quickSave))
    if hasquickLoad(message):
        result = result + sizeOfTag(7, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestQuickLoad(message.request.quickLoad))
    if hasquit(message):
        result = result + sizeOfTag(8, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestQuit(message.request.quit))
    if hasgameInfo(message):
        result = result + sizeOfTag(9, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestGameInfo(message.request.gameInfo))
    if hasobservation(message):
        result = result + sizeOfTag(10, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestObservation(message.request.observation))
    if hasaction(message):
        result = result + sizeOfTag(11, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestAction(message.request.action))
    if hasobsAction(message):
        result = result + sizeOfTag(21, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestObserverAction(message.request.obsAction))
    if hasstep(message):
        result = result + sizeOfTag(12, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestStep(message.request.step))
    if hasdata(message):
        result = result + sizeOfTag(13, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestData(message.request.data))
    if hasquery(message):
        result = result + sizeOfTag(14, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestQuery(message.request.query))
    if hassaveReplay(message):
        result = result + sizeOfTag(15, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestSaveReplay(message.request.saveReplay))
    if hasmapCommand(message):
        result = result + sizeOfTag(22, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestMapCommand(message.request.mapCommand))
    if hasreplayInfo(message):
        result = result + sizeOfTag(16, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestReplayInfo(message.request.replayInfo))
    if hasavailableMaps(message):
        result = result + sizeOfTag(17, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestAvailableMaps(message.request.availableMaps))
    if hassaveMap(message):
        result = result + sizeOfTag(18, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestSaveMap(message.request.saveMap))
    if hasping(message):
        result = result + sizeOfTag(19, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestPing(message.request.ping))
    if hasdebug(message):
        result = result + sizeOfTag(20, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRequestDebug(message.request.debug))
    if hasid(message):
        result = result + sizeOfTag(97, WireType.Varint)
        result = result + sizeOfUInt32(message.id)
    result = result + sizeOfUnknownFields(message)

proc writeRequest*(stream: Stream, message: Request) =
    if hascreateGame(message):
        writeMessage(stream, message.request.createGame, 1)
    if hasjoinGame(message):
        writeMessage(stream, message.request.joinGame, 2)
    if hasrestartGame(message):
        writeMessage(stream, message.request.restartGame, 3)
    if hasstartReplay(message):
        writeMessage(stream, message.request.startReplay, 4)
    if hasleaveGame(message):
        writeMessage(stream, message.request.leaveGame, 5)
    if hasquickSave(message):
        writeMessage(stream, message.request.quickSave, 6)
    if hasquickLoad(message):
        writeMessage(stream, message.request.quickLoad, 7)
    if hasquit(message):
        writeMessage(stream, message.request.quit, 8)
    if hasgameInfo(message):
        writeMessage(stream, message.request.gameInfo, 9)
    if hasobservation(message):
        writeMessage(stream, message.request.observation, 10)
    if hasaction(message):
        writeMessage(stream, message.request.action, 11)
    if hasobsAction(message):
        writeMessage(stream, message.request.obsAction, 21)
    if hasstep(message):
        writeMessage(stream, message.request.step, 12)
    if hasdata(message):
        writeMessage(stream, message.request.data, 13)
    if hasquery(message):
        writeMessage(stream, message.request.query, 14)
    if hassaveReplay(message):
        writeMessage(stream, message.request.saveReplay, 15)
    if hasmapCommand(message):
        writeMessage(stream, message.request.mapCommand, 22)
    if hasreplayInfo(message):
        writeMessage(stream, message.request.replayInfo, 16)
    if hasavailableMaps(message):
        writeMessage(stream, message.request.availableMaps, 17)
    if hassaveMap(message):
        writeMessage(stream, message.request.saveMap, 18)
    if hasping(message):
        writeMessage(stream, message.request.ping, 19)
    if hasdebug(message):
        writeMessage(stream, message.request.debug, 20)
    if hasid(message):
        protoWriteUInt32(stream, message.id, 97)
    writeUnknownFields(stream, message)

proc readRequest*(stream: Stream): Request =
    result = newRequest()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcreateGame(result, newRequestCreateGame(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setjoinGame(result, newRequestJoinGame(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setrestartGame(result, newRequestRestartGame(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setstartReplay(result, newRequestStartReplay(data))
        of 5:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setleaveGame(result, newRequestLeaveGame(data))
        of 6:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setquickSave(result, newRequestQuickSave(data))
        of 7:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setquickLoad(result, newRequestQuickLoad(data))
        of 8:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setquit(result, newRequestQuit(data))
        of 9:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setgameInfo(result, newRequestGameInfo(data))
        of 10:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setobservation(result, newRequestObservation(data))
        of 11:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setaction(result, newRequestAction(data))
        of 21:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setobsAction(result, newRequestObserverAction(data))
        of 12:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setstep(result, newRequestStep(data))
        of 13:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setdata(result, newRequestData(data))
        of 14:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setquery(result, newRequestQuery(data))
        of 15:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setsaveReplay(result, newRequestSaveReplay(data))
        of 22:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setmapCommand(result, newRequestMapCommand(data))
        of 16:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setreplayInfo(result, newRequestReplayInfo(data))
        of 17:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setavailableMaps(result, newRequestAvailableMaps(data))
        of 18:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setsaveMap(result, newRequestSaveMap(data))
        of 19:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setping(result, newRequestPing(data))
        of 20:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setdebug(result, newRequestDebug(data))
        of 97:
            expectWireType(wireType, WireType.Varint)
            setid(result, protoReadUInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: Request): string =
    let
        ss = newStringStream()
    writeRequest(ss, message)
    result = ss.data

proc newRequest*(data: string): Request =
    let
        ss = newStringStream(data)
    result = readRequest(ss)

proc newRequest*(data: seq[byte]): Request =
    let
        ss = newStringStream(cast[string](data))
    result = readRequest(ss)


