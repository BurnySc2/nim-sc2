# Generated by protoc_gen_nim. Do not edit!

import base64
import intsets
import json
import strutils
import strformat

import nimpb/nimpb
import nimpb/json as nimpb_json

import common_pb

type
    Attribute* {.pure.} = enum
        Light = 1
        Armored = 2
        Biological = 3
        Mechanical = 4
        Robotic = 5
        Psionic = 6
        Massive = 7
        Structure = 8
        Hover = 9
        Heroic = 10
        Summoned = 11
    AbilityData_Target* {.pure.} = enum
        None = 1
        Point = 2
        Unit = 3
        PointOrUnit = 4
        PointOrNone = 5
    Weapon_TargetType* {.pure.} = enum
        Ground = 1
        Air = 2
        Any = 3
    AbilityData* = ref AbilityDataObj
    AbilityDataObj* = object of Message
        abilityId: uint32
        linkName: string
        linkIndex: uint32
        buttonName: string
        friendlyName: string
        hotkey: string
        remapsToAbilityId: uint32
        available: bool
        target: AbilityData_Target
        allowMinimap: bool
        allowAutocast: bool
        isBuilding: bool
        footprintRadius: float32
        isInstantPlacement: bool
        castRange: float32
    DamageBonus* = ref DamageBonusObj
    DamageBonusObj* = object of Message
        attribute: Attribute
        bonus: float32
    Weapon* = ref WeaponObj
    WeaponObj* = object of Message
        ftype: Weapon_TargetType
        damage: float32
        damageBonus: seq[DamageBonus]
        attacks: uint32
        range: float32
        speed: float32
    UnitTypeData* = ref UnitTypeDataObj
    UnitTypeDataObj* = object of Message
        unitId: uint32
        name: string
        available: bool
        cargoSize: uint32
        mineralCost: uint32
        vespeneCost: uint32
        foodRequired: float32
        foodProvided: float32
        abilityId: uint32
        race: Race
        buildTime: float32
        hasVespene: bool
        hasMinerals: bool
        sightRange: float32
        techAlias: seq[uint32]
        unitAlias: uint32
        techRequirement: uint32
        requireAttached: bool
        attributes: seq[Attribute]
        movementSpeed: float32
        armor: float32
        weapons: seq[Weapon]
    UpgradeData* = ref UpgradeDataObj
    UpgradeDataObj* = object of Message
        upgradeId: uint32
        name: string
        mineralCost: uint32
        vespeneCost: uint32
        researchTime: float32
        abilityId: uint32
    BuffData* = ref BuffDataObj
    BuffDataObj* = object of Message
        buffId: uint32
        name: string
    EffectData* = ref EffectDataObj
    EffectDataObj* = object of Message
        effectId: uint32
        name: string
        friendlyName: string
        radius: float32

proc newDamageBonus*(): DamageBonus
proc newDamageBonus*(data: string): DamageBonus
proc newDamageBonus*(data: seq[byte]): DamageBonus
proc writeDamageBonus*(stream: Stream, message: DamageBonus)
proc readDamageBonus*(stream: Stream): DamageBonus
proc sizeOfDamageBonus*(message: DamageBonus): uint64

proc newAbilityData*(): AbilityData
proc newAbilityData*(data: string): AbilityData
proc newAbilityData*(data: seq[byte]): AbilityData
proc writeAbilityData*(stream: Stream, message: AbilityData)
proc readAbilityData*(stream: Stream): AbilityData
proc sizeOfAbilityData*(message: AbilityData): uint64

proc newUpgradeData*(): UpgradeData
proc newUpgradeData*(data: string): UpgradeData
proc newUpgradeData*(data: seq[byte]): UpgradeData
proc writeUpgradeData*(stream: Stream, message: UpgradeData)
proc readUpgradeData*(stream: Stream): UpgradeData
proc sizeOfUpgradeData*(message: UpgradeData): uint64

proc newWeapon*(): Weapon
proc newWeapon*(data: string): Weapon
proc newWeapon*(data: seq[byte]): Weapon
proc writeWeapon*(stream: Stream, message: Weapon)
proc readWeapon*(stream: Stream): Weapon
proc sizeOfWeapon*(message: Weapon): uint64

proc newUnitTypeData*(): UnitTypeData
proc newUnitTypeData*(data: string): UnitTypeData
proc newUnitTypeData*(data: seq[byte]): UnitTypeData
proc writeUnitTypeData*(stream: Stream, message: UnitTypeData)
proc readUnitTypeData*(stream: Stream): UnitTypeData
proc sizeOfUnitTypeData*(message: UnitTypeData): uint64

proc newEffectData*(): EffectData
proc newEffectData*(data: string): EffectData
proc newEffectData*(data: seq[byte]): EffectData
proc writeEffectData*(stream: Stream, message: EffectData)
proc readEffectData*(stream: Stream): EffectData
proc sizeOfEffectData*(message: EffectData): uint64

proc newBuffData*(): BuffData
proc newBuffData*(data: string): BuffData
proc newBuffData*(data: seq[byte]): BuffData
proc writeBuffData*(stream: Stream, message: BuffData)
proc readBuffData*(stream: Stream): BuffData
proc sizeOfBuffData*(message: BuffData): uint64

proc fullyQualifiedName*(T: typedesc[DamageBonus]): string = "DamageBonus"

proc readDamageBonusImpl(stream: Stream): Message = readDamageBonus(stream)
proc writeDamageBonusImpl(stream: Stream, msg: Message) = writeDamageBonus(stream, DamageBonus(msg))

proc DamageBonusProcs*(): MessageProcs =
    result.readImpl = readDamageBonusImpl
    result.writeImpl = writeDamageBonusImpl

proc newDamageBonus*(): DamageBonus =
    new(result)
    initMessage(result[])
    result.procs = DamageBonusProcs()
    result.attribute = Attribute.Light
    result.bonus = 0

proc clearattribute*(message: DamageBonus) =
    message.attribute = Attribute.Light
    clearFields(message, [1])

proc hasattribute*(message: DamageBonus): bool =
    result = hasField(message, 1)

proc setattribute*(message: DamageBonus, value: Attribute) =
    message.attribute = value
    setField(message, 1)

proc attribute*(message: DamageBonus): Attribute {.inline.} =
    message.attribute

proc `attribute=`*(message: DamageBonus, value: Attribute) {.inline.} =
    setattribute(message, value)

proc clearbonus*(message: DamageBonus) =
    message.bonus = 0
    clearFields(message, [2])

proc hasbonus*(message: DamageBonus): bool =
    result = hasField(message, 2)

proc setbonus*(message: DamageBonus, value: float32) =
    message.bonus = value
    setField(message, 2)

proc bonus*(message: DamageBonus): float32 {.inline.} =
    message.bonus

proc `bonus=`*(message: DamageBonus, value: float32) {.inline.} =
    setbonus(message, value)

proc `$`*(message: DamageBonus): string =
    runnableExamples:
        echo $DamageBonus
        echo fmt"{DamageBonus}"
        echo &"{DamageBonus}"
    var resultSeq: seq[string]
    if message.hasattribute:
        resultSeq.add(&"attribute: {message.attribute}")
    if message.hasbonus:
        resultSeq.add(&"bonus: {message.bonus}")
    result = resultSeq.join(", ")
    result = &"DamageBonus({result})"

proc sizeOfDamageBonus*(message: DamageBonus): uint64 =
    if hasattribute(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfEnum[Attribute](message.attribute)
    if hasbonus(message):
        result = result + sizeOfTag(2, WireType.Fixed32)
        result = result + sizeOfFloat(message.bonus)
    result = result + sizeOfUnknownFields(message)

proc writeDamageBonus*(stream: Stream, message: DamageBonus) =
    if hasattribute(message):
        protoWriteEnum(stream, message.attribute, 1)
    if hasbonus(message):
        protoWriteFloat(stream, message.bonus, 2)
    writeUnknownFields(stream, message)

proc readDamageBonus*(stream: Stream): DamageBonus =
    result = newDamageBonus()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setattribute(result, protoReadEnum[Attribute](stream))
        of 2:
            expectWireType(wireType, WireType.Fixed32)
            setbonus(result, protoReadFloat(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: DamageBonus): string =
    let
        ss = newStringStream()
    writeDamageBonus(ss, message)
    result = ss.data

proc newDamageBonus*(data: string): DamageBonus =
    let
        ss = newStringStream(data)
    result = readDamageBonus(ss)

proc newDamageBonus*(data: seq[byte]): DamageBonus =
    let
        ss = newStringStream(cast[string](data))
    result = readDamageBonus(ss)


proc fullyQualifiedName*(T: typedesc[AbilityData]): string = "AbilityData"

proc readAbilityDataImpl(stream: Stream): Message = readAbilityData(stream)
proc writeAbilityDataImpl(stream: Stream, msg: Message) = writeAbilityData(stream, AbilityData(msg))

proc AbilityDataProcs*(): MessageProcs =
    result.readImpl = readAbilityDataImpl
    result.writeImpl = writeAbilityDataImpl

proc newAbilityData*(): AbilityData =
    new(result)
    initMessage(result[])
    result.procs = AbilityDataProcs()
    result.abilityId = 0
    result.linkName = ""
    result.linkIndex = 0
    result.buttonName = ""
    result.friendlyName = ""
    result.hotkey = ""
    result.remapsToAbilityId = 0
    result.available = false
    result.target = AbilityData_Target.None
    result.allowMinimap = false
    result.allowAutocast = false
    result.isBuilding = false
    result.footprintRadius = 0
    result.isInstantPlacement = false
    result.castRange = 0

proc clearabilityId*(message: AbilityData) =
    message.abilityId = 0
    clearFields(message, [1])

proc hasabilityId*(message: AbilityData): bool =
    result = hasField(message, 1)

proc setabilityId*(message: AbilityData, value: uint32) =
    message.abilityId = value
    setField(message, 1)

proc abilityId*(message: AbilityData): uint32 {.inline.} =
    message.abilityId

proc `abilityId=`*(message: AbilityData, value: uint32) {.inline.} =
    setabilityId(message, value)

proc clearlinkName*(message: AbilityData) =
    message.linkName = ""
    clearFields(message, [2])

proc haslinkName*(message: AbilityData): bool =
    result = hasField(message, 2)

proc setlinkName*(message: AbilityData, value: string) =
    message.linkName = value
    setField(message, 2)

proc linkName*(message: AbilityData): string {.inline.} =
    message.linkName

proc `linkName=`*(message: AbilityData, value: string) {.inline.} =
    setlinkName(message, value)

proc clearlinkIndex*(message: AbilityData) =
    message.linkIndex = 0
    clearFields(message, [3])

proc haslinkIndex*(message: AbilityData): bool =
    result = hasField(message, 3)

proc setlinkIndex*(message: AbilityData, value: uint32) =
    message.linkIndex = value
    setField(message, 3)

proc linkIndex*(message: AbilityData): uint32 {.inline.} =
    message.linkIndex

proc `linkIndex=`*(message: AbilityData, value: uint32) {.inline.} =
    setlinkIndex(message, value)

proc clearbuttonName*(message: AbilityData) =
    message.buttonName = ""
    clearFields(message, [4])

proc hasbuttonName*(message: AbilityData): bool =
    result = hasField(message, 4)

proc setbuttonName*(message: AbilityData, value: string) =
    message.buttonName = value
    setField(message, 4)

proc buttonName*(message: AbilityData): string {.inline.} =
    message.buttonName

proc `buttonName=`*(message: AbilityData, value: string) {.inline.} =
    setbuttonName(message, value)

proc clearfriendlyName*(message: AbilityData) =
    message.friendlyName = ""
    clearFields(message, [5])

proc hasfriendlyName*(message: AbilityData): bool =
    result = hasField(message, 5)

proc setfriendlyName*(message: AbilityData, value: string) =
    message.friendlyName = value
    setField(message, 5)

proc friendlyName*(message: AbilityData): string {.inline.} =
    message.friendlyName

proc `friendlyName=`*(message: AbilityData, value: string) {.inline.} =
    setfriendlyName(message, value)

proc clearhotkey*(message: AbilityData) =
    message.hotkey = ""
    clearFields(message, [6])

proc hashotkey*(message: AbilityData): bool =
    result = hasField(message, 6)

proc sethotkey*(message: AbilityData, value: string) =
    message.hotkey = value
    setField(message, 6)

proc hotkey*(message: AbilityData): string {.inline.} =
    message.hotkey

proc `hotkey=`*(message: AbilityData, value: string) {.inline.} =
    sethotkey(message, value)

proc clearremapsToAbilityId*(message: AbilityData) =
    message.remapsToAbilityId = 0
    clearFields(message, [7])

proc hasremapsToAbilityId*(message: AbilityData): bool =
    result = hasField(message, 7)

proc setremapsToAbilityId*(message: AbilityData, value: uint32) =
    message.remapsToAbilityId = value
    setField(message, 7)

proc remapsToAbilityId*(message: AbilityData): uint32 {.inline.} =
    message.remapsToAbilityId

proc `remapsToAbilityId=`*(message: AbilityData, value: uint32) {.inline.} =
    setremapsToAbilityId(message, value)

proc clearavailable*(message: AbilityData) =
    message.available = false
    clearFields(message, [8])

proc hasavailable*(message: AbilityData): bool =
    result = hasField(message, 8)

proc setavailable*(message: AbilityData, value: bool) =
    message.available = value
    setField(message, 8)

proc available*(message: AbilityData): bool {.inline.} =
    message.available

proc `available=`*(message: AbilityData, value: bool) {.inline.} =
    setavailable(message, value)

proc cleartarget*(message: AbilityData) =
    message.target = AbilityData_Target.None
    clearFields(message, [9])

proc hastarget*(message: AbilityData): bool =
    result = hasField(message, 9)

proc settarget*(message: AbilityData, value: AbilityData_Target) =
    message.target = value
    setField(message, 9)

proc target*(message: AbilityData): AbilityData_Target {.inline.} =
    message.target

proc `target=`*(message: AbilityData, value: AbilityData_Target) {.inline.} =
    settarget(message, value)

proc clearallowMinimap*(message: AbilityData) =
    message.allowMinimap = false
    clearFields(message, [10])

proc hasallowMinimap*(message: AbilityData): bool =
    result = hasField(message, 10)

proc setallowMinimap*(message: AbilityData, value: bool) =
    message.allowMinimap = value
    setField(message, 10)

proc allowMinimap*(message: AbilityData): bool {.inline.} =
    message.allowMinimap

proc `allowMinimap=`*(message: AbilityData, value: bool) {.inline.} =
    setallowMinimap(message, value)

proc clearallowAutocast*(message: AbilityData) =
    message.allowAutocast = false
    clearFields(message, [11])

proc hasallowAutocast*(message: AbilityData): bool =
    result = hasField(message, 11)

proc setallowAutocast*(message: AbilityData, value: bool) =
    message.allowAutocast = value
    setField(message, 11)

proc allowAutocast*(message: AbilityData): bool {.inline.} =
    message.allowAutocast

proc `allowAutocast=`*(message: AbilityData, value: bool) {.inline.} =
    setallowAutocast(message, value)

proc clearisBuilding*(message: AbilityData) =
    message.isBuilding = false
    clearFields(message, [12])

proc hasisBuilding*(message: AbilityData): bool =
    result = hasField(message, 12)

proc setisBuilding*(message: AbilityData, value: bool) =
    message.isBuilding = value
    setField(message, 12)

proc isBuilding*(message: AbilityData): bool {.inline.} =
    message.isBuilding

proc `isBuilding=`*(message: AbilityData, value: bool) {.inline.} =
    setisBuilding(message, value)

proc clearfootprintRadius*(message: AbilityData) =
    message.footprintRadius = 0
    clearFields(message, [13])

proc hasfootprintRadius*(message: AbilityData): bool =
    result = hasField(message, 13)

proc setfootprintRadius*(message: AbilityData, value: float32) =
    message.footprintRadius = value
    setField(message, 13)

proc footprintRadius*(message: AbilityData): float32 {.inline.} =
    message.footprintRadius

proc `footprintRadius=`*(message: AbilityData, value: float32) {.inline.} =
    setfootprintRadius(message, value)

proc clearisInstantPlacement*(message: AbilityData) =
    message.isInstantPlacement = false
    clearFields(message, [14])

proc hasisInstantPlacement*(message: AbilityData): bool =
    result = hasField(message, 14)

proc setisInstantPlacement*(message: AbilityData, value: bool) =
    message.isInstantPlacement = value
    setField(message, 14)

proc isInstantPlacement*(message: AbilityData): bool {.inline.} =
    message.isInstantPlacement

proc `isInstantPlacement=`*(message: AbilityData, value: bool) {.inline.} =
    setisInstantPlacement(message, value)

proc clearcastRange*(message: AbilityData) =
    message.castRange = 0
    clearFields(message, [15])

proc hascastRange*(message: AbilityData): bool =
    result = hasField(message, 15)

proc setcastRange*(message: AbilityData, value: float32) =
    message.castRange = value
    setField(message, 15)

proc castRange*(message: AbilityData): float32 {.inline.} =
    message.castRange

proc `castRange=`*(message: AbilityData, value: float32) {.inline.} =
    setcastRange(message, value)

proc `$`*(message: AbilityData): string =
    runnableExamples:
        echo $AbilityData
        echo fmt"{AbilityData}"
        echo &"{AbilityData}"
    var resultSeq: seq[string]
    if message.hasabilityId:
        resultSeq.add(&"abilityId: {message.abilityId}")
    if message.haslinkName:
        resultSeq.add(&"linkName: {message.linkName}")
    if message.haslinkIndex:
        resultSeq.add(&"linkIndex: {message.linkIndex}")
    if message.hasbuttonName:
        resultSeq.add(&"buttonName: {message.buttonName}")
    if message.hasfriendlyName:
        resultSeq.add(&"friendlyName: {message.friendlyName}")
    if message.hashotkey:
        resultSeq.add(&"hotkey: {message.hotkey}")
    if message.hasremapsToAbilityId:
        resultSeq.add(&"remapsToAbilityId: {message.remapsToAbilityId}")
    if message.hasavailable:
        resultSeq.add(&"available: {message.available}")
    if message.hastarget:
        resultSeq.add(&"target: {message.target}")
    if message.hasallowMinimap:
        resultSeq.add(&"allowMinimap: {message.allowMinimap}")
    if message.hasallowAutocast:
        resultSeq.add(&"allowAutocast: {message.allowAutocast}")
    if message.hasisBuilding:
        resultSeq.add(&"isBuilding: {message.isBuilding}")
    if message.hasfootprintRadius:
        resultSeq.add(&"footprintRadius: {message.footprintRadius}")
    if message.hasisInstantPlacement:
        resultSeq.add(&"isInstantPlacement: {message.isInstantPlacement}")
    if message.hascastRange:
        resultSeq.add(&"castRange: {message.castRange}")
    result = resultSeq.join(", ")
    result = &"AbilityData({result})"

proc sizeOfAbilityData*(message: AbilityData): uint64 =
    if hasabilityId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.abilityId)
    if haslinkName(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfString(message.linkName)
    if haslinkIndex(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfUInt32(message.linkIndex)
    if hasbuttonName(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfString(message.buttonName)
    if hasfriendlyName(message):
        result = result + sizeOfTag(5, WireType.LengthDelimited)
        result = result + sizeOfString(message.friendlyName)
    if hashotkey(message):
        result = result + sizeOfTag(6, WireType.LengthDelimited)
        result = result + sizeOfString(message.hotkey)
    if hasremapsToAbilityId(message):
        result = result + sizeOfTag(7, WireType.Varint)
        result = result + sizeOfUInt32(message.remapsToAbilityId)
    if hasavailable(message):
        result = result + sizeOfTag(8, WireType.Varint)
        result = result + sizeOfBool(message.available)
    if hastarget(message):
        result = result + sizeOfTag(9, WireType.Varint)
        result = result + sizeOfEnum[AbilityData_Target](message.target)
    if hasallowMinimap(message):
        result = result + sizeOfTag(10, WireType.Varint)
        result = result + sizeOfBool(message.allowMinimap)
    if hasallowAutocast(message):
        result = result + sizeOfTag(11, WireType.Varint)
        result = result + sizeOfBool(message.allowAutocast)
    if hasisBuilding(message):
        result = result + sizeOfTag(12, WireType.Varint)
        result = result + sizeOfBool(message.isBuilding)
    if hasfootprintRadius(message):
        result = result + sizeOfTag(13, WireType.Fixed32)
        result = result + sizeOfFloat(message.footprintRadius)
    if hasisInstantPlacement(message):
        result = result + sizeOfTag(14, WireType.Varint)
        result = result + sizeOfBool(message.isInstantPlacement)
    if hascastRange(message):
        result = result + sizeOfTag(15, WireType.Fixed32)
        result = result + sizeOfFloat(message.castRange)
    result = result + sizeOfUnknownFields(message)

proc writeAbilityData*(stream: Stream, message: AbilityData) =
    if hasabilityId(message):
        protoWriteUInt32(stream, message.abilityId, 1)
    if haslinkName(message):
        protoWriteString(stream, message.linkName, 2)
    if haslinkIndex(message):
        protoWriteUInt32(stream, message.linkIndex, 3)
    if hasbuttonName(message):
        protoWriteString(stream, message.buttonName, 4)
    if hasfriendlyName(message):
        protoWriteString(stream, message.friendlyName, 5)
    if hashotkey(message):
        protoWriteString(stream, message.hotkey, 6)
    if hasremapsToAbilityId(message):
        protoWriteUInt32(stream, message.remapsToAbilityId, 7)
    if hasavailable(message):
        protoWriteBool(stream, message.available, 8)
    if hastarget(message):
        protoWriteEnum(stream, message.target, 9)
    if hasallowMinimap(message):
        protoWriteBool(stream, message.allowMinimap, 10)
    if hasallowAutocast(message):
        protoWriteBool(stream, message.allowAutocast, 11)
    if hasisBuilding(message):
        protoWriteBool(stream, message.isBuilding, 12)
    if hasfootprintRadius(message):
        protoWriteFloat(stream, message.footprintRadius, 13)
    if hasisInstantPlacement(message):
        protoWriteBool(stream, message.isInstantPlacement, 14)
    if hascastRange(message):
        protoWriteFloat(stream, message.castRange, 15)
    writeUnknownFields(stream, message)

proc readAbilityData*(stream: Stream): AbilityData =
    result = newAbilityData()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setabilityId(result, protoReadUInt32(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            setlinkName(result, protoReadString(stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setlinkIndex(result, protoReadUInt32(stream))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            setbuttonName(result, protoReadString(stream))
        of 5:
            expectWireType(wireType, WireType.LengthDelimited)
            setfriendlyName(result, protoReadString(stream))
        of 6:
            expectWireType(wireType, WireType.LengthDelimited)
            sethotkey(result, protoReadString(stream))
        of 7:
            expectWireType(wireType, WireType.Varint)
            setremapsToAbilityId(result, protoReadUInt32(stream))
        of 8:
            expectWireType(wireType, WireType.Varint)
            setavailable(result, protoReadBool(stream))
        of 9:
            expectWireType(wireType, WireType.Varint)
            settarget(result, protoReadEnum[AbilityData_Target](stream))
        of 10:
            expectWireType(wireType, WireType.Varint)
            setallowMinimap(result, protoReadBool(stream))
        of 11:
            expectWireType(wireType, WireType.Varint)
            setallowAutocast(result, protoReadBool(stream))
        of 12:
            expectWireType(wireType, WireType.Varint)
            setisBuilding(result, protoReadBool(stream))
        of 13:
            expectWireType(wireType, WireType.Fixed32)
            setfootprintRadius(result, protoReadFloat(stream))
        of 14:
            expectWireType(wireType, WireType.Varint)
            setisInstantPlacement(result, protoReadBool(stream))
        of 15:
            expectWireType(wireType, WireType.Fixed32)
            setcastRange(result, protoReadFloat(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: AbilityData): string =
    let
        ss = newStringStream()
    writeAbilityData(ss, message)
    result = ss.data

proc newAbilityData*(data: string): AbilityData =
    let
        ss = newStringStream(data)
    result = readAbilityData(ss)

proc newAbilityData*(data: seq[byte]): AbilityData =
    let
        ss = newStringStream(cast[string](data))
    result = readAbilityData(ss)


proc fullyQualifiedName*(T: typedesc[UpgradeData]): string = "UpgradeData"

proc readUpgradeDataImpl(stream: Stream): Message = readUpgradeData(stream)
proc writeUpgradeDataImpl(stream: Stream, msg: Message) = writeUpgradeData(stream, UpgradeData(msg))

proc UpgradeDataProcs*(): MessageProcs =
    result.readImpl = readUpgradeDataImpl
    result.writeImpl = writeUpgradeDataImpl

proc newUpgradeData*(): UpgradeData =
    new(result)
    initMessage(result[])
    result.procs = UpgradeDataProcs()
    result.upgradeId = 0
    result.name = ""
    result.mineralCost = 0
    result.vespeneCost = 0
    result.researchTime = 0
    result.abilityId = 0

proc clearupgradeId*(message: UpgradeData) =
    message.upgradeId = 0
    clearFields(message, [1])

proc hasupgradeId*(message: UpgradeData): bool =
    result = hasField(message, 1)

proc setupgradeId*(message: UpgradeData, value: uint32) =
    message.upgradeId = value
    setField(message, 1)

proc upgradeId*(message: UpgradeData): uint32 {.inline.} =
    message.upgradeId

proc `upgradeId=`*(message: UpgradeData, value: uint32) {.inline.} =
    setupgradeId(message, value)

proc clearname*(message: UpgradeData) =
    message.name = ""
    clearFields(message, [2])

proc hasname*(message: UpgradeData): bool =
    result = hasField(message, 2)

proc setname*(message: UpgradeData, value: string) =
    message.name = value
    setField(message, 2)

proc name*(message: UpgradeData): string {.inline.} =
    message.name

proc `name=`*(message: UpgradeData, value: string) {.inline.} =
    setname(message, value)

proc clearmineralCost*(message: UpgradeData) =
    message.mineralCost = 0
    clearFields(message, [3])

proc hasmineralCost*(message: UpgradeData): bool =
    result = hasField(message, 3)

proc setmineralCost*(message: UpgradeData, value: uint32) =
    message.mineralCost = value
    setField(message, 3)

proc mineralCost*(message: UpgradeData): uint32 {.inline.} =
    message.mineralCost

proc `mineralCost=`*(message: UpgradeData, value: uint32) {.inline.} =
    setmineralCost(message, value)

proc clearvespeneCost*(message: UpgradeData) =
    message.vespeneCost = 0
    clearFields(message, [4])

proc hasvespeneCost*(message: UpgradeData): bool =
    result = hasField(message, 4)

proc setvespeneCost*(message: UpgradeData, value: uint32) =
    message.vespeneCost = value
    setField(message, 4)

proc vespeneCost*(message: UpgradeData): uint32 {.inline.} =
    message.vespeneCost

proc `vespeneCost=`*(message: UpgradeData, value: uint32) {.inline.} =
    setvespeneCost(message, value)

proc clearresearchTime*(message: UpgradeData) =
    message.researchTime = 0
    clearFields(message, [5])

proc hasresearchTime*(message: UpgradeData): bool =
    result = hasField(message, 5)

proc setresearchTime*(message: UpgradeData, value: float32) =
    message.researchTime = value
    setField(message, 5)

proc researchTime*(message: UpgradeData): float32 {.inline.} =
    message.researchTime

proc `researchTime=`*(message: UpgradeData, value: float32) {.inline.} =
    setresearchTime(message, value)

proc clearabilityId*(message: UpgradeData) =
    message.abilityId = 0
    clearFields(message, [6])

proc hasabilityId*(message: UpgradeData): bool =
    result = hasField(message, 6)

proc setabilityId*(message: UpgradeData, value: uint32) =
    message.abilityId = value
    setField(message, 6)

proc abilityId*(message: UpgradeData): uint32 {.inline.} =
    message.abilityId

proc `abilityId=`*(message: UpgradeData, value: uint32) {.inline.} =
    setabilityId(message, value)

proc `$`*(message: UpgradeData): string =
    runnableExamples:
        echo $UpgradeData
        echo fmt"{UpgradeData}"
        echo &"{UpgradeData}"
    var resultSeq: seq[string]
    if message.hasupgradeId:
        resultSeq.add(&"upgradeId: {message.upgradeId}")
    if message.hasname:
        resultSeq.add(&"name: {message.name}")
    if message.hasmineralCost:
        resultSeq.add(&"mineralCost: {message.mineralCost}")
    if message.hasvespeneCost:
        resultSeq.add(&"vespeneCost: {message.vespeneCost}")
    if message.hasresearchTime:
        resultSeq.add(&"researchTime: {message.researchTime}")
    if message.hasabilityId:
        resultSeq.add(&"abilityId: {message.abilityId}")
    result = resultSeq.join(", ")
    result = &"UpgradeData({result})"

proc sizeOfUpgradeData*(message: UpgradeData): uint64 =
    if hasupgradeId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.upgradeId)
    if hasname(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfString(message.name)
    if hasmineralCost(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfUInt32(message.mineralCost)
    if hasvespeneCost(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfUInt32(message.vespeneCost)
    if hasresearchTime(message):
        result = result + sizeOfTag(5, WireType.Fixed32)
        result = result + sizeOfFloat(message.researchTime)
    if hasabilityId(message):
        result = result + sizeOfTag(6, WireType.Varint)
        result = result + sizeOfUInt32(message.abilityId)
    result = result + sizeOfUnknownFields(message)

proc writeUpgradeData*(stream: Stream, message: UpgradeData) =
    if hasupgradeId(message):
        protoWriteUInt32(stream, message.upgradeId, 1)
    if hasname(message):
        protoWriteString(stream, message.name, 2)
    if hasmineralCost(message):
        protoWriteUInt32(stream, message.mineralCost, 3)
    if hasvespeneCost(message):
        protoWriteUInt32(stream, message.vespeneCost, 4)
    if hasresearchTime(message):
        protoWriteFloat(stream, message.researchTime, 5)
    if hasabilityId(message):
        protoWriteUInt32(stream, message.abilityId, 6)
    writeUnknownFields(stream, message)

proc readUpgradeData*(stream: Stream): UpgradeData =
    result = newUpgradeData()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setupgradeId(result, protoReadUInt32(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            setname(result, protoReadString(stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setmineralCost(result, protoReadUInt32(stream))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setvespeneCost(result, protoReadUInt32(stream))
        of 5:
            expectWireType(wireType, WireType.Fixed32)
            setresearchTime(result, protoReadFloat(stream))
        of 6:
            expectWireType(wireType, WireType.Varint)
            setabilityId(result, protoReadUInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: UpgradeData): string =
    let
        ss = newStringStream()
    writeUpgradeData(ss, message)
    result = ss.data

proc newUpgradeData*(data: string): UpgradeData =
    let
        ss = newStringStream(data)
    result = readUpgradeData(ss)

proc newUpgradeData*(data: seq[byte]): UpgradeData =
    let
        ss = newStringStream(cast[string](data))
    result = readUpgradeData(ss)


proc fullyQualifiedName*(T: typedesc[Weapon]): string = "Weapon"

proc readWeaponImpl(stream: Stream): Message = readWeapon(stream)
proc writeWeaponImpl(stream: Stream, msg: Message) = writeWeapon(stream, Weapon(msg))

proc WeaponProcs*(): MessageProcs =
    result.readImpl = readWeaponImpl
    result.writeImpl = writeWeaponImpl

proc newWeapon*(): Weapon =
    new(result)
    initMessage(result[])
    result.procs = WeaponProcs()
    result.ftype = Weapon_TargetType.Ground
    result.damage = 0
    result.damageBonus = @[]
    result.attacks = 0
    result.range = 0
    result.speed = 0

proc clearftype*(message: Weapon) =
    message.ftype = Weapon_TargetType.Ground
    clearFields(message, [1])

proc hasftype*(message: Weapon): bool =
    result = hasField(message, 1)

proc setftype*(message: Weapon, value: Weapon_TargetType) =
    message.ftype = value
    setField(message, 1)

proc ftype*(message: Weapon): Weapon_TargetType {.inline.} =
    message.ftype

proc `ftype=`*(message: Weapon, value: Weapon_TargetType) {.inline.} =
    setftype(message, value)

proc cleardamage*(message: Weapon) =
    message.damage = 0
    clearFields(message, [2])

proc hasdamage*(message: Weapon): bool =
    result = hasField(message, 2)

proc setdamage*(message: Weapon, value: float32) =
    message.damage = value
    setField(message, 2)

proc damage*(message: Weapon): float32 {.inline.} =
    message.damage

proc `damage=`*(message: Weapon, value: float32) {.inline.} =
    setdamage(message, value)

proc cleardamageBonus*(message: Weapon) =
    message.damageBonus = @[]
    clearFields(message, [3])

proc hasdamageBonus*(message: Weapon): bool =
    result = hasField(message, 3) or (len(message.damageBonus) > 0)

proc setdamageBonus*(message: Weapon, value: seq[DamageBonus]) =
    message.damageBonus = value
    setField(message, 3)

proc adddamageBonus*(message: Weapon, value: DamageBonus) =
    add(message.damageBonus, value)

proc damageBonus*(message: Weapon): seq[DamageBonus] {.inline.} =
    message.damageBonus

proc `damageBonus=`*(message: Weapon, value: seq[DamageBonus]) {.inline.} =
    setdamageBonus(message, value)

proc clearattacks*(message: Weapon) =
    message.attacks = 0
    clearFields(message, [4])

proc hasattacks*(message: Weapon): bool =
    result = hasField(message, 4)

proc setattacks*(message: Weapon, value: uint32) =
    message.attacks = value
    setField(message, 4)

proc attacks*(message: Weapon): uint32 {.inline.} =
    message.attacks

proc `attacks=`*(message: Weapon, value: uint32) {.inline.} =
    setattacks(message, value)

proc clearrange*(message: Weapon) =
    message.range = 0
    clearFields(message, [5])

proc hasrange*(message: Weapon): bool =
    result = hasField(message, 5)

proc setrange*(message: Weapon, value: float32) =
    message.range = value
    setField(message, 5)

proc range*(message: Weapon): float32 {.inline.} =
    message.range

proc `range=`*(message: Weapon, value: float32) {.inline.} =
    setrange(message, value)

proc clearspeed*(message: Weapon) =
    message.speed = 0
    clearFields(message, [6])

proc hasspeed*(message: Weapon): bool =
    result = hasField(message, 6)

proc setspeed*(message: Weapon, value: float32) =
    message.speed = value
    setField(message, 6)

proc speed*(message: Weapon): float32 {.inline.} =
    message.speed

proc `speed=`*(message: Weapon, value: float32) {.inline.} =
    setspeed(message, value)

proc `$`*(message: Weapon): string =
    runnableExamples:
        echo $Weapon
        echo fmt"{Weapon}"
        echo &"{Weapon}"
    var resultSeq: seq[string]
    if message.hasftype:
        resultSeq.add(&"ftype: {message.ftype}")
    if message.hasdamage:
        resultSeq.add(&"damage: {message.damage}")
    if message.hasdamageBonus:
        resultSeq.add(&"damageBonus: {message.damageBonus}")
    if message.hasattacks:
        resultSeq.add(&"attacks: {message.attacks}")
    if message.hasrange:
        resultSeq.add(&"range: {message.range}")
    if message.hasspeed:
        resultSeq.add(&"speed: {message.speed}")
    result = resultSeq.join(", ")
    result = &"Weapon({result})"

proc sizeOfWeapon*(message: Weapon): uint64 =
    if hasftype(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfEnum[Weapon_TargetType](message.ftype)
    if hasdamage(message):
        result = result + sizeOfTag(2, WireType.Fixed32)
        result = result + sizeOfFloat(message.damage)
    for value in message.damageBonus:
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfDamageBonus(value))
    if hasattacks(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfUInt32(message.attacks)
    if hasrange(message):
        result = result + sizeOfTag(5, WireType.Fixed32)
        result = result + sizeOfFloat(message.range)
    if hasspeed(message):
        result = result + sizeOfTag(6, WireType.Fixed32)
        result = result + sizeOfFloat(message.speed)
    result = result + sizeOfUnknownFields(message)

proc writeWeapon*(stream: Stream, message: Weapon) =
    if hasftype(message):
        protoWriteEnum(stream, message.ftype, 1)
    if hasdamage(message):
        protoWriteFloat(stream, message.damage, 2)
    for value in message.damageBonus:
        writeMessage(stream, value, 3)
    if hasattacks(message):
        protoWriteUInt32(stream, message.attacks, 4)
    if hasrange(message):
        protoWriteFloat(stream, message.range, 5)
    if hasspeed(message):
        protoWriteFloat(stream, message.speed, 6)
    writeUnknownFields(stream, message)

proc readWeapon*(stream: Stream): Weapon =
    result = newWeapon()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setftype(result, protoReadEnum[Weapon_TargetType](stream))
        of 2:
            expectWireType(wireType, WireType.Fixed32)
            setdamage(result, protoReadFloat(stream))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            adddamageBonus(result, newDamageBonus(data))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setattacks(result, protoReadUInt32(stream))
        of 5:
            expectWireType(wireType, WireType.Fixed32)
            setrange(result, protoReadFloat(stream))
        of 6:
            expectWireType(wireType, WireType.Fixed32)
            setspeed(result, protoReadFloat(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: Weapon): string =
    let
        ss = newStringStream()
    writeWeapon(ss, message)
    result = ss.data

proc newWeapon*(data: string): Weapon =
    let
        ss = newStringStream(data)
    result = readWeapon(ss)

proc newWeapon*(data: seq[byte]): Weapon =
    let
        ss = newStringStream(cast[string](data))
    result = readWeapon(ss)


proc fullyQualifiedName*(T: typedesc[UnitTypeData]): string = "UnitTypeData"

proc readUnitTypeDataImpl(stream: Stream): Message = readUnitTypeData(stream)
proc writeUnitTypeDataImpl(stream: Stream, msg: Message) = writeUnitTypeData(stream, UnitTypeData(msg))

proc UnitTypeDataProcs*(): MessageProcs =
    result.readImpl = readUnitTypeDataImpl
    result.writeImpl = writeUnitTypeDataImpl

proc newUnitTypeData*(): UnitTypeData =
    new(result)
    initMessage(result[])
    result.procs = UnitTypeDataProcs()
    result.unitId = 0
    result.name = ""
    result.available = false
    result.cargoSize = 0
    result.mineralCost = 0
    result.vespeneCost = 0
    result.foodRequired = 0
    result.foodProvided = 0
    result.abilityId = 0
    result.race = Race.NoRace
    result.buildTime = 0
    result.hasVespene = false
    result.hasMinerals = false
    result.sightRange = 0
    result.techAlias = @[]
    result.unitAlias = 0
    result.techRequirement = 0
    result.requireAttached = false
    result.attributes = @[]
    result.movementSpeed = 0
    result.armor = 0
    result.weapons = @[]

proc clearunitId*(message: UnitTypeData) =
    message.unitId = 0
    clearFields(message, [1])

proc hasunitId*(message: UnitTypeData): bool =
    result = hasField(message, 1)

proc setunitId*(message: UnitTypeData, value: uint32) =
    message.unitId = value
    setField(message, 1)

proc unitId*(message: UnitTypeData): uint32 {.inline.} =
    message.unitId

proc `unitId=`*(message: UnitTypeData, value: uint32) {.inline.} =
    setunitId(message, value)

proc clearname*(message: UnitTypeData) =
    message.name = ""
    clearFields(message, [2])

proc hasname*(message: UnitTypeData): bool =
    result = hasField(message, 2)

proc setname*(message: UnitTypeData, value: string) =
    message.name = value
    setField(message, 2)

proc name*(message: UnitTypeData): string {.inline.} =
    message.name

proc `name=`*(message: UnitTypeData, value: string) {.inline.} =
    setname(message, value)

proc clearavailable*(message: UnitTypeData) =
    message.available = false
    clearFields(message, [3])

proc hasavailable*(message: UnitTypeData): bool =
    result = hasField(message, 3)

proc setavailable*(message: UnitTypeData, value: bool) =
    message.available = value
    setField(message, 3)

proc available*(message: UnitTypeData): bool {.inline.} =
    message.available

proc `available=`*(message: UnitTypeData, value: bool) {.inline.} =
    setavailable(message, value)

proc clearcargoSize*(message: UnitTypeData) =
    message.cargoSize = 0
    clearFields(message, [4])

proc hascargoSize*(message: UnitTypeData): bool =
    result = hasField(message, 4)

proc setcargoSize*(message: UnitTypeData, value: uint32) =
    message.cargoSize = value
    setField(message, 4)

proc cargoSize*(message: UnitTypeData): uint32 {.inline.} =
    message.cargoSize

proc `cargoSize=`*(message: UnitTypeData, value: uint32) {.inline.} =
    setcargoSize(message, value)

proc clearmineralCost*(message: UnitTypeData) =
    message.mineralCost = 0
    clearFields(message, [12])

proc hasmineralCost*(message: UnitTypeData): bool =
    result = hasField(message, 12)

proc setmineralCost*(message: UnitTypeData, value: uint32) =
    message.mineralCost = value
    setField(message, 12)

proc mineralCost*(message: UnitTypeData): uint32 {.inline.} =
    message.mineralCost

proc `mineralCost=`*(message: UnitTypeData, value: uint32) {.inline.} =
    setmineralCost(message, value)

proc clearvespeneCost*(message: UnitTypeData) =
    message.vespeneCost = 0
    clearFields(message, [13])

proc hasvespeneCost*(message: UnitTypeData): bool =
    result = hasField(message, 13)

proc setvespeneCost*(message: UnitTypeData, value: uint32) =
    message.vespeneCost = value
    setField(message, 13)

proc vespeneCost*(message: UnitTypeData): uint32 {.inline.} =
    message.vespeneCost

proc `vespeneCost=`*(message: UnitTypeData, value: uint32) {.inline.} =
    setvespeneCost(message, value)

proc clearfoodRequired*(message: UnitTypeData) =
    message.foodRequired = 0
    clearFields(message, [14])

proc hasfoodRequired*(message: UnitTypeData): bool =
    result = hasField(message, 14)

proc setfoodRequired*(message: UnitTypeData, value: float32) =
    message.foodRequired = value
    setField(message, 14)

proc foodRequired*(message: UnitTypeData): float32 {.inline.} =
    message.foodRequired

proc `foodRequired=`*(message: UnitTypeData, value: float32) {.inline.} =
    setfoodRequired(message, value)

proc clearfoodProvided*(message: UnitTypeData) =
    message.foodProvided = 0
    clearFields(message, [18])

proc hasfoodProvided*(message: UnitTypeData): bool =
    result = hasField(message, 18)

proc setfoodProvided*(message: UnitTypeData, value: float32) =
    message.foodProvided = value
    setField(message, 18)

proc foodProvided*(message: UnitTypeData): float32 {.inline.} =
    message.foodProvided

proc `foodProvided=`*(message: UnitTypeData, value: float32) {.inline.} =
    setfoodProvided(message, value)

proc clearabilityId*(message: UnitTypeData) =
    message.abilityId = 0
    clearFields(message, [15])

proc hasabilityId*(message: UnitTypeData): bool =
    result = hasField(message, 15)

proc setabilityId*(message: UnitTypeData, value: uint32) =
    message.abilityId = value
    setField(message, 15)

proc abilityId*(message: UnitTypeData): uint32 {.inline.} =
    message.abilityId

proc `abilityId=`*(message: UnitTypeData, value: uint32) {.inline.} =
    setabilityId(message, value)

proc clearrace*(message: UnitTypeData) =
    message.race = Race.NoRace
    clearFields(message, [16])

proc hasrace*(message: UnitTypeData): bool =
    result = hasField(message, 16)

proc setrace*(message: UnitTypeData, value: Race) =
    message.race = value
    setField(message, 16)

proc race*(message: UnitTypeData): Race {.inline.} =
    message.race

proc `race=`*(message: UnitTypeData, value: Race) {.inline.} =
    setrace(message, value)

proc clearbuildTime*(message: UnitTypeData) =
    message.buildTime = 0
    clearFields(message, [17])

proc hasbuildTime*(message: UnitTypeData): bool =
    result = hasField(message, 17)

proc setbuildTime*(message: UnitTypeData, value: float32) =
    message.buildTime = value
    setField(message, 17)

proc buildTime*(message: UnitTypeData): float32 {.inline.} =
    message.buildTime

proc `buildTime=`*(message: UnitTypeData, value: float32) {.inline.} =
    setbuildTime(message, value)

proc clearhasVespene*(message: UnitTypeData) =
    message.hasVespene = false
    clearFields(message, [19])

proc hashasVespene*(message: UnitTypeData): bool =
    result = hasField(message, 19)

proc sethasVespene*(message: UnitTypeData, value: bool) =
    message.hasVespene = value
    setField(message, 19)

proc hasVespene*(message: UnitTypeData): bool {.inline.} =
    message.hasVespene

proc `hasVespene=`*(message: UnitTypeData, value: bool) {.inline.} =
    sethasVespene(message, value)

proc clearhasMinerals*(message: UnitTypeData) =
    message.hasMinerals = false
    clearFields(message, [20])

proc hashasMinerals*(message: UnitTypeData): bool =
    result = hasField(message, 20)

proc sethasMinerals*(message: UnitTypeData, value: bool) =
    message.hasMinerals = value
    setField(message, 20)

proc hasMinerals*(message: UnitTypeData): bool {.inline.} =
    message.hasMinerals

proc `hasMinerals=`*(message: UnitTypeData, value: bool) {.inline.} =
    sethasMinerals(message, value)

proc clearsightRange*(message: UnitTypeData) =
    message.sightRange = 0
    clearFields(message, [25])

proc hassightRange*(message: UnitTypeData): bool =
    result = hasField(message, 25)

proc setsightRange*(message: UnitTypeData, value: float32) =
    message.sightRange = value
    setField(message, 25)

proc sightRange*(message: UnitTypeData): float32 {.inline.} =
    message.sightRange

proc `sightRange=`*(message: UnitTypeData, value: float32) {.inline.} =
    setsightRange(message, value)

proc cleartechAlias*(message: UnitTypeData) =
    message.techAlias = @[]
    clearFields(message, [21])

proc hastechAlias*(message: UnitTypeData): bool =
    result = hasField(message, 21) or (len(message.techAlias) > 0)

proc settechAlias*(message: UnitTypeData, value: seq[uint32]) =
    message.techAlias = value
    setField(message, 21)

proc addtechAlias*(message: UnitTypeData, value: uint32) =
    add(message.techAlias, value)

proc techAlias*(message: UnitTypeData): seq[uint32] {.inline.} =
    message.techAlias

proc `techAlias=`*(message: UnitTypeData, value: seq[uint32]) {.inline.} =
    settechAlias(message, value)

proc clearunitAlias*(message: UnitTypeData) =
    message.unitAlias = 0
    clearFields(message, [22])

proc hasunitAlias*(message: UnitTypeData): bool =
    result = hasField(message, 22)

proc setunitAlias*(message: UnitTypeData, value: uint32) =
    message.unitAlias = value
    setField(message, 22)

proc unitAlias*(message: UnitTypeData): uint32 {.inline.} =
    message.unitAlias

proc `unitAlias=`*(message: UnitTypeData, value: uint32) {.inline.} =
    setunitAlias(message, value)

proc cleartechRequirement*(message: UnitTypeData) =
    message.techRequirement = 0
    clearFields(message, [23])

proc hastechRequirement*(message: UnitTypeData): bool =
    result = hasField(message, 23)

proc settechRequirement*(message: UnitTypeData, value: uint32) =
    message.techRequirement = value
    setField(message, 23)

proc techRequirement*(message: UnitTypeData): uint32 {.inline.} =
    message.techRequirement

proc `techRequirement=`*(message: UnitTypeData, value: uint32) {.inline.} =
    settechRequirement(message, value)

proc clearrequireAttached*(message: UnitTypeData) =
    message.requireAttached = false
    clearFields(message, [24])

proc hasrequireAttached*(message: UnitTypeData): bool =
    result = hasField(message, 24)

proc setrequireAttached*(message: UnitTypeData, value: bool) =
    message.requireAttached = value
    setField(message, 24)

proc requireAttached*(message: UnitTypeData): bool {.inline.} =
    message.requireAttached

proc `requireAttached=`*(message: UnitTypeData, value: bool) {.inline.} =
    setrequireAttached(message, value)

proc clearattributes*(message: UnitTypeData) =
    message.attributes = @[]
    clearFields(message, [8])

proc hasattributes*(message: UnitTypeData): bool =
    result = hasField(message, 8) or (len(message.attributes) > 0)

proc setattributes*(message: UnitTypeData, value: seq[Attribute]) =
    message.attributes = value
    setField(message, 8)

proc addattributes*(message: UnitTypeData, value: Attribute) =
    add(message.attributes, value)

proc attributes*(message: UnitTypeData): seq[Attribute] {.inline.} =
    message.attributes

proc `attributes=`*(message: UnitTypeData, value: seq[Attribute]) {.inline.} =
    setattributes(message, value)

proc clearmovementSpeed*(message: UnitTypeData) =
    message.movementSpeed = 0
    clearFields(message, [9])

proc hasmovementSpeed*(message: UnitTypeData): bool =
    result = hasField(message, 9)

proc setmovementSpeed*(message: UnitTypeData, value: float32) =
    message.movementSpeed = value
    setField(message, 9)

proc movementSpeed*(message: UnitTypeData): float32 {.inline.} =
    message.movementSpeed

proc `movementSpeed=`*(message: UnitTypeData, value: float32) {.inline.} =
    setmovementSpeed(message, value)

proc cleararmor*(message: UnitTypeData) =
    message.armor = 0
    clearFields(message, [10])

proc hasarmor*(message: UnitTypeData): bool =
    result = hasField(message, 10)

proc setarmor*(message: UnitTypeData, value: float32) =
    message.armor = value
    setField(message, 10)

proc armor*(message: UnitTypeData): float32 {.inline.} =
    message.armor

proc `armor=`*(message: UnitTypeData, value: float32) {.inline.} =
    setarmor(message, value)

proc clearweapons*(message: UnitTypeData) =
    message.weapons = @[]
    clearFields(message, [11])

proc hasweapons*(message: UnitTypeData): bool =
    result = hasField(message, 11) or (len(message.weapons) > 0)

proc setweapons*(message: UnitTypeData, value: seq[Weapon]) =
    message.weapons = value
    setField(message, 11)

proc addweapons*(message: UnitTypeData, value: Weapon) =
    add(message.weapons, value)

proc weapons*(message: UnitTypeData): seq[Weapon] {.inline.} =
    message.weapons

proc `weapons=`*(message: UnitTypeData, value: seq[Weapon]) {.inline.} =
    setweapons(message, value)

proc `$`*(message: UnitTypeData): string =
    runnableExamples:
        echo $UnitTypeData
        echo fmt"{UnitTypeData}"
        echo &"{UnitTypeData}"
    var resultSeq: seq[string]
    if message.hasunitId:
        resultSeq.add(&"unitId: {message.unitId}")
    if message.hasname:
        resultSeq.add(&"name: {message.name}")
    if message.hasavailable:
        resultSeq.add(&"available: {message.available}")
    if message.hascargoSize:
        resultSeq.add(&"cargoSize: {message.cargoSize}")
    if message.hasmineralCost:
        resultSeq.add(&"mineralCost: {message.mineralCost}")
    if message.hasvespeneCost:
        resultSeq.add(&"vespeneCost: {message.vespeneCost}")
    if message.hasfoodRequired:
        resultSeq.add(&"foodRequired: {message.foodRequired}")
    if message.hasfoodProvided:
        resultSeq.add(&"foodProvided: {message.foodProvided}")
    if message.hasabilityId:
        resultSeq.add(&"abilityId: {message.abilityId}")
    if message.hasrace:
        resultSeq.add(&"race: {message.race}")
    if message.hasbuildTime:
        resultSeq.add(&"buildTime: {message.buildTime}")
    if message.hashasVespene:
        resultSeq.add(&"hasVespene: {message.hasVespene}")
    if message.hashasMinerals:
        resultSeq.add(&"hasMinerals: {message.hasMinerals}")
    if message.hassightRange:
        resultSeq.add(&"sightRange: {message.sightRange}")
    if message.hastechAlias:
        resultSeq.add(&"techAlias: {message.techAlias}")
    if message.hasunitAlias:
        resultSeq.add(&"unitAlias: {message.unitAlias}")
    if message.hastechRequirement:
        resultSeq.add(&"techRequirement: {message.techRequirement}")
    if message.hasrequireAttached:
        resultSeq.add(&"requireAttached: {message.requireAttached}")
    if message.hasattributes:
        resultSeq.add(&"attributes: {message.attributes}")
    if message.hasmovementSpeed:
        resultSeq.add(&"movementSpeed: {message.movementSpeed}")
    if message.hasarmor:
        resultSeq.add(&"armor: {message.armor}")
    if message.hasweapons:
        resultSeq.add(&"weapons: {message.weapons}")
    result = resultSeq.join(", ")
    result = &"UnitTypeData({result})"

proc sizeOfUnitTypeData*(message: UnitTypeData): uint64 =
    if hasunitId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.unitId)
    if hasname(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfString(message.name)
    if hasavailable(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfBool(message.available)
    if hascargoSize(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfUInt32(message.cargoSize)
    if hasmineralCost(message):
        result = result + sizeOfTag(12, WireType.Varint)
        result = result + sizeOfUInt32(message.mineralCost)
    if hasvespeneCost(message):
        result = result + sizeOfTag(13, WireType.Varint)
        result = result + sizeOfUInt32(message.vespeneCost)
    if hasfoodRequired(message):
        result = result + sizeOfTag(14, WireType.Fixed32)
        result = result + sizeOfFloat(message.foodRequired)
    if hasfoodProvided(message):
        result = result + sizeOfTag(18, WireType.Fixed32)
        result = result + sizeOfFloat(message.foodProvided)
    if hasabilityId(message):
        result = result + sizeOfTag(15, WireType.Varint)
        result = result + sizeOfUInt32(message.abilityId)
    if hasrace(message):
        result = result + sizeOfTag(16, WireType.Varint)
        result = result + sizeOfEnum[Race](message.race)
    if hasbuildTime(message):
        result = result + sizeOfTag(17, WireType.Fixed32)
        result = result + sizeOfFloat(message.buildTime)
    if hashasVespene(message):
        result = result + sizeOfTag(19, WireType.Varint)
        result = result + sizeOfBool(message.hasVespene)
    if hashasMinerals(message):
        result = result + sizeOfTag(20, WireType.Varint)
        result = result + sizeOfBool(message.hasMinerals)
    if hassightRange(message):
        result = result + sizeOfTag(25, WireType.Fixed32)
        result = result + sizeOfFloat(message.sightRange)
    if len(message.techAlias) > 0:
        result = result + sizeOfTag(21, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(packedFieldSize(message.techAlias, FieldType.UInt32))
    if hasunitAlias(message):
        result = result + sizeOfTag(22, WireType.Varint)
        result = result + sizeOfUInt32(message.unitAlias)
    if hastechRequirement(message):
        result = result + sizeOfTag(23, WireType.Varint)
        result = result + sizeOfUInt32(message.techRequirement)
    if hasrequireAttached(message):
        result = result + sizeOfTag(24, WireType.Varint)
        result = result + sizeOfBool(message.requireAttached)
    if len(message.attributes) > 0:
        result = result + sizeOfTag(8, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(packedFieldSize(message.attributes, FieldType.Enum))
    if hasmovementSpeed(message):
        result = result + sizeOfTag(9, WireType.Fixed32)
        result = result + sizeOfFloat(message.movementSpeed)
    if hasarmor(message):
        result = result + sizeOfTag(10, WireType.Fixed32)
        result = result + sizeOfFloat(message.armor)
    for value in message.weapons:
        result = result + sizeOfTag(11, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfWeapon(value))
    result = result + sizeOfUnknownFields(message)

proc writeUnitTypeData*(stream: Stream, message: UnitTypeData) =
    if hasunitId(message):
        protoWriteUInt32(stream, message.unitId, 1)
    if hasname(message):
        protoWriteString(stream, message.name, 2)
    if hasavailable(message):
        protoWriteBool(stream, message.available, 3)
    if hascargoSize(message):
        protoWriteUInt32(stream, message.cargoSize, 4)
    if hasmineralCost(message):
        protoWriteUInt32(stream, message.mineralCost, 12)
    if hasvespeneCost(message):
        protoWriteUInt32(stream, message.vespeneCost, 13)
    if hasfoodRequired(message):
        protoWriteFloat(stream, message.foodRequired, 14)
    if hasfoodProvided(message):
        protoWriteFloat(stream, message.foodProvided, 18)
    if hasabilityId(message):
        protoWriteUInt32(stream, message.abilityId, 15)
    if hasrace(message):
        protoWriteEnum(stream, message.race, 16)
    if hasbuildTime(message):
        protoWriteFloat(stream, message.buildTime, 17)
    if hashasVespene(message):
        protoWriteBool(stream, message.hasVespene, 19)
    if hashasMinerals(message):
        protoWriteBool(stream, message.hasMinerals, 20)
    if hassightRange(message):
        protoWriteFloat(stream, message.sightRange, 25)
    for value in message.techAlias:
        protoWriteUInt32(stream, value, 21)
    if hasunitAlias(message):
        protoWriteUInt32(stream, message.unitAlias, 22)
    if hastechRequirement(message):
        protoWriteUInt32(stream, message.techRequirement, 23)
    if hasrequireAttached(message):
        protoWriteBool(stream, message.requireAttached, 24)
    for value in message.attributes:
        protoWriteEnum(stream, value, 8)
    if hasmovementSpeed(message):
        protoWriteFloat(stream, message.movementSpeed, 9)
    if hasarmor(message):
        protoWriteFloat(stream, message.armor, 10)
    for value in message.weapons:
        writeMessage(stream, value, 11)
    writeUnknownFields(stream, message)

proc readUnitTypeData*(stream: Stream): UnitTypeData =
    result = newUnitTypeData()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setunitId(result, protoReadUInt32(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            setname(result, protoReadString(stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setavailable(result, protoReadBool(stream))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setcargoSize(result, protoReadUInt32(stream))
        of 12:
            expectWireType(wireType, WireType.Varint)
            setmineralCost(result, protoReadUInt32(stream))
        of 13:
            expectWireType(wireType, WireType.Varint)
            setvespeneCost(result, protoReadUInt32(stream))
        of 14:
            expectWireType(wireType, WireType.Fixed32)
            setfoodRequired(result, protoReadFloat(stream))
        of 18:
            expectWireType(wireType, WireType.Fixed32)
            setfoodProvided(result, protoReadFloat(stream))
        of 15:
            expectWireType(wireType, WireType.Varint)
            setabilityId(result, protoReadUInt32(stream))
        of 16:
            expectWireType(wireType, WireType.Varint)
            setrace(result, protoReadEnum[Race](stream))
        of 17:
            expectWireType(wireType, WireType.Fixed32)
            setbuildTime(result, protoReadFloat(stream))
        of 19:
            expectWireType(wireType, WireType.Varint)
            sethasVespene(result, protoReadBool(stream))
        of 20:
            expectWireType(wireType, WireType.Varint)
            sethasMinerals(result, protoReadBool(stream))
        of 25:
            expectWireType(wireType, WireType.Fixed32)
            setsightRange(result, protoReadFloat(stream))
        of 21:
            expectWireType(wireType, WireType.Varint, WireType.LengthDelimited)
            if wireType == WireType.LengthDelimited:
                let
                    size = readVarint(stream)
                    start = uint64(getPosition(stream))
                var consumed = 0'u64
                while consumed < size:
                    addtechAlias(result, protoReadUInt32(stream))
                    consumed = uint64(getPosition(stream)) - start
                if consumed != size:
                    raise newException(Exception, "packed field size mismatch")
            else:
                addtechAlias(result, protoReadUInt32(stream))
        of 22:
            expectWireType(wireType, WireType.Varint)
            setunitAlias(result, protoReadUInt32(stream))
        of 23:
            expectWireType(wireType, WireType.Varint)
            settechRequirement(result, protoReadUInt32(stream))
        of 24:
            expectWireType(wireType, WireType.Varint)
            setrequireAttached(result, protoReadBool(stream))
        of 8:
            expectWireType(wireType, WireType.Varint, WireType.LengthDelimited)
            if wireType == WireType.LengthDelimited:
                let
                    size = readVarint(stream)
                    start = uint64(getPosition(stream))
                var consumed = 0'u64
                while consumed < size:
                    addattributes(result, protoReadEnum[Attribute](stream))
                    consumed = uint64(getPosition(stream)) - start
                if consumed != size:
                    raise newException(Exception, "packed field size mismatch")
            else:
                addattributes(result, protoReadEnum[Attribute](stream))
        of 9:
            expectWireType(wireType, WireType.Fixed32)
            setmovementSpeed(result, protoReadFloat(stream))
        of 10:
            expectWireType(wireType, WireType.Fixed32)
            setarmor(result, protoReadFloat(stream))
        of 11:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addweapons(result, newWeapon(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: UnitTypeData): string =
    let
        ss = newStringStream()
    writeUnitTypeData(ss, message)
    result = ss.data

proc newUnitTypeData*(data: string): UnitTypeData =
    let
        ss = newStringStream(data)
    result = readUnitTypeData(ss)

proc newUnitTypeData*(data: seq[byte]): UnitTypeData =
    let
        ss = newStringStream(cast[string](data))
    result = readUnitTypeData(ss)


proc fullyQualifiedName*(T: typedesc[EffectData]): string = "EffectData"

proc readEffectDataImpl(stream: Stream): Message = readEffectData(stream)
proc writeEffectDataImpl(stream: Stream, msg: Message) = writeEffectData(stream, EffectData(msg))

proc EffectDataProcs*(): MessageProcs =
    result.readImpl = readEffectDataImpl
    result.writeImpl = writeEffectDataImpl

proc newEffectData*(): EffectData =
    new(result)
    initMessage(result[])
    result.procs = EffectDataProcs()
    result.effectId = 0
    result.name = ""
    result.friendlyName = ""
    result.radius = 0

proc cleareffectId*(message: EffectData) =
    message.effectId = 0
    clearFields(message, [1])

proc haseffectId*(message: EffectData): bool =
    result = hasField(message, 1)

proc seteffectId*(message: EffectData, value: uint32) =
    message.effectId = value
    setField(message, 1)

proc effectId*(message: EffectData): uint32 {.inline.} =
    message.effectId

proc `effectId=`*(message: EffectData, value: uint32) {.inline.} =
    seteffectId(message, value)

proc clearname*(message: EffectData) =
    message.name = ""
    clearFields(message, [2])

proc hasname*(message: EffectData): bool =
    result = hasField(message, 2)

proc setname*(message: EffectData, value: string) =
    message.name = value
    setField(message, 2)

proc name*(message: EffectData): string {.inline.} =
    message.name

proc `name=`*(message: EffectData, value: string) {.inline.} =
    setname(message, value)

proc clearfriendlyName*(message: EffectData) =
    message.friendlyName = ""
    clearFields(message, [3])

proc hasfriendlyName*(message: EffectData): bool =
    result = hasField(message, 3)

proc setfriendlyName*(message: EffectData, value: string) =
    message.friendlyName = value
    setField(message, 3)

proc friendlyName*(message: EffectData): string {.inline.} =
    message.friendlyName

proc `friendlyName=`*(message: EffectData, value: string) {.inline.} =
    setfriendlyName(message, value)

proc clearradius*(message: EffectData) =
    message.radius = 0
    clearFields(message, [4])

proc hasradius*(message: EffectData): bool =
    result = hasField(message, 4)

proc setradius*(message: EffectData, value: float32) =
    message.radius = value
    setField(message, 4)

proc radius*(message: EffectData): float32 {.inline.} =
    message.radius

proc `radius=`*(message: EffectData, value: float32) {.inline.} =
    setradius(message, value)

proc `$`*(message: EffectData): string =
    runnableExamples:
        echo $EffectData
        echo fmt"{EffectData}"
        echo &"{EffectData}"
    var resultSeq: seq[string]
    if message.haseffectId:
        resultSeq.add(&"effectId: {message.effectId}")
    if message.hasname:
        resultSeq.add(&"name: {message.name}")
    if message.hasfriendlyName:
        resultSeq.add(&"friendlyName: {message.friendlyName}")
    if message.hasradius:
        resultSeq.add(&"radius: {message.radius}")
    result = resultSeq.join(", ")
    result = &"EffectData({result})"

proc sizeOfEffectData*(message: EffectData): uint64 =
    if haseffectId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.effectId)
    if hasname(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfString(message.name)
    if hasfriendlyName(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfString(message.friendlyName)
    if hasradius(message):
        result = result + sizeOfTag(4, WireType.Fixed32)
        result = result + sizeOfFloat(message.radius)
    result = result + sizeOfUnknownFields(message)

proc writeEffectData*(stream: Stream, message: EffectData) =
    if haseffectId(message):
        protoWriteUInt32(stream, message.effectId, 1)
    if hasname(message):
        protoWriteString(stream, message.name, 2)
    if hasfriendlyName(message):
        protoWriteString(stream, message.friendlyName, 3)
    if hasradius(message):
        protoWriteFloat(stream, message.radius, 4)
    writeUnknownFields(stream, message)

proc readEffectData*(stream: Stream): EffectData =
    result = newEffectData()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            seteffectId(result, protoReadUInt32(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            setname(result, protoReadString(stream))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            setfriendlyName(result, protoReadString(stream))
        of 4:
            expectWireType(wireType, WireType.Fixed32)
            setradius(result, protoReadFloat(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: EffectData): string =
    let
        ss = newStringStream()
    writeEffectData(ss, message)
    result = ss.data

proc newEffectData*(data: string): EffectData =
    let
        ss = newStringStream(data)
    result = readEffectData(ss)

proc newEffectData*(data: seq[byte]): EffectData =
    let
        ss = newStringStream(cast[string](data))
    result = readEffectData(ss)


proc fullyQualifiedName*(T: typedesc[BuffData]): string = "BuffData"

proc readBuffDataImpl(stream: Stream): Message = readBuffData(stream)
proc writeBuffDataImpl(stream: Stream, msg: Message) = writeBuffData(stream, BuffData(msg))

proc BuffDataProcs*(): MessageProcs =
    result.readImpl = readBuffDataImpl
    result.writeImpl = writeBuffDataImpl

proc newBuffData*(): BuffData =
    new(result)
    initMessage(result[])
    result.procs = BuffDataProcs()
    result.buffId = 0
    result.name = ""

proc clearbuffId*(message: BuffData) =
    message.buffId = 0
    clearFields(message, [1])

proc hasbuffId*(message: BuffData): bool =
    result = hasField(message, 1)

proc setbuffId*(message: BuffData, value: uint32) =
    message.buffId = value
    setField(message, 1)

proc buffId*(message: BuffData): uint32 {.inline.} =
    message.buffId

proc `buffId=`*(message: BuffData, value: uint32) {.inline.} =
    setbuffId(message, value)

proc clearname*(message: BuffData) =
    message.name = ""
    clearFields(message, [2])

proc hasname*(message: BuffData): bool =
    result = hasField(message, 2)

proc setname*(message: BuffData, value: string) =
    message.name = value
    setField(message, 2)

proc name*(message: BuffData): string {.inline.} =
    message.name

proc `name=`*(message: BuffData, value: string) {.inline.} =
    setname(message, value)

proc `$`*(message: BuffData): string =
    runnableExamples:
        echo $BuffData
        echo fmt"{BuffData}"
        echo &"{BuffData}"
    var resultSeq: seq[string]
    if message.hasbuffId:
        resultSeq.add(&"buffId: {message.buffId}")
    if message.hasname:
        resultSeq.add(&"name: {message.name}")
    result = resultSeq.join(", ")
    result = &"BuffData({result})"

proc sizeOfBuffData*(message: BuffData): uint64 =
    if hasbuffId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.buffId)
    if hasname(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfString(message.name)
    result = result + sizeOfUnknownFields(message)

proc writeBuffData*(stream: Stream, message: BuffData) =
    if hasbuffId(message):
        protoWriteUInt32(stream, message.buffId, 1)
    if hasname(message):
        protoWriteString(stream, message.name, 2)
    writeUnknownFields(stream, message)

proc readBuffData*(stream: Stream): BuffData =
    result = newBuffData()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setbuffId(result, protoReadUInt32(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            setname(result, protoReadString(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: BuffData): string =
    let
        ss = newStringStream()
    writeBuffData(ss, message)
    result = ss.data

proc newBuffData*(data: string): BuffData =
    let
        ss = newStringStream(data)
    result = readBuffData(ss)

proc newBuffData*(data: seq[byte]): BuffData =
    let
        ss = newStringStream(cast[string](data))
    result = readBuffData(ss)


