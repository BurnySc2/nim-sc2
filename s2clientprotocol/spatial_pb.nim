# Generated by protoc_gen_nim. Do not edit!

import base64
import intsets
import json
import strformat
import strutils

import nimpb/nimpb
import nimpb/json as nimpb_json

import common_pb

type
    ActionSpatialUnitSelectionPoint_Type* {.pure.} = enum
        Select = 1
        Toggle = 2
        AllType = 3
        AddAllType = 4
    ObservationFeatureLayer* = ref ObservationFeatureLayerObj
    ObservationFeatureLayerObj* = object of Message
        renders: FeatureLayers
        minimapRenders: FeatureLayersMinimap
    FeatureLayers* = ref FeatureLayersObj
    FeatureLayersObj* = object of Message
        heightMap: ImageData
        visibilityMap: ImageData
        creep: ImageData
        power: ImageData
        playerId: ImageData
        unitType: ImageData
        selected: ImageData
        unitHitPoints: ImageData
        unitHitPointsRatio: ImageData
        unitEnergy: ImageData
        unitEnergyRatio: ImageData
        unitShields: ImageData
        unitShieldsRatio: ImageData
        playerRelative: ImageData
        unitDensityAa: ImageData
        unitDensity: ImageData
        effects: ImageData
        hallucinations: ImageData
        cloaked: ImageData
        blip: ImageData
        buffs: ImageData
        buffDuration: ImageData
        active: ImageData
        buildProgress: ImageData
        buildable: ImageData
        pathable: ImageData
        placeholder: ImageData
    FeatureLayersMinimap* = ref FeatureLayersMinimapObj
    FeatureLayersMinimapObj* = object of Message
        heightMap: ImageData
        visibilityMap: ImageData
        creep: ImageData
        camera: ImageData
        playerId: ImageData
        playerRelative: ImageData
        selected: ImageData
        alerts: ImageData
        buildable: ImageData
        pathable: ImageData
        unitType: ImageData
    ObservationRender* = ref ObservationRenderObj
    ObservationRenderObj* = object of Message
        map: ImageData
        minimap: ImageData
    ActionSpatial* = ref ActionSpatialObj
    ActionSpatialObj* = object of Message
        action: ActionSpatial_action_OneOf

    ActionSpatial_action_Kind* {.pure.} = enum
        UnitCommand
        CameraMove
        UnitSelectionPoint
        UnitSelectionRect
        NotSet

    ActionSpatial_action_OneOf* = object
        case kind*: ActionSpatial_action_Kind
        of ActionSpatial_action_Kind.UnitCommand: unitCommand*: ActionSpatialUnitCommand
        of ActionSpatial_action_Kind.CameraMove: cameraMove*: ActionSpatialCameraMove
        of ActionSpatial_action_Kind.UnitSelectionPoint: unitSelectionPoint*: ActionSpatialUnitSelectionPoint
        of ActionSpatial_action_Kind.UnitSelectionRect: unitSelectionRect*: ActionSpatialUnitSelectionRect
        of ActionSpatial_action_Kind.NotSet: nil
    ActionSpatialUnitCommand* = ref ActionSpatialUnitCommandObj
    ActionSpatialUnitCommandObj* = object of Message
        abilityId: int32
        queueCommand: bool
        target: ActionSpatialUnitCommand_target_OneOf

    ActionSpatialUnitCommand_target_Kind* {.pure.} = enum
        TargetScreenCoord
        TargetMinimapCoord
        NotSet

    ActionSpatialUnitCommand_target_OneOf* = object
        case kind*: ActionSpatialUnitCommand_target_Kind
        of ActionSpatialUnitCommand_target_Kind.TargetScreenCoord: targetScreenCoord*: PointI
        of ActionSpatialUnitCommand_target_Kind.TargetMinimapCoord: targetMinimapCoord*: PointI
        of ActionSpatialUnitCommand_target_Kind.NotSet: nil
    ActionSpatialCameraMove* = ref ActionSpatialCameraMoveObj
    ActionSpatialCameraMoveObj* = object of Message
        centerMinimap: PointI
    ActionSpatialUnitSelectionPoint* = ref ActionSpatialUnitSelectionPointObj
    ActionSpatialUnitSelectionPointObj* = object of Message
        selectionScreenCoord: PointI
        ftype: ActionSpatialUnitSelectionPoint_Type
    ActionSpatialUnitSelectionRect* = ref ActionSpatialUnitSelectionRectObj
    ActionSpatialUnitSelectionRectObj* = object of Message
        selectionScreenCoord: seq[RectangleI]
        selectionAdd: bool

proc newActionSpatialUnitSelectionRect*(): ActionSpatialUnitSelectionRect
proc newActionSpatialUnitSelectionRect*(data: string): ActionSpatialUnitSelectionRect
proc newActionSpatialUnitSelectionRect*(data: seq[byte]): ActionSpatialUnitSelectionRect
proc writeActionSpatialUnitSelectionRect*(stream: Stream, message: ActionSpatialUnitSelectionRect)
proc readActionSpatialUnitSelectionRect*(stream: Stream): ActionSpatialUnitSelectionRect
proc sizeOfActionSpatialUnitSelectionRect*(message: ActionSpatialUnitSelectionRect): uint64

proc newActionSpatialCameraMove*(): ActionSpatialCameraMove
proc newActionSpatialCameraMove*(data: string): ActionSpatialCameraMove
proc newActionSpatialCameraMove*(data: seq[byte]): ActionSpatialCameraMove
proc writeActionSpatialCameraMove*(stream: Stream, message: ActionSpatialCameraMove)
proc readActionSpatialCameraMove*(stream: Stream): ActionSpatialCameraMove
proc sizeOfActionSpatialCameraMove*(message: ActionSpatialCameraMove): uint64

proc newActionSpatialUnitSelectionPoint*(): ActionSpatialUnitSelectionPoint
proc newActionSpatialUnitSelectionPoint*(data: string): ActionSpatialUnitSelectionPoint
proc newActionSpatialUnitSelectionPoint*(data: seq[byte]): ActionSpatialUnitSelectionPoint
proc writeActionSpatialUnitSelectionPoint*(stream: Stream, message: ActionSpatialUnitSelectionPoint)
proc readActionSpatialUnitSelectionPoint*(stream: Stream): ActionSpatialUnitSelectionPoint
proc sizeOfActionSpatialUnitSelectionPoint*(message: ActionSpatialUnitSelectionPoint): uint64

proc newActionSpatialUnitCommand*(): ActionSpatialUnitCommand
proc newActionSpatialUnitCommand*(data: string): ActionSpatialUnitCommand
proc newActionSpatialUnitCommand*(data: seq[byte]): ActionSpatialUnitCommand
proc writeActionSpatialUnitCommand*(stream: Stream, message: ActionSpatialUnitCommand)
proc readActionSpatialUnitCommand*(stream: Stream): ActionSpatialUnitCommand
proc sizeOfActionSpatialUnitCommand*(message: ActionSpatialUnitCommand): uint64

proc newActionSpatial*(): ActionSpatial
proc newActionSpatial*(data: string): ActionSpatial
proc newActionSpatial*(data: seq[byte]): ActionSpatial
proc writeActionSpatial*(stream: Stream, message: ActionSpatial)
proc readActionSpatial*(stream: Stream): ActionSpatial
proc sizeOfActionSpatial*(message: ActionSpatial): uint64

proc newFeatureLayers*(): FeatureLayers
proc newFeatureLayers*(data: string): FeatureLayers
proc newFeatureLayers*(data: seq[byte]): FeatureLayers
proc writeFeatureLayers*(stream: Stream, message: FeatureLayers)
proc readFeatureLayers*(stream: Stream): FeatureLayers
proc sizeOfFeatureLayers*(message: FeatureLayers): uint64

proc newObservationRender*(): ObservationRender
proc newObservationRender*(data: string): ObservationRender
proc newObservationRender*(data: seq[byte]): ObservationRender
proc writeObservationRender*(stream: Stream, message: ObservationRender)
proc readObservationRender*(stream: Stream): ObservationRender
proc sizeOfObservationRender*(message: ObservationRender): uint64

proc newFeatureLayersMinimap*(): FeatureLayersMinimap
proc newFeatureLayersMinimap*(data: string): FeatureLayersMinimap
proc newFeatureLayersMinimap*(data: seq[byte]): FeatureLayersMinimap
proc writeFeatureLayersMinimap*(stream: Stream, message: FeatureLayersMinimap)
proc readFeatureLayersMinimap*(stream: Stream): FeatureLayersMinimap
proc sizeOfFeatureLayersMinimap*(message: FeatureLayersMinimap): uint64

proc newObservationFeatureLayer*(): ObservationFeatureLayer
proc newObservationFeatureLayer*(data: string): ObservationFeatureLayer
proc newObservationFeatureLayer*(data: seq[byte]): ObservationFeatureLayer
proc writeObservationFeatureLayer*(stream: Stream, message: ObservationFeatureLayer)
proc readObservationFeatureLayer*(stream: Stream): ObservationFeatureLayer
proc sizeOfObservationFeatureLayer*(message: ObservationFeatureLayer): uint64

proc fullyQualifiedName*(T: typedesc[ActionSpatialUnitSelectionRect]): string = "ActionSpatialUnitSelectionRect"

proc readActionSpatialUnitSelectionRectImpl(stream: Stream): Message = readActionSpatialUnitSelectionRect(stream)
proc writeActionSpatialUnitSelectionRectImpl(stream: Stream, msg: Message) = writeActionSpatialUnitSelectionRect(stream, ActionSpatialUnitSelectionRect(msg))

proc ActionSpatialUnitSelectionRectProcs*(): MessageProcs =
    result.readImpl = readActionSpatialUnitSelectionRectImpl
    result.writeImpl = writeActionSpatialUnitSelectionRectImpl

proc newActionSpatialUnitSelectionRect*(): ActionSpatialUnitSelectionRect =
    new(result)
    initMessage(result[])
    result.procs = ActionSpatialUnitSelectionRectProcs()
    result.selectionScreenCoord = @[]
    result.selectionAdd = false

proc clearselectionScreenCoord*(message: ActionSpatialUnitSelectionRect) =
    message.selectionScreenCoord = @[]
    clearFields(message, [1])

proc hasselectionScreenCoord*(message: ActionSpatialUnitSelectionRect): bool =
    result = hasField(message, 1) or (len(message.selectionScreenCoord) > 0)

proc setselectionScreenCoord*(message: ActionSpatialUnitSelectionRect, value: seq[RectangleI]) =
    message.selectionScreenCoord = value
    setField(message, 1)

proc addselectionScreenCoord*(message: ActionSpatialUnitSelectionRect, value: RectangleI) =
    add(message.selectionScreenCoord, value)

proc selectionScreenCoord*(message: ActionSpatialUnitSelectionRect): seq[RectangleI] {.inline.} =
    message.selectionScreenCoord

proc `selectionScreenCoord=`*(message: ActionSpatialUnitSelectionRect, value: seq[RectangleI]) {.inline.} =
    setselectionScreenCoord(message, value)

proc clearselectionAdd*(message: ActionSpatialUnitSelectionRect) =
    message.selectionAdd = false
    clearFields(message, [2])

proc hasselectionAdd*(message: ActionSpatialUnitSelectionRect): bool =
    result = hasField(message, 2)

proc setselectionAdd*(message: ActionSpatialUnitSelectionRect, value: bool) =
    message.selectionAdd = value
    setField(message, 2)

proc selectionAdd*(message: ActionSpatialUnitSelectionRect): bool {.inline.} =
    message.selectionAdd

proc `selectionAdd=`*(message: ActionSpatialUnitSelectionRect, value: bool) {.inline.} =
    setselectionAdd(message, value)

proc `$`*(message: ActionSpatialUnitSelectionRect): string =
    runnableExamples:
        echo $ActionSpatialUnitSelectionRect
        echo fmt"{ActionSpatialUnitSelectionRect}"
        echo &"{ActionSpatialUnitSelectionRect}"
    var resultSeq: seq[string]
    if message.hasselectionScreenCoord:
        resultSeq.add(&"selectionScreenCoord: {message.selectionScreenCoord}")
    if message.hasselectionAdd:
        resultSeq.add(&"selectionAdd: {message.selectionAdd}")
    result = resultSeq.join(", ")
    result = &"ActionSpatialUnitSelectionRect({result})"

proc sizeOfActionSpatialUnitSelectionRect*(message: ActionSpatialUnitSelectionRect): uint64 =
    for value in message.selectionScreenCoord:
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRectangleI(value))
    if hasselectionAdd(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfBool(message.selectionAdd)
    result = result + sizeOfUnknownFields(message)

proc writeActionSpatialUnitSelectionRect*(stream: Stream, message: ActionSpatialUnitSelectionRect) =
    for value in message.selectionScreenCoord:
        writeMessage(stream, value, 1)
    if hasselectionAdd(message):
        protoWriteBool(stream, message.selectionAdd, 2)
    writeUnknownFields(stream, message)

proc readActionSpatialUnitSelectionRect*(stream: Stream): ActionSpatialUnitSelectionRect =
    result = newActionSpatialUnitSelectionRect()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addselectionScreenCoord(result, newRectangleI(data))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setselectionAdd(result, protoReadBool(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionSpatialUnitSelectionRect): string =
    let
        ss = newStringStream()
    writeActionSpatialUnitSelectionRect(ss, message)
    result = ss.data

proc newActionSpatialUnitSelectionRect*(data: string): ActionSpatialUnitSelectionRect =
    let
        ss = newStringStream(data)
    result = readActionSpatialUnitSelectionRect(ss)

proc newActionSpatialUnitSelectionRect*(data: seq[byte]): ActionSpatialUnitSelectionRect =
    let
        ss = newStringStream(cast[string](data))
    result = readActionSpatialUnitSelectionRect(ss)


proc fullyQualifiedName*(T: typedesc[ActionSpatialCameraMove]): string = "ActionSpatialCameraMove"

proc readActionSpatialCameraMoveImpl(stream: Stream): Message = readActionSpatialCameraMove(stream)
proc writeActionSpatialCameraMoveImpl(stream: Stream, msg: Message) = writeActionSpatialCameraMove(stream, ActionSpatialCameraMove(msg))

proc ActionSpatialCameraMoveProcs*(): MessageProcs =
    result.readImpl = readActionSpatialCameraMoveImpl
    result.writeImpl = writeActionSpatialCameraMoveImpl

proc newActionSpatialCameraMove*(): ActionSpatialCameraMove =
    new(result)
    initMessage(result[])
    result.procs = ActionSpatialCameraMoveProcs()
    result.centerMinimap = nil

proc clearcenterMinimap*(message: ActionSpatialCameraMove) =
    message.centerMinimap = nil
    clearFields(message, [1])

proc hascenterMinimap*(message: ActionSpatialCameraMove): bool =
    result = hasField(message, 1)

proc setcenterMinimap*(message: ActionSpatialCameraMove, value: PointI) =
    message.centerMinimap = value
    setField(message, 1)

proc centerMinimap*(message: ActionSpatialCameraMove): PointI {.inline.} =
    message.centerMinimap

proc `centerMinimap=`*(message: ActionSpatialCameraMove, value: PointI) {.inline.} =
    setcenterMinimap(message, value)

proc `$`*(message: ActionSpatialCameraMove): string =
    runnableExamples:
        echo $ActionSpatialCameraMove
        echo fmt"{ActionSpatialCameraMove}"
        echo &"{ActionSpatialCameraMove}"
    var resultSeq: seq[string]
    if message.hascenterMinimap:
        resultSeq.add(&"centerMinimap: {message.centerMinimap}")
    result = resultSeq.join(", ")
    result = &"ActionSpatialCameraMove({result})"

proc sizeOfActionSpatialCameraMove*(message: ActionSpatialCameraMove): uint64 =
    if hascenterMinimap(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPointI(message.centerMinimap))
    result = result + sizeOfUnknownFields(message)

proc writeActionSpatialCameraMove*(stream: Stream, message: ActionSpatialCameraMove) =
    if hascenterMinimap(message):
        writeMessage(stream, message.centerMinimap, 1)
    writeUnknownFields(stream, message)

proc readActionSpatialCameraMove*(stream: Stream): ActionSpatialCameraMove =
    result = newActionSpatialCameraMove()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcenterMinimap(result, newPointI(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionSpatialCameraMove): string =
    let
        ss = newStringStream()
    writeActionSpatialCameraMove(ss, message)
    result = ss.data

proc newActionSpatialCameraMove*(data: string): ActionSpatialCameraMove =
    let
        ss = newStringStream(data)
    result = readActionSpatialCameraMove(ss)

proc newActionSpatialCameraMove*(data: seq[byte]): ActionSpatialCameraMove =
    let
        ss = newStringStream(cast[string](data))
    result = readActionSpatialCameraMove(ss)


proc fullyQualifiedName*(T: typedesc[ActionSpatialUnitSelectionPoint]): string = "ActionSpatialUnitSelectionPoint"

proc readActionSpatialUnitSelectionPointImpl(stream: Stream): Message = readActionSpatialUnitSelectionPoint(stream)
proc writeActionSpatialUnitSelectionPointImpl(stream: Stream, msg: Message) = writeActionSpatialUnitSelectionPoint(stream, ActionSpatialUnitSelectionPoint(msg))

proc ActionSpatialUnitSelectionPointProcs*(): MessageProcs =
    result.readImpl = readActionSpatialUnitSelectionPointImpl
    result.writeImpl = writeActionSpatialUnitSelectionPointImpl

proc newActionSpatialUnitSelectionPoint*(): ActionSpatialUnitSelectionPoint =
    new(result)
    initMessage(result[])
    result.procs = ActionSpatialUnitSelectionPointProcs()
    result.selectionScreenCoord = nil
    result.ftype = ActionSpatialUnitSelectionPoint_Type.Select

proc clearselectionScreenCoord*(message: ActionSpatialUnitSelectionPoint) =
    message.selectionScreenCoord = nil
    clearFields(message, [1])

proc hasselectionScreenCoord*(message: ActionSpatialUnitSelectionPoint): bool =
    result = hasField(message, 1)

proc setselectionScreenCoord*(message: ActionSpatialUnitSelectionPoint, value: PointI) =
    message.selectionScreenCoord = value
    setField(message, 1)

proc selectionScreenCoord*(message: ActionSpatialUnitSelectionPoint): PointI {.inline.} =
    message.selectionScreenCoord

proc `selectionScreenCoord=`*(message: ActionSpatialUnitSelectionPoint, value: PointI) {.inline.} =
    setselectionScreenCoord(message, value)

proc clearftype*(message: ActionSpatialUnitSelectionPoint) =
    message.ftype = ActionSpatialUnitSelectionPoint_Type.Select
    clearFields(message, [2])

proc hasftype*(message: ActionSpatialUnitSelectionPoint): bool =
    result = hasField(message, 2)

proc setftype*(message: ActionSpatialUnitSelectionPoint, value: ActionSpatialUnitSelectionPoint_Type) =
    message.ftype = value
    setField(message, 2)

proc ftype*(message: ActionSpatialUnitSelectionPoint): ActionSpatialUnitSelectionPoint_Type {.inline.} =
    message.ftype

proc `ftype=`*(message: ActionSpatialUnitSelectionPoint, value: ActionSpatialUnitSelectionPoint_Type) {.inline.} =
    setftype(message, value)

proc `$`*(message: ActionSpatialUnitSelectionPoint): string =
    runnableExamples:
        echo $ActionSpatialUnitSelectionPoint
        echo fmt"{ActionSpatialUnitSelectionPoint}"
        echo &"{ActionSpatialUnitSelectionPoint}"
    var resultSeq: seq[string]
    if message.hasselectionScreenCoord:
        resultSeq.add(&"selectionScreenCoord: {message.selectionScreenCoord}")
    if message.hasftype:
        resultSeq.add(&"ftype: {message.ftype}")
    result = resultSeq.join(", ")
    result = &"ActionSpatialUnitSelectionPoint({result})"

proc sizeOfActionSpatialUnitSelectionPoint*(message: ActionSpatialUnitSelectionPoint): uint64 =
    if hasselectionScreenCoord(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPointI(message.selectionScreenCoord))
    if hasftype(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfEnum[ActionSpatialUnitSelectionPoint_Type](message.ftype)
    result = result + sizeOfUnknownFields(message)

proc writeActionSpatialUnitSelectionPoint*(stream: Stream, message: ActionSpatialUnitSelectionPoint) =
    if hasselectionScreenCoord(message):
        writeMessage(stream, message.selectionScreenCoord, 1)
    if hasftype(message):
        protoWriteEnum(stream, message.ftype, 2)
    writeUnknownFields(stream, message)

proc readActionSpatialUnitSelectionPoint*(stream: Stream): ActionSpatialUnitSelectionPoint =
    result = newActionSpatialUnitSelectionPoint()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setselectionScreenCoord(result, newPointI(data))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setftype(result, protoReadEnum[ActionSpatialUnitSelectionPoint_Type](stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionSpatialUnitSelectionPoint): string =
    let
        ss = newStringStream()
    writeActionSpatialUnitSelectionPoint(ss, message)
    result = ss.data

proc newActionSpatialUnitSelectionPoint*(data: string): ActionSpatialUnitSelectionPoint =
    let
        ss = newStringStream(data)
    result = readActionSpatialUnitSelectionPoint(ss)

proc newActionSpatialUnitSelectionPoint*(data: seq[byte]): ActionSpatialUnitSelectionPoint =
    let
        ss = newStringStream(cast[string](data))
    result = readActionSpatialUnitSelectionPoint(ss)


proc fullyQualifiedName*(T: typedesc[ActionSpatialUnitCommand]): string = "ActionSpatialUnitCommand"

proc readActionSpatialUnitCommandImpl(stream: Stream): Message = readActionSpatialUnitCommand(stream)
proc writeActionSpatialUnitCommandImpl(stream: Stream, msg: Message) = writeActionSpatialUnitCommand(stream, ActionSpatialUnitCommand(msg))

proc ActionSpatialUnitCommandProcs*(): MessageProcs =
    result.readImpl = readActionSpatialUnitCommandImpl
    result.writeImpl = writeActionSpatialUnitCommandImpl

proc newActionSpatialUnitCommand*(): ActionSpatialUnitCommand =
    new(result)
    initMessage(result[])
    result.procs = ActionSpatialUnitCommandProcs()
    result.abilityId = 0
    result.queueCommand = false
    result.target = ActionSpatialUnitCommand_target_OneOf(kind: ActionSpatialUnitCommand_target_Kind.NotSet)

proc clearabilityId*(message: ActionSpatialUnitCommand) =
    message.abilityId = 0
    clearFields(message, [1])

proc hasabilityId*(message: ActionSpatialUnitCommand): bool =
    result = hasField(message, 1)

proc setabilityId*(message: ActionSpatialUnitCommand, value: int32) =
    message.abilityId = value
    setField(message, 1)

proc abilityId*(message: ActionSpatialUnitCommand): int32 {.inline.} =
    message.abilityId

proc `abilityId=`*(message: ActionSpatialUnitCommand, value: int32) {.inline.} =
    setabilityId(message, value)

proc cleartargetScreenCoord*(message: ActionSpatialUnitCommand) =
    reset(message.target)
    message.target.kind = ActionSpatialUnitCommand_target_Kind.NotSet
    clearFields(message, [2, 3])

proc hastargetScreenCoord*(message: ActionSpatialUnitCommand): bool =
    result = hasField(message, 2)

proc settargetScreenCoord*(message: ActionSpatialUnitCommand, value: PointI) =
    if message.target.kind != ActionSpatialUnitCommand_target_Kind.TargetScreenCoord:
        message.target = ActionSpatialUnitCommand_target_OneOf(kind: ActionSpatialUnitCommand_target_Kind.TargetScreenCoord, targetScreenCoord: value)
    else:
        message.target.targetScreenCoord = value
    setField(message, 2)
    clearFields(message, [3])

proc targetScreenCoord*(message: ActionSpatialUnitCommand): PointI {.inline.} =
    message.target.targetScreenCoord

proc `targetScreenCoord=`*(message: ActionSpatialUnitCommand, value: PointI) {.inline.} =
    settargetScreenCoord(message, value)

proc cleartargetMinimapCoord*(message: ActionSpatialUnitCommand) =
    reset(message.target)
    message.target.kind = ActionSpatialUnitCommand_target_Kind.NotSet
    clearFields(message, [3, 2])

proc hastargetMinimapCoord*(message: ActionSpatialUnitCommand): bool =
    result = hasField(message, 3)

proc settargetMinimapCoord*(message: ActionSpatialUnitCommand, value: PointI) =
    if message.target.kind != ActionSpatialUnitCommand_target_Kind.TargetMinimapCoord:
        message.target = ActionSpatialUnitCommand_target_OneOf(kind: ActionSpatialUnitCommand_target_Kind.TargetMinimapCoord, targetMinimapCoord: value)
    else:
        message.target.targetMinimapCoord = value
    setField(message, 3)
    clearFields(message, [2])

proc targetMinimapCoord*(message: ActionSpatialUnitCommand): PointI {.inline.} =
    message.target.targetMinimapCoord

proc `targetMinimapCoord=`*(message: ActionSpatialUnitCommand, value: PointI) {.inline.} =
    settargetMinimapCoord(message, value)

proc clearqueueCommand*(message: ActionSpatialUnitCommand) =
    message.queueCommand = false
    clearFields(message, [4])

proc hasqueueCommand*(message: ActionSpatialUnitCommand): bool =
    result = hasField(message, 4)

proc setqueueCommand*(message: ActionSpatialUnitCommand, value: bool) =
    message.queueCommand = value
    setField(message, 4)

proc queueCommand*(message: ActionSpatialUnitCommand): bool {.inline.} =
    message.queueCommand

proc `queueCommand=`*(message: ActionSpatialUnitCommand, value: bool) {.inline.} =
    setqueueCommand(message, value)

proc `$`*(message: ActionSpatialUnitCommand): string =
    runnableExamples:
        echo $ActionSpatialUnitCommand
        echo fmt"{ActionSpatialUnitCommand}"
        echo &"{ActionSpatialUnitCommand}"
    var resultSeq: seq[string]
    if message.hasabilityId:
        resultSeq.add(&"abilityId: {message.abilityId}")
    if message.hasqueueCommand:
        resultSeq.add(&"queueCommand: {message.queueCommand}")
    if message.hastargetScreenCoord:
        resultSeq.add(&"targetScreenCoord: {message.targetScreenCoord}")
    if message.hastargetMinimapCoord:
        resultSeq.add(&"targetMinimapCoord: {message.targetMinimapCoord}")
    result = resultSeq.join(", ")
    result = &"ActionSpatialUnitCommand({result})"

proc sizeOfActionSpatialUnitCommand*(message: ActionSpatialUnitCommand): uint64 =
    if hasabilityId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfInt32(message.abilityId)
    if hastargetScreenCoord(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPointI(message.target.targetScreenCoord))
    if hastargetMinimapCoord(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPointI(message.target.targetMinimapCoord))
    if hasqueueCommand(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfBool(message.queueCommand)
    result = result + sizeOfUnknownFields(message)

proc writeActionSpatialUnitCommand*(stream: Stream, message: ActionSpatialUnitCommand) =
    if hasabilityId(message):
        protoWriteInt32(stream, message.abilityId, 1)
    if hastargetScreenCoord(message):
        writeMessage(stream, message.target.targetScreenCoord, 2)
    if hastargetMinimapCoord(message):
        writeMessage(stream, message.target.targetMinimapCoord, 3)
    if hasqueueCommand(message):
        protoWriteBool(stream, message.queueCommand, 4)
    writeUnknownFields(stream, message)

proc readActionSpatialUnitCommand*(stream: Stream): ActionSpatialUnitCommand =
    result = newActionSpatialUnitCommand()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setabilityId(result, protoReadInt32(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            settargetScreenCoord(result, newPointI(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            settargetMinimapCoord(result, newPointI(data))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setqueueCommand(result, protoReadBool(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionSpatialUnitCommand): string =
    let
        ss = newStringStream()
    writeActionSpatialUnitCommand(ss, message)
    result = ss.data

proc newActionSpatialUnitCommand*(data: string): ActionSpatialUnitCommand =
    let
        ss = newStringStream(data)
    result = readActionSpatialUnitCommand(ss)

proc newActionSpatialUnitCommand*(data: seq[byte]): ActionSpatialUnitCommand =
    let
        ss = newStringStream(cast[string](data))
    result = readActionSpatialUnitCommand(ss)


proc fullyQualifiedName*(T: typedesc[ActionSpatial]): string = "ActionSpatial"

proc readActionSpatialImpl(stream: Stream): Message = readActionSpatial(stream)
proc writeActionSpatialImpl(stream: Stream, msg: Message) = writeActionSpatial(stream, ActionSpatial(msg))

proc ActionSpatialProcs*(): MessageProcs =
    result.readImpl = readActionSpatialImpl
    result.writeImpl = writeActionSpatialImpl

proc newActionSpatial*(): ActionSpatial =
    new(result)
    initMessage(result[])
    result.procs = ActionSpatialProcs()
    result.action = ActionSpatial_action_OneOf(kind: ActionSpatial_action_Kind.NotSet)

proc clearunitCommand*(message: ActionSpatial) =
    reset(message.action)
    message.action.kind = ActionSpatial_action_Kind.NotSet
    clearFields(message, [1, 2, 3, 4])

proc hasunitCommand*(message: ActionSpatial): bool =
    result = hasField(message, 1)

proc setunitCommand*(message: ActionSpatial, value: ActionSpatialUnitCommand) =
    if message.action.kind != ActionSpatial_action_Kind.UnitCommand:
        message.action = ActionSpatial_action_OneOf(kind: ActionSpatial_action_Kind.UnitCommand, unitCommand: value)
    else:
        message.action.unitCommand = value
    setField(message, 1)
    clearFields(message, [2, 3, 4])

proc unitCommand*(message: ActionSpatial): ActionSpatialUnitCommand {.inline.} =
    message.action.unitCommand

proc `unitCommand=`*(message: ActionSpatial, value: ActionSpatialUnitCommand) {.inline.} =
    setunitCommand(message, value)

proc clearcameraMove*(message: ActionSpatial) =
    reset(message.action)
    message.action.kind = ActionSpatial_action_Kind.NotSet
    clearFields(message, [2, 1, 3, 4])

proc hascameraMove*(message: ActionSpatial): bool =
    result = hasField(message, 2)

proc setcameraMove*(message: ActionSpatial, value: ActionSpatialCameraMove) =
    if message.action.kind != ActionSpatial_action_Kind.CameraMove:
        message.action = ActionSpatial_action_OneOf(kind: ActionSpatial_action_Kind.CameraMove, cameraMove: value)
    else:
        message.action.cameraMove = value
    setField(message, 2)
    clearFields(message, [1, 3, 4])

proc cameraMove*(message: ActionSpatial): ActionSpatialCameraMove {.inline.} =
    message.action.cameraMove

proc `cameraMove=`*(message: ActionSpatial, value: ActionSpatialCameraMove) {.inline.} =
    setcameraMove(message, value)

proc clearunitSelectionPoint*(message: ActionSpatial) =
    reset(message.action)
    message.action.kind = ActionSpatial_action_Kind.NotSet
    clearFields(message, [3, 1, 2, 4])

proc hasunitSelectionPoint*(message: ActionSpatial): bool =
    result = hasField(message, 3)

proc setunitSelectionPoint*(message: ActionSpatial, value: ActionSpatialUnitSelectionPoint) =
    if message.action.kind != ActionSpatial_action_Kind.UnitSelectionPoint:
        message.action = ActionSpatial_action_OneOf(kind: ActionSpatial_action_Kind.UnitSelectionPoint, unitSelectionPoint: value)
    else:
        message.action.unitSelectionPoint = value
    setField(message, 3)
    clearFields(message, [1, 2, 4])

proc unitSelectionPoint*(message: ActionSpatial): ActionSpatialUnitSelectionPoint {.inline.} =
    message.action.unitSelectionPoint

proc `unitSelectionPoint=`*(message: ActionSpatial, value: ActionSpatialUnitSelectionPoint) {.inline.} =
    setunitSelectionPoint(message, value)

proc clearunitSelectionRect*(message: ActionSpatial) =
    reset(message.action)
    message.action.kind = ActionSpatial_action_Kind.NotSet
    clearFields(message, [4, 1, 2, 3])

proc hasunitSelectionRect*(message: ActionSpatial): bool =
    result = hasField(message, 4)

proc setunitSelectionRect*(message: ActionSpatial, value: ActionSpatialUnitSelectionRect) =
    if message.action.kind != ActionSpatial_action_Kind.UnitSelectionRect:
        message.action = ActionSpatial_action_OneOf(kind: ActionSpatial_action_Kind.UnitSelectionRect, unitSelectionRect: value)
    else:
        message.action.unitSelectionRect = value
    setField(message, 4)
    clearFields(message, [1, 2, 3])

proc unitSelectionRect*(message: ActionSpatial): ActionSpatialUnitSelectionRect {.inline.} =
    message.action.unitSelectionRect

proc `unitSelectionRect=`*(message: ActionSpatial, value: ActionSpatialUnitSelectionRect) {.inline.} =
    setunitSelectionRect(message, value)

proc `$`*(message: ActionSpatial): string =
    runnableExamples:
        echo $ActionSpatial
        echo fmt"{ActionSpatial}"
        echo &"{ActionSpatial}"
    var resultSeq: seq[string]
    if message.hasunitCommand:
        resultSeq.add(&"unitCommand: {message.unitCommand}")
    if message.hascameraMove:
        resultSeq.add(&"cameraMove: {message.cameraMove}")
    if message.hasunitSelectionPoint:
        resultSeq.add(&"unitSelectionPoint: {message.unitSelectionPoint}")
    if message.hasunitSelectionRect:
        resultSeq.add(&"unitSelectionRect: {message.unitSelectionRect}")
    result = resultSeq.join(", ")
    result = &"ActionSpatial({result})"

proc sizeOfActionSpatial*(message: ActionSpatial): uint64 =
    if hasunitCommand(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionSpatialUnitCommand(message.action.unitCommand))
    if hascameraMove(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionSpatialCameraMove(message.action.cameraMove))
    if hasunitSelectionPoint(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionSpatialUnitSelectionPoint(message.action.unitSelectionPoint))
    if hasunitSelectionRect(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionSpatialUnitSelectionRect(message.action.unitSelectionRect))
    result = result + sizeOfUnknownFields(message)

proc writeActionSpatial*(stream: Stream, message: ActionSpatial) =
    if hasunitCommand(message):
        writeMessage(stream, message.action.unitCommand, 1)
    if hascameraMove(message):
        writeMessage(stream, message.action.cameraMove, 2)
    if hasunitSelectionPoint(message):
        writeMessage(stream, message.action.unitSelectionPoint, 3)
    if hasunitSelectionRect(message):
        writeMessage(stream, message.action.unitSelectionRect, 4)
    writeUnknownFields(stream, message)

proc readActionSpatial*(stream: Stream): ActionSpatial =
    result = newActionSpatial()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunitCommand(result, newActionSpatialUnitCommand(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcameraMove(result, newActionSpatialCameraMove(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunitSelectionPoint(result, newActionSpatialUnitSelectionPoint(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunitSelectionRect(result, newActionSpatialUnitSelectionRect(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionSpatial): string =
    let
        ss = newStringStream()
    writeActionSpatial(ss, message)
    result = ss.data

proc newActionSpatial*(data: string): ActionSpatial =
    let
        ss = newStringStream(data)
    result = readActionSpatial(ss)

proc newActionSpatial*(data: seq[byte]): ActionSpatial =
    let
        ss = newStringStream(cast[string](data))
    result = readActionSpatial(ss)


proc fullyQualifiedName*(T: typedesc[FeatureLayers]): string = "FeatureLayers"

proc readFeatureLayersImpl(stream: Stream): Message = readFeatureLayers(stream)
proc writeFeatureLayersImpl(stream: Stream, msg: Message) = writeFeatureLayers(stream, FeatureLayers(msg))

proc FeatureLayersProcs*(): MessageProcs =
    result.readImpl = readFeatureLayersImpl
    result.writeImpl = writeFeatureLayersImpl

proc newFeatureLayers*(): FeatureLayers =
    new(result)
    initMessage(result[])
    result.procs = FeatureLayersProcs()
    result.heightMap = nil
    result.visibilityMap = nil
    result.creep = nil
    result.power = nil
    result.playerId = nil
    result.unitType = nil
    result.selected = nil
    result.unitHitPoints = nil
    result.unitHitPointsRatio = nil
    result.unitEnergy = nil
    result.unitEnergyRatio = nil
    result.unitShields = nil
    result.unitShieldsRatio = nil
    result.playerRelative = nil
    result.unitDensityAa = nil
    result.unitDensity = nil
    result.effects = nil
    result.hallucinations = nil
    result.cloaked = nil
    result.blip = nil
    result.buffs = nil
    result.buffDuration = nil
    result.active = nil
    result.buildProgress = nil
    result.buildable = nil
    result.pathable = nil
    result.placeholder = nil

proc clearheightMap*(message: FeatureLayers) =
    message.heightMap = nil
    clearFields(message, [1])

proc hasheightMap*(message: FeatureLayers): bool =
    result = hasField(message, 1)

proc setheightMap*(message: FeatureLayers, value: ImageData) =
    message.heightMap = value
    setField(message, 1)

proc heightMap*(message: FeatureLayers): ImageData {.inline.} =
    message.heightMap

proc `heightMap=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setheightMap(message, value)

proc clearvisibilityMap*(message: FeatureLayers) =
    message.visibilityMap = nil
    clearFields(message, [2])

proc hasvisibilityMap*(message: FeatureLayers): bool =
    result = hasField(message, 2)

proc setvisibilityMap*(message: FeatureLayers, value: ImageData) =
    message.visibilityMap = value
    setField(message, 2)

proc visibilityMap*(message: FeatureLayers): ImageData {.inline.} =
    message.visibilityMap

proc `visibilityMap=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setvisibilityMap(message, value)

proc clearcreep*(message: FeatureLayers) =
    message.creep = nil
    clearFields(message, [3])

proc hascreep*(message: FeatureLayers): bool =
    result = hasField(message, 3)

proc setcreep*(message: FeatureLayers, value: ImageData) =
    message.creep = value
    setField(message, 3)

proc creep*(message: FeatureLayers): ImageData {.inline.} =
    message.creep

proc `creep=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setcreep(message, value)

proc clearpower*(message: FeatureLayers) =
    message.power = nil
    clearFields(message, [4])

proc haspower*(message: FeatureLayers): bool =
    result = hasField(message, 4)

proc setpower*(message: FeatureLayers, value: ImageData) =
    message.power = value
    setField(message, 4)

proc power*(message: FeatureLayers): ImageData {.inline.} =
    message.power

proc `power=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setpower(message, value)

proc clearplayerId*(message: FeatureLayers) =
    message.playerId = nil
    clearFields(message, [5])

proc hasplayerId*(message: FeatureLayers): bool =
    result = hasField(message, 5)

proc setplayerId*(message: FeatureLayers, value: ImageData) =
    message.playerId = value
    setField(message, 5)

proc playerId*(message: FeatureLayers): ImageData {.inline.} =
    message.playerId

proc `playerId=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setplayerId(message, value)

proc clearunitType*(message: FeatureLayers) =
    message.unitType = nil
    clearFields(message, [6])

proc hasunitType*(message: FeatureLayers): bool =
    result = hasField(message, 6)

proc setunitType*(message: FeatureLayers, value: ImageData) =
    message.unitType = value
    setField(message, 6)

proc unitType*(message: FeatureLayers): ImageData {.inline.} =
    message.unitType

proc `unitType=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setunitType(message, value)

proc clearselected*(message: FeatureLayers) =
    message.selected = nil
    clearFields(message, [7])

proc hasselected*(message: FeatureLayers): bool =
    result = hasField(message, 7)

proc setselected*(message: FeatureLayers, value: ImageData) =
    message.selected = value
    setField(message, 7)

proc selected*(message: FeatureLayers): ImageData {.inline.} =
    message.selected

proc `selected=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setselected(message, value)

proc clearunitHitPoints*(message: FeatureLayers) =
    message.unitHitPoints = nil
    clearFields(message, [8])

proc hasunitHitPoints*(message: FeatureLayers): bool =
    result = hasField(message, 8)

proc setunitHitPoints*(message: FeatureLayers, value: ImageData) =
    message.unitHitPoints = value
    setField(message, 8)

proc unitHitPoints*(message: FeatureLayers): ImageData {.inline.} =
    message.unitHitPoints

proc `unitHitPoints=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setunitHitPoints(message, value)

proc clearunitHitPointsRatio*(message: FeatureLayers) =
    message.unitHitPointsRatio = nil
    clearFields(message, [17])

proc hasunitHitPointsRatio*(message: FeatureLayers): bool =
    result = hasField(message, 17)

proc setunitHitPointsRatio*(message: FeatureLayers, value: ImageData) =
    message.unitHitPointsRatio = value
    setField(message, 17)

proc unitHitPointsRatio*(message: FeatureLayers): ImageData {.inline.} =
    message.unitHitPointsRatio

proc `unitHitPointsRatio=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setunitHitPointsRatio(message, value)

proc clearunitEnergy*(message: FeatureLayers) =
    message.unitEnergy = nil
    clearFields(message, [9])

proc hasunitEnergy*(message: FeatureLayers): bool =
    result = hasField(message, 9)

proc setunitEnergy*(message: FeatureLayers, value: ImageData) =
    message.unitEnergy = value
    setField(message, 9)

proc unitEnergy*(message: FeatureLayers): ImageData {.inline.} =
    message.unitEnergy

proc `unitEnergy=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setunitEnergy(message, value)

proc clearunitEnergyRatio*(message: FeatureLayers) =
    message.unitEnergyRatio = nil
    clearFields(message, [18])

proc hasunitEnergyRatio*(message: FeatureLayers): bool =
    result = hasField(message, 18)

proc setunitEnergyRatio*(message: FeatureLayers, value: ImageData) =
    message.unitEnergyRatio = value
    setField(message, 18)

proc unitEnergyRatio*(message: FeatureLayers): ImageData {.inline.} =
    message.unitEnergyRatio

proc `unitEnergyRatio=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setunitEnergyRatio(message, value)

proc clearunitShields*(message: FeatureLayers) =
    message.unitShields = nil
    clearFields(message, [10])

proc hasunitShields*(message: FeatureLayers): bool =
    result = hasField(message, 10)

proc setunitShields*(message: FeatureLayers, value: ImageData) =
    message.unitShields = value
    setField(message, 10)

proc unitShields*(message: FeatureLayers): ImageData {.inline.} =
    message.unitShields

proc `unitShields=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setunitShields(message, value)

proc clearunitShieldsRatio*(message: FeatureLayers) =
    message.unitShieldsRatio = nil
    clearFields(message, [19])

proc hasunitShieldsRatio*(message: FeatureLayers): bool =
    result = hasField(message, 19)

proc setunitShieldsRatio*(message: FeatureLayers, value: ImageData) =
    message.unitShieldsRatio = value
    setField(message, 19)

proc unitShieldsRatio*(message: FeatureLayers): ImageData {.inline.} =
    message.unitShieldsRatio

proc `unitShieldsRatio=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setunitShieldsRatio(message, value)

proc clearplayerRelative*(message: FeatureLayers) =
    message.playerRelative = nil
    clearFields(message, [11])

proc hasplayerRelative*(message: FeatureLayers): bool =
    result = hasField(message, 11)

proc setplayerRelative*(message: FeatureLayers, value: ImageData) =
    message.playerRelative = value
    setField(message, 11)

proc playerRelative*(message: FeatureLayers): ImageData {.inline.} =
    message.playerRelative

proc `playerRelative=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setplayerRelative(message, value)

proc clearunitDensityAa*(message: FeatureLayers) =
    message.unitDensityAa = nil
    clearFields(message, [14])

proc hasunitDensityAa*(message: FeatureLayers): bool =
    result = hasField(message, 14)

proc setunitDensityAa*(message: FeatureLayers, value: ImageData) =
    message.unitDensityAa = value
    setField(message, 14)

proc unitDensityAa*(message: FeatureLayers): ImageData {.inline.} =
    message.unitDensityAa

proc `unitDensityAa=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setunitDensityAa(message, value)

proc clearunitDensity*(message: FeatureLayers) =
    message.unitDensity = nil
    clearFields(message, [15])

proc hasunitDensity*(message: FeatureLayers): bool =
    result = hasField(message, 15)

proc setunitDensity*(message: FeatureLayers, value: ImageData) =
    message.unitDensity = value
    setField(message, 15)

proc unitDensity*(message: FeatureLayers): ImageData {.inline.} =
    message.unitDensity

proc `unitDensity=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setunitDensity(message, value)

proc cleareffects*(message: FeatureLayers) =
    message.effects = nil
    clearFields(message, [20])

proc haseffects*(message: FeatureLayers): bool =
    result = hasField(message, 20)

proc seteffects*(message: FeatureLayers, value: ImageData) =
    message.effects = value
    setField(message, 20)

proc effects*(message: FeatureLayers): ImageData {.inline.} =
    message.effects

proc `effects=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    seteffects(message, value)

proc clearhallucinations*(message: FeatureLayers) =
    message.hallucinations = nil
    clearFields(message, [21])

proc hashallucinations*(message: FeatureLayers): bool =
    result = hasField(message, 21)

proc sethallucinations*(message: FeatureLayers, value: ImageData) =
    message.hallucinations = value
    setField(message, 21)

proc hallucinations*(message: FeatureLayers): ImageData {.inline.} =
    message.hallucinations

proc `hallucinations=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    sethallucinations(message, value)

proc clearcloaked*(message: FeatureLayers) =
    message.cloaked = nil
    clearFields(message, [22])

proc hascloaked*(message: FeatureLayers): bool =
    result = hasField(message, 22)

proc setcloaked*(message: FeatureLayers, value: ImageData) =
    message.cloaked = value
    setField(message, 22)

proc cloaked*(message: FeatureLayers): ImageData {.inline.} =
    message.cloaked

proc `cloaked=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setcloaked(message, value)

proc clearblip*(message: FeatureLayers) =
    message.blip = nil
    clearFields(message, [23])

proc hasblip*(message: FeatureLayers): bool =
    result = hasField(message, 23)

proc setblip*(message: FeatureLayers, value: ImageData) =
    message.blip = value
    setField(message, 23)

proc blip*(message: FeatureLayers): ImageData {.inline.} =
    message.blip

proc `blip=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setblip(message, value)

proc clearbuffs*(message: FeatureLayers) =
    message.buffs = nil
    clearFields(message, [24])

proc hasbuffs*(message: FeatureLayers): bool =
    result = hasField(message, 24)

proc setbuffs*(message: FeatureLayers, value: ImageData) =
    message.buffs = value
    setField(message, 24)

proc buffs*(message: FeatureLayers): ImageData {.inline.} =
    message.buffs

proc `buffs=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setbuffs(message, value)

proc clearbuffDuration*(message: FeatureLayers) =
    message.buffDuration = nil
    clearFields(message, [26])

proc hasbuffDuration*(message: FeatureLayers): bool =
    result = hasField(message, 26)

proc setbuffDuration*(message: FeatureLayers, value: ImageData) =
    message.buffDuration = value
    setField(message, 26)

proc buffDuration*(message: FeatureLayers): ImageData {.inline.} =
    message.buffDuration

proc `buffDuration=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setbuffDuration(message, value)

proc clearactive*(message: FeatureLayers) =
    message.active = nil
    clearFields(message, [25])

proc hasactive*(message: FeatureLayers): bool =
    result = hasField(message, 25)

proc setactive*(message: FeatureLayers, value: ImageData) =
    message.active = value
    setField(message, 25)

proc active*(message: FeatureLayers): ImageData {.inline.} =
    message.active

proc `active=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setactive(message, value)

proc clearbuildProgress*(message: FeatureLayers) =
    message.buildProgress = nil
    clearFields(message, [27])

proc hasbuildProgress*(message: FeatureLayers): bool =
    result = hasField(message, 27)

proc setbuildProgress*(message: FeatureLayers, value: ImageData) =
    message.buildProgress = value
    setField(message, 27)

proc buildProgress*(message: FeatureLayers): ImageData {.inline.} =
    message.buildProgress

proc `buildProgress=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setbuildProgress(message, value)

proc clearbuildable*(message: FeatureLayers) =
    message.buildable = nil
    clearFields(message, [28])

proc hasbuildable*(message: FeatureLayers): bool =
    result = hasField(message, 28)

proc setbuildable*(message: FeatureLayers, value: ImageData) =
    message.buildable = value
    setField(message, 28)

proc buildable*(message: FeatureLayers): ImageData {.inline.} =
    message.buildable

proc `buildable=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setbuildable(message, value)

proc clearpathable*(message: FeatureLayers) =
    message.pathable = nil
    clearFields(message, [29])

proc haspathable*(message: FeatureLayers): bool =
    result = hasField(message, 29)

proc setpathable*(message: FeatureLayers, value: ImageData) =
    message.pathable = value
    setField(message, 29)

proc pathable*(message: FeatureLayers): ImageData {.inline.} =
    message.pathable

proc `pathable=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setpathable(message, value)

proc clearplaceholder*(message: FeatureLayers) =
    message.placeholder = nil
    clearFields(message, [30])

proc hasplaceholder*(message: FeatureLayers): bool =
    result = hasField(message, 30)

proc setplaceholder*(message: FeatureLayers, value: ImageData) =
    message.placeholder = value
    setField(message, 30)

proc placeholder*(message: FeatureLayers): ImageData {.inline.} =
    message.placeholder

proc `placeholder=`*(message: FeatureLayers, value: ImageData) {.inline.} =
    setplaceholder(message, value)

proc `$`*(message: FeatureLayers): string =
    runnableExamples:
        echo $FeatureLayers
        echo fmt"{FeatureLayers}"
        echo &"{FeatureLayers}"
    var resultSeq: seq[string]
    if message.hasheightMap:
        resultSeq.add(&"heightMap: {message.heightMap}")
    if message.hasvisibilityMap:
        resultSeq.add(&"visibilityMap: {message.visibilityMap}")
    if message.hascreep:
        resultSeq.add(&"creep: {message.creep}")
    if message.haspower:
        resultSeq.add(&"power: {message.power}")
    if message.hasplayerId:
        resultSeq.add(&"playerId: {message.playerId}")
    if message.hasunitType:
        resultSeq.add(&"unitType: {message.unitType}")
    if message.hasselected:
        resultSeq.add(&"selected: {message.selected}")
    if message.hasunitHitPoints:
        resultSeq.add(&"unitHitPoints: {message.unitHitPoints}")
    if message.hasunitHitPointsRatio:
        resultSeq.add(&"unitHitPointsRatio: {message.unitHitPointsRatio}")
    if message.hasunitEnergy:
        resultSeq.add(&"unitEnergy: {message.unitEnergy}")
    if message.hasunitEnergyRatio:
        resultSeq.add(&"unitEnergyRatio: {message.unitEnergyRatio}")
    if message.hasunitShields:
        resultSeq.add(&"unitShields: {message.unitShields}")
    if message.hasunitShieldsRatio:
        resultSeq.add(&"unitShieldsRatio: {message.unitShieldsRatio}")
    if message.hasplayerRelative:
        resultSeq.add(&"playerRelative: {message.playerRelative}")
    if message.hasunitDensityAa:
        resultSeq.add(&"unitDensityAa: {message.unitDensityAa}")
    if message.hasunitDensity:
        resultSeq.add(&"unitDensity: {message.unitDensity}")
    if message.haseffects:
        resultSeq.add(&"effects: {message.effects}")
    if message.hashallucinations:
        resultSeq.add(&"hallucinations: {message.hallucinations}")
    if message.hascloaked:
        resultSeq.add(&"cloaked: {message.cloaked}")
    if message.hasblip:
        resultSeq.add(&"blip: {message.blip}")
    if message.hasbuffs:
        resultSeq.add(&"buffs: {message.buffs}")
    if message.hasbuffDuration:
        resultSeq.add(&"buffDuration: {message.buffDuration}")
    if message.hasactive:
        resultSeq.add(&"active: {message.active}")
    if message.hasbuildProgress:
        resultSeq.add(&"buildProgress: {message.buildProgress}")
    if message.hasbuildable:
        resultSeq.add(&"buildable: {message.buildable}")
    if message.haspathable:
        resultSeq.add(&"pathable: {message.pathable}")
    if message.hasplaceholder:
        resultSeq.add(&"placeholder: {message.placeholder}")
    result = resultSeq.join(", ")
    result = &"FeatureLayers({result})"

proc sizeOfFeatureLayers*(message: FeatureLayers): uint64 =
    if hasheightMap(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.heightMap))
    if hasvisibilityMap(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.visibilityMap))
    if hascreep(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.creep))
    if haspower(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.power))
    if hasplayerId(message):
        result = result + sizeOfTag(5, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.playerId))
    if hasunitType(message):
        result = result + sizeOfTag(6, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.unitType))
    if hasselected(message):
        result = result + sizeOfTag(7, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.selected))
    if hasunitHitPoints(message):
        result = result + sizeOfTag(8, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.unitHitPoints))
    if hasunitHitPointsRatio(message):
        result = result + sizeOfTag(17, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.unitHitPointsRatio))
    if hasunitEnergy(message):
        result = result + sizeOfTag(9, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.unitEnergy))
    if hasunitEnergyRatio(message):
        result = result + sizeOfTag(18, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.unitEnergyRatio))
    if hasunitShields(message):
        result = result + sizeOfTag(10, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.unitShields))
    if hasunitShieldsRatio(message):
        result = result + sizeOfTag(19, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.unitShieldsRatio))
    if hasplayerRelative(message):
        result = result + sizeOfTag(11, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.playerRelative))
    if hasunitDensityAa(message):
        result = result + sizeOfTag(14, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.unitDensityAa))
    if hasunitDensity(message):
        result = result + sizeOfTag(15, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.unitDensity))
    if haseffects(message):
        result = result + sizeOfTag(20, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.effects))
    if hashallucinations(message):
        result = result + sizeOfTag(21, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.hallucinations))
    if hascloaked(message):
        result = result + sizeOfTag(22, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.cloaked))
    if hasblip(message):
        result = result + sizeOfTag(23, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.blip))
    if hasbuffs(message):
        result = result + sizeOfTag(24, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.buffs))
    if hasbuffDuration(message):
        result = result + sizeOfTag(26, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.buffDuration))
    if hasactive(message):
        result = result + sizeOfTag(25, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.active))
    if hasbuildProgress(message):
        result = result + sizeOfTag(27, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.buildProgress))
    if hasbuildable(message):
        result = result + sizeOfTag(28, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.buildable))
    if haspathable(message):
        result = result + sizeOfTag(29, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.pathable))
    if hasplaceholder(message):
        result = result + sizeOfTag(30, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.placeholder))
    result = result + sizeOfUnknownFields(message)

proc writeFeatureLayers*(stream: Stream, message: FeatureLayers) =
    if hasheightMap(message):
        writeMessage(stream, message.heightMap, 1)
    if hasvisibilityMap(message):
        writeMessage(stream, message.visibilityMap, 2)
    if hascreep(message):
        writeMessage(stream, message.creep, 3)
    if haspower(message):
        writeMessage(stream, message.power, 4)
    if hasplayerId(message):
        writeMessage(stream, message.playerId, 5)
    if hasunitType(message):
        writeMessage(stream, message.unitType, 6)
    if hasselected(message):
        writeMessage(stream, message.selected, 7)
    if hasunitHitPoints(message):
        writeMessage(stream, message.unitHitPoints, 8)
    if hasunitHitPointsRatio(message):
        writeMessage(stream, message.unitHitPointsRatio, 17)
    if hasunitEnergy(message):
        writeMessage(stream, message.unitEnergy, 9)
    if hasunitEnergyRatio(message):
        writeMessage(stream, message.unitEnergyRatio, 18)
    if hasunitShields(message):
        writeMessage(stream, message.unitShields, 10)
    if hasunitShieldsRatio(message):
        writeMessage(stream, message.unitShieldsRatio, 19)
    if hasplayerRelative(message):
        writeMessage(stream, message.playerRelative, 11)
    if hasunitDensityAa(message):
        writeMessage(stream, message.unitDensityAa, 14)
    if hasunitDensity(message):
        writeMessage(stream, message.unitDensity, 15)
    if haseffects(message):
        writeMessage(stream, message.effects, 20)
    if hashallucinations(message):
        writeMessage(stream, message.hallucinations, 21)
    if hascloaked(message):
        writeMessage(stream, message.cloaked, 22)
    if hasblip(message):
        writeMessage(stream, message.blip, 23)
    if hasbuffs(message):
        writeMessage(stream, message.buffs, 24)
    if hasbuffDuration(message):
        writeMessage(stream, message.buffDuration, 26)
    if hasactive(message):
        writeMessage(stream, message.active, 25)
    if hasbuildProgress(message):
        writeMessage(stream, message.buildProgress, 27)
    if hasbuildable(message):
        writeMessage(stream, message.buildable, 28)
    if haspathable(message):
        writeMessage(stream, message.pathable, 29)
    if hasplaceholder(message):
        writeMessage(stream, message.placeholder, 30)
    writeUnknownFields(stream, message)

proc readFeatureLayers*(stream: Stream): FeatureLayers =
    result = newFeatureLayers()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setheightMap(result, newImageData(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setvisibilityMap(result, newImageData(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcreep(result, newImageData(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setpower(result, newImageData(data))
        of 5:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setplayerId(result, newImageData(data))
        of 6:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunitType(result, newImageData(data))
        of 7:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setselected(result, newImageData(data))
        of 8:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunitHitPoints(result, newImageData(data))
        of 17:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunitHitPointsRatio(result, newImageData(data))
        of 9:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunitEnergy(result, newImageData(data))
        of 18:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunitEnergyRatio(result, newImageData(data))
        of 10:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunitShields(result, newImageData(data))
        of 19:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunitShieldsRatio(result, newImageData(data))
        of 11:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setplayerRelative(result, newImageData(data))
        of 14:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunitDensityAa(result, newImageData(data))
        of 15:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunitDensity(result, newImageData(data))
        of 20:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            seteffects(result, newImageData(data))
        of 21:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            sethallucinations(result, newImageData(data))
        of 22:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcloaked(result, newImageData(data))
        of 23:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setblip(result, newImageData(data))
        of 24:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setbuffs(result, newImageData(data))
        of 26:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setbuffDuration(result, newImageData(data))
        of 25:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setactive(result, newImageData(data))
        of 27:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setbuildProgress(result, newImageData(data))
        of 28:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setbuildable(result, newImageData(data))
        of 29:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setpathable(result, newImageData(data))
        of 30:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setplaceholder(result, newImageData(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: FeatureLayers): string =
    let
        ss = newStringStream()
    writeFeatureLayers(ss, message)
    result = ss.data

proc newFeatureLayers*(data: string): FeatureLayers =
    let
        ss = newStringStream(data)
    result = readFeatureLayers(ss)

proc newFeatureLayers*(data: seq[byte]): FeatureLayers =
    let
        ss = newStringStream(cast[string](data))
    result = readFeatureLayers(ss)


proc fullyQualifiedName*(T: typedesc[ObservationRender]): string = "ObservationRender"

proc readObservationRenderImpl(stream: Stream): Message = readObservationRender(stream)
proc writeObservationRenderImpl(stream: Stream, msg: Message) = writeObservationRender(stream, ObservationRender(msg))

proc ObservationRenderProcs*(): MessageProcs =
    result.readImpl = readObservationRenderImpl
    result.writeImpl = writeObservationRenderImpl

proc newObservationRender*(): ObservationRender =
    new(result)
    initMessage(result[])
    result.procs = ObservationRenderProcs()
    result.map = nil
    result.minimap = nil

proc clearmap*(message: ObservationRender) =
    message.map = nil
    clearFields(message, [1])

proc hasmap*(message: ObservationRender): bool =
    result = hasField(message, 1)

proc setmap*(message: ObservationRender, value: ImageData) =
    message.map = value
    setField(message, 1)

proc map*(message: ObservationRender): ImageData {.inline.} =
    message.map

proc `map=`*(message: ObservationRender, value: ImageData) {.inline.} =
    setmap(message, value)

proc clearminimap*(message: ObservationRender) =
    message.minimap = nil
    clearFields(message, [2])

proc hasminimap*(message: ObservationRender): bool =
    result = hasField(message, 2)

proc setminimap*(message: ObservationRender, value: ImageData) =
    message.minimap = value
    setField(message, 2)

proc minimap*(message: ObservationRender): ImageData {.inline.} =
    message.minimap

proc `minimap=`*(message: ObservationRender, value: ImageData) {.inline.} =
    setminimap(message, value)

proc `$`*(message: ObservationRender): string =
    runnableExamples:
        echo $ObservationRender
        echo fmt"{ObservationRender}"
        echo &"{ObservationRender}"
    var resultSeq: seq[string]
    if message.hasmap:
        resultSeq.add(&"map: {message.map}")
    if message.hasminimap:
        resultSeq.add(&"minimap: {message.minimap}")
    result = resultSeq.join(", ")
    result = &"ObservationRender({result})"

proc sizeOfObservationRender*(message: ObservationRender): uint64 =
    if hasmap(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.map))
    if hasminimap(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.minimap))
    result = result + sizeOfUnknownFields(message)

proc writeObservationRender*(stream: Stream, message: ObservationRender) =
    if hasmap(message):
        writeMessage(stream, message.map, 1)
    if hasminimap(message):
        writeMessage(stream, message.minimap, 2)
    writeUnknownFields(stream, message)

proc readObservationRender*(stream: Stream): ObservationRender =
    result = newObservationRender()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setmap(result, newImageData(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setminimap(result, newImageData(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ObservationRender): string =
    let
        ss = newStringStream()
    writeObservationRender(ss, message)
    result = ss.data

proc newObservationRender*(data: string): ObservationRender =
    let
        ss = newStringStream(data)
    result = readObservationRender(ss)

proc newObservationRender*(data: seq[byte]): ObservationRender =
    let
        ss = newStringStream(cast[string](data))
    result = readObservationRender(ss)


proc fullyQualifiedName*(T: typedesc[FeatureLayersMinimap]): string = "FeatureLayersMinimap"

proc readFeatureLayersMinimapImpl(stream: Stream): Message = readFeatureLayersMinimap(stream)
proc writeFeatureLayersMinimapImpl(stream: Stream, msg: Message) = writeFeatureLayersMinimap(stream, FeatureLayersMinimap(msg))

proc FeatureLayersMinimapProcs*(): MessageProcs =
    result.readImpl = readFeatureLayersMinimapImpl
    result.writeImpl = writeFeatureLayersMinimapImpl

proc newFeatureLayersMinimap*(): FeatureLayersMinimap =
    new(result)
    initMessage(result[])
    result.procs = FeatureLayersMinimapProcs()
    result.heightMap = nil
    result.visibilityMap = nil
    result.creep = nil
    result.camera = nil
    result.playerId = nil
    result.playerRelative = nil
    result.selected = nil
    result.alerts = nil
    result.buildable = nil
    result.pathable = nil
    result.unitType = nil

proc clearheightMap*(message: FeatureLayersMinimap) =
    message.heightMap = nil
    clearFields(message, [1])

proc hasheightMap*(message: FeatureLayersMinimap): bool =
    result = hasField(message, 1)

proc setheightMap*(message: FeatureLayersMinimap, value: ImageData) =
    message.heightMap = value
    setField(message, 1)

proc heightMap*(message: FeatureLayersMinimap): ImageData {.inline.} =
    message.heightMap

proc `heightMap=`*(message: FeatureLayersMinimap, value: ImageData) {.inline.} =
    setheightMap(message, value)

proc clearvisibilityMap*(message: FeatureLayersMinimap) =
    message.visibilityMap = nil
    clearFields(message, [2])

proc hasvisibilityMap*(message: FeatureLayersMinimap): bool =
    result = hasField(message, 2)

proc setvisibilityMap*(message: FeatureLayersMinimap, value: ImageData) =
    message.visibilityMap = value
    setField(message, 2)

proc visibilityMap*(message: FeatureLayersMinimap): ImageData {.inline.} =
    message.visibilityMap

proc `visibilityMap=`*(message: FeatureLayersMinimap, value: ImageData) {.inline.} =
    setvisibilityMap(message, value)

proc clearcreep*(message: FeatureLayersMinimap) =
    message.creep = nil
    clearFields(message, [3])

proc hascreep*(message: FeatureLayersMinimap): bool =
    result = hasField(message, 3)

proc setcreep*(message: FeatureLayersMinimap, value: ImageData) =
    message.creep = value
    setField(message, 3)

proc creep*(message: FeatureLayersMinimap): ImageData {.inline.} =
    message.creep

proc `creep=`*(message: FeatureLayersMinimap, value: ImageData) {.inline.} =
    setcreep(message, value)

proc clearcamera*(message: FeatureLayersMinimap) =
    message.camera = nil
    clearFields(message, [4])

proc hascamera*(message: FeatureLayersMinimap): bool =
    result = hasField(message, 4)

proc setcamera*(message: FeatureLayersMinimap, value: ImageData) =
    message.camera = value
    setField(message, 4)

proc camera*(message: FeatureLayersMinimap): ImageData {.inline.} =
    message.camera

proc `camera=`*(message: FeatureLayersMinimap, value: ImageData) {.inline.} =
    setcamera(message, value)

proc clearplayerId*(message: FeatureLayersMinimap) =
    message.playerId = nil
    clearFields(message, [5])

proc hasplayerId*(message: FeatureLayersMinimap): bool =
    result = hasField(message, 5)

proc setplayerId*(message: FeatureLayersMinimap, value: ImageData) =
    message.playerId = value
    setField(message, 5)

proc playerId*(message: FeatureLayersMinimap): ImageData {.inline.} =
    message.playerId

proc `playerId=`*(message: FeatureLayersMinimap, value: ImageData) {.inline.} =
    setplayerId(message, value)

proc clearplayerRelative*(message: FeatureLayersMinimap) =
    message.playerRelative = nil
    clearFields(message, [6])

proc hasplayerRelative*(message: FeatureLayersMinimap): bool =
    result = hasField(message, 6)

proc setplayerRelative*(message: FeatureLayersMinimap, value: ImageData) =
    message.playerRelative = value
    setField(message, 6)

proc playerRelative*(message: FeatureLayersMinimap): ImageData {.inline.} =
    message.playerRelative

proc `playerRelative=`*(message: FeatureLayersMinimap, value: ImageData) {.inline.} =
    setplayerRelative(message, value)

proc clearselected*(message: FeatureLayersMinimap) =
    message.selected = nil
    clearFields(message, [7])

proc hasselected*(message: FeatureLayersMinimap): bool =
    result = hasField(message, 7)

proc setselected*(message: FeatureLayersMinimap, value: ImageData) =
    message.selected = value
    setField(message, 7)

proc selected*(message: FeatureLayersMinimap): ImageData {.inline.} =
    message.selected

proc `selected=`*(message: FeatureLayersMinimap, value: ImageData) {.inline.} =
    setselected(message, value)

proc clearalerts*(message: FeatureLayersMinimap) =
    message.alerts = nil
    clearFields(message, [9])

proc hasalerts*(message: FeatureLayersMinimap): bool =
    result = hasField(message, 9)

proc setalerts*(message: FeatureLayersMinimap, value: ImageData) =
    message.alerts = value
    setField(message, 9)

proc alerts*(message: FeatureLayersMinimap): ImageData {.inline.} =
    message.alerts

proc `alerts=`*(message: FeatureLayersMinimap, value: ImageData) {.inline.} =
    setalerts(message, value)

proc clearbuildable*(message: FeatureLayersMinimap) =
    message.buildable = nil
    clearFields(message, [10])

proc hasbuildable*(message: FeatureLayersMinimap): bool =
    result = hasField(message, 10)

proc setbuildable*(message: FeatureLayersMinimap, value: ImageData) =
    message.buildable = value
    setField(message, 10)

proc buildable*(message: FeatureLayersMinimap): ImageData {.inline.} =
    message.buildable

proc `buildable=`*(message: FeatureLayersMinimap, value: ImageData) {.inline.} =
    setbuildable(message, value)

proc clearpathable*(message: FeatureLayersMinimap) =
    message.pathable = nil
    clearFields(message, [11])

proc haspathable*(message: FeatureLayersMinimap): bool =
    result = hasField(message, 11)

proc setpathable*(message: FeatureLayersMinimap, value: ImageData) =
    message.pathable = value
    setField(message, 11)

proc pathable*(message: FeatureLayersMinimap): ImageData {.inline.} =
    message.pathable

proc `pathable=`*(message: FeatureLayersMinimap, value: ImageData) {.inline.} =
    setpathable(message, value)

proc clearunitType*(message: FeatureLayersMinimap) =
    message.unitType = nil
    clearFields(message, [8])

proc hasunitType*(message: FeatureLayersMinimap): bool =
    result = hasField(message, 8)

proc setunitType*(message: FeatureLayersMinimap, value: ImageData) =
    message.unitType = value
    setField(message, 8)

proc unitType*(message: FeatureLayersMinimap): ImageData {.inline.} =
    message.unitType

proc `unitType=`*(message: FeatureLayersMinimap, value: ImageData) {.inline.} =
    setunitType(message, value)

proc `$`*(message: FeatureLayersMinimap): string =
    runnableExamples:
        echo $FeatureLayersMinimap
        echo fmt"{FeatureLayersMinimap}"
        echo &"{FeatureLayersMinimap}"
    var resultSeq: seq[string]
    if message.hasheightMap:
        resultSeq.add(&"heightMap: {message.heightMap}")
    if message.hasvisibilityMap:
        resultSeq.add(&"visibilityMap: {message.visibilityMap}")
    if message.hascreep:
        resultSeq.add(&"creep: {message.creep}")
    if message.hascamera:
        resultSeq.add(&"camera: {message.camera}")
    if message.hasplayerId:
        resultSeq.add(&"playerId: {message.playerId}")
    if message.hasplayerRelative:
        resultSeq.add(&"playerRelative: {message.playerRelative}")
    if message.hasselected:
        resultSeq.add(&"selected: {message.selected}")
    if message.hasalerts:
        resultSeq.add(&"alerts: {message.alerts}")
    if message.hasbuildable:
        resultSeq.add(&"buildable: {message.buildable}")
    if message.haspathable:
        resultSeq.add(&"pathable: {message.pathable}")
    if message.hasunitType:
        resultSeq.add(&"unitType: {message.unitType}")
    result = resultSeq.join(", ")
    result = &"FeatureLayersMinimap({result})"

proc sizeOfFeatureLayersMinimap*(message: FeatureLayersMinimap): uint64 =
    if hasheightMap(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.heightMap))
    if hasvisibilityMap(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.visibilityMap))
    if hascreep(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.creep))
    if hascamera(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.camera))
    if hasplayerId(message):
        result = result + sizeOfTag(5, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.playerId))
    if hasplayerRelative(message):
        result = result + sizeOfTag(6, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.playerRelative))
    if hasselected(message):
        result = result + sizeOfTag(7, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.selected))
    if hasalerts(message):
        result = result + sizeOfTag(9, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.alerts))
    if hasbuildable(message):
        result = result + sizeOfTag(10, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.buildable))
    if haspathable(message):
        result = result + sizeOfTag(11, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.pathable))
    if hasunitType(message):
        result = result + sizeOfTag(8, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.unitType))
    result = result + sizeOfUnknownFields(message)

proc writeFeatureLayersMinimap*(stream: Stream, message: FeatureLayersMinimap) =
    if hasheightMap(message):
        writeMessage(stream, message.heightMap, 1)
    if hasvisibilityMap(message):
        writeMessage(stream, message.visibilityMap, 2)
    if hascreep(message):
        writeMessage(stream, message.creep, 3)
    if hascamera(message):
        writeMessage(stream, message.camera, 4)
    if hasplayerId(message):
        writeMessage(stream, message.playerId, 5)
    if hasplayerRelative(message):
        writeMessage(stream, message.playerRelative, 6)
    if hasselected(message):
        writeMessage(stream, message.selected, 7)
    if hasalerts(message):
        writeMessage(stream, message.alerts, 9)
    if hasbuildable(message):
        writeMessage(stream, message.buildable, 10)
    if haspathable(message):
        writeMessage(stream, message.pathable, 11)
    if hasunitType(message):
        writeMessage(stream, message.unitType, 8)
    writeUnknownFields(stream, message)

proc readFeatureLayersMinimap*(stream: Stream): FeatureLayersMinimap =
    result = newFeatureLayersMinimap()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setheightMap(result, newImageData(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setvisibilityMap(result, newImageData(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcreep(result, newImageData(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcamera(result, newImageData(data))
        of 5:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setplayerId(result, newImageData(data))
        of 6:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setplayerRelative(result, newImageData(data))
        of 7:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setselected(result, newImageData(data))
        of 9:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setalerts(result, newImageData(data))
        of 10:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setbuildable(result, newImageData(data))
        of 11:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setpathable(result, newImageData(data))
        of 8:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunitType(result, newImageData(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: FeatureLayersMinimap): string =
    let
        ss = newStringStream()
    writeFeatureLayersMinimap(ss, message)
    result = ss.data

proc newFeatureLayersMinimap*(data: string): FeatureLayersMinimap =
    let
        ss = newStringStream(data)
    result = readFeatureLayersMinimap(ss)

proc newFeatureLayersMinimap*(data: seq[byte]): FeatureLayersMinimap =
    let
        ss = newStringStream(cast[string](data))
    result = readFeatureLayersMinimap(ss)


proc fullyQualifiedName*(T: typedesc[ObservationFeatureLayer]): string = "ObservationFeatureLayer"

proc readObservationFeatureLayerImpl(stream: Stream): Message = readObservationFeatureLayer(stream)
proc writeObservationFeatureLayerImpl(stream: Stream, msg: Message) = writeObservationFeatureLayer(stream, ObservationFeatureLayer(msg))

proc ObservationFeatureLayerProcs*(): MessageProcs =
    result.readImpl = readObservationFeatureLayerImpl
    result.writeImpl = writeObservationFeatureLayerImpl

proc newObservationFeatureLayer*(): ObservationFeatureLayer =
    new(result)
    initMessage(result[])
    result.procs = ObservationFeatureLayerProcs()
    result.renders = nil
    result.minimapRenders = nil

proc clearrenders*(message: ObservationFeatureLayer) =
    message.renders = nil
    clearFields(message, [1])

proc hasrenders*(message: ObservationFeatureLayer): bool =
    result = hasField(message, 1)

proc setrenders*(message: ObservationFeatureLayer, value: FeatureLayers) =
    message.renders = value
    setField(message, 1)

proc renders*(message: ObservationFeatureLayer): FeatureLayers {.inline.} =
    message.renders

proc `renders=`*(message: ObservationFeatureLayer, value: FeatureLayers) {.inline.} =
    setrenders(message, value)

proc clearminimapRenders*(message: ObservationFeatureLayer) =
    message.minimapRenders = nil
    clearFields(message, [2])

proc hasminimapRenders*(message: ObservationFeatureLayer): bool =
    result = hasField(message, 2)

proc setminimapRenders*(message: ObservationFeatureLayer, value: FeatureLayersMinimap) =
    message.minimapRenders = value
    setField(message, 2)

proc minimapRenders*(message: ObservationFeatureLayer): FeatureLayersMinimap {.inline.} =
    message.minimapRenders

proc `minimapRenders=`*(message: ObservationFeatureLayer, value: FeatureLayersMinimap) {.inline.} =
    setminimapRenders(message, value)

proc `$`*(message: ObservationFeatureLayer): string =
    runnableExamples:
        echo $ObservationFeatureLayer
        echo fmt"{ObservationFeatureLayer}"
        echo &"{ObservationFeatureLayer}"
    var resultSeq: seq[string]
    if message.hasrenders:
        resultSeq.add(&"renders: {message.renders}")
    if message.hasminimapRenders:
        resultSeq.add(&"minimapRenders: {message.minimapRenders}")
    result = resultSeq.join(", ")
    result = &"ObservationFeatureLayer({result})"

proc sizeOfObservationFeatureLayer*(message: ObservationFeatureLayer): uint64 =
    if hasrenders(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfFeatureLayers(message.renders))
    if hasminimapRenders(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfFeatureLayersMinimap(message.minimapRenders))
    result = result + sizeOfUnknownFields(message)

proc writeObservationFeatureLayer*(stream: Stream, message: ObservationFeatureLayer) =
    if hasrenders(message):
        writeMessage(stream, message.renders, 1)
    if hasminimapRenders(message):
        writeMessage(stream, message.minimapRenders, 2)
    writeUnknownFields(stream, message)

proc readObservationFeatureLayer*(stream: Stream): ObservationFeatureLayer =
    result = newObservationFeatureLayer()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setrenders(result, newFeatureLayers(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setminimapRenders(result, newFeatureLayersMinimap(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ObservationFeatureLayer): string =
    let
        ss = newStringStream()
    writeObservationFeatureLayer(ss, message)
    result = ss.data

proc newObservationFeatureLayer*(data: string): ObservationFeatureLayer =
    let
        ss = newStringStream(data)
    result = readObservationFeatureLayer(ss)

proc newObservationFeatureLayer*(data: seq[byte]): ObservationFeatureLayer =
    let
        ss = newStringStream(cast[string](data))
    result = readObservationFeatureLayer(ss)


