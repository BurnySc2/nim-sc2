# Generated by protoc_gen_nim. Do not edit!

import base64
import intsets
import json
import strutils
import strformat

import nimpb/nimpb
import nimpb/json as nimpb_json

import common_pb

type
    DisplayType* {.pure.} = enum
        Visible = 1
        Snapshot = 2
        Hidden = 3
        Placeholder = 4
    Alliance* {.pure.} = enum
        Self = 1
        Ally = 2
        Neutral = 3
        Enemy = 4
    CloakState* {.pure.} = enum
        CloakedUnknown = 0
        Cloaked = 1
        CloakedDetected = 2
        NotCloaked = 3
        CloakedAllied = 4
    StartRaw* = ref StartRawObj
    StartRawObj* = object of Message
        mapSize: Size2DI
        pathingGrid: ImageData
        terrainHeight: ImageData
        placementGrid: ImageData
        playableArea: RectangleI
        startLocations: seq[Point2D]
    ObservationRaw* = ref ObservationRawObj
    ObservationRawObj* = object of Message
        player: PlayerRaw
        units: seq[Unit]
        mapState: MapState
        event: Event
        effects: seq[Effect]
        radar: seq[RadarRing]
    RadarRing* = ref RadarRingObj
    RadarRingObj* = object of Message
        pos: Point
        radius: float32
    PowerSource* = ref PowerSourceObj
    PowerSourceObj* = object of Message
        pos: Point
        radius: float32
        tag: uint64
    PlayerRaw* = ref PlayerRawObj
    PlayerRawObj* = object of Message
        powerSources: seq[PowerSource]
        camera: Point
        upgradeIds: seq[uint32]
    UnitOrder* = ref UnitOrderObj
    UnitOrderObj* = object of Message
        abilityId: uint32
        progress: float32
        target: UnitOrder_target_OneOf

    UnitOrder_target_Kind* {.pure.} = enum
        TargetWorldSpacePos
        TargetUnitTag
        NotSet

    UnitOrder_target_OneOf* = object
        case kind*: UnitOrder_target_Kind
        of UnitOrder_target_Kind.TargetWorldSpacePos: targetWorldSpacePos*: Point
        of UnitOrder_target_Kind.TargetUnitTag: targetUnitTag*: uint64
        of UnitOrder_target_Kind.NotSet: nil
    PassengerUnit* = ref PassengerUnitObj
    PassengerUnitObj* = object of Message
        tag: uint64
        health: float32
        healthMax: float32
        shield: float32
        shieldMax: float32
        energy: float32
        energyMax: float32
        unitType: uint32
    RallyTarget* = ref RallyTargetObj
    RallyTargetObj* = object of Message
        point: Point
        tag: uint64
    Unit* = ref UnitObj
    UnitObj* = object of Message
        displayType: DisplayType
        alliance: Alliance
        tag: uint64
        unitType: uint32
        owner: int32
        pos: Point
        facing: float32
        radius: float32
        buildProgress: float32
        cloak: CloakState
        buffIds: seq[uint32]
        detectRange: float32
        radarRange: float32
        isSelected: bool
        isOnScreen: bool
        isBlip: bool
        isPowered: bool
        isActive: bool
        attackUpgradeLevel: int32
        armorUpgradeLevel: int32
        shieldUpgradeLevel: int32
        health: float32
        healthMax: float32
        shield: float32
        shieldMax: float32
        energy: float32
        energyMax: float32
        mineralContents: int32
        vespeneContents: int32
        isFlying: bool
        isBurrowed: bool
        isHallucination: bool
        orders: seq[UnitOrder]
        addOnTag: uint64
        passengers: seq[PassengerUnit]
        cargoSpaceTaken: int32
        cargoSpaceMax: int32
        assignedHarvesters: int32
        idealHarvesters: int32
        weaponCooldown: float32
        engagedTargetTag: uint64
        buffDurationRemain: int32
        buffDurationMax: int32
        rallyTargets: seq[RallyTarget]
    MapState* = ref MapStateObj
    MapStateObj* = object of Message
        visibility: ImageData
        creep: ImageData
    Event* = ref EventObj
    EventObj* = object of Message
        deadUnits: seq[uint64]
    Effect* = ref EffectObj
    EffectObj* = object of Message
        effectId: uint32
        pos: seq[Point2D]
        alliance: Alliance
        owner: int32
        radius: float32
    ActionRaw* = ref ActionRawObj
    ActionRawObj* = object of Message
        action: ActionRaw_action_OneOf

    ActionRaw_action_Kind* {.pure.} = enum
        UnitCommand
        CameraMove
        ToggleAutocast
        NotSet

    ActionRaw_action_OneOf* = object
        case kind*: ActionRaw_action_Kind
        of ActionRaw_action_Kind.UnitCommand: unitCommand*: ActionRawUnitCommand
        of ActionRaw_action_Kind.CameraMove: cameraMove*: ActionRawCameraMove
        of ActionRaw_action_Kind.ToggleAutocast: toggleAutocast*: ActionRawToggleAutocast
        of ActionRaw_action_Kind.NotSet: nil
    ActionRawUnitCommand* = ref ActionRawUnitCommandObj
    ActionRawUnitCommandObj* = object of Message
        abilityId: int32
        unitTags: seq[uint64]
        queueCommand: bool
        target: ActionRawUnitCommand_target_OneOf

    ActionRawUnitCommand_target_Kind* {.pure.} = enum
        TargetWorldSpacePos
        TargetUnitTag
        NotSet

    ActionRawUnitCommand_target_OneOf* = object
        case kind*: ActionRawUnitCommand_target_Kind
        of ActionRawUnitCommand_target_Kind.TargetWorldSpacePos: targetWorldSpacePos*: Point2D
        of ActionRawUnitCommand_target_Kind.TargetUnitTag: targetUnitTag*: uint64
        of ActionRawUnitCommand_target_Kind.NotSet: nil
    ActionRawCameraMove* = ref ActionRawCameraMoveObj
    ActionRawCameraMoveObj* = object of Message
        centerWorldSpace: Point
    ActionRawToggleAutocast* = ref ActionRawToggleAutocastObj
    ActionRawToggleAutocastObj* = object of Message
        abilityId: int32
        unitTags: seq[uint64]

proc newEvent*(): Event
proc newEvent*(data: string): Event
proc newEvent*(data: seq[byte]): Event
proc writeEvent*(stream: Stream, message: Event)
proc readEvent*(stream: Stream): Event
proc sizeOfEvent*(message: Event): uint64

proc newStartRaw*(): StartRaw
proc newStartRaw*(data: string): StartRaw
proc newStartRaw*(data: seq[byte]): StartRaw
proc writeStartRaw*(stream: Stream, message: StartRaw)
proc readStartRaw*(stream: Stream): StartRaw
proc sizeOfStartRaw*(message: StartRaw): uint64

proc newMapState*(): MapState
proc newMapState*(data: string): MapState
proc newMapState*(data: seq[byte]): MapState
proc writeMapState*(stream: Stream, message: MapState)
proc readMapState*(stream: Stream): MapState
proc sizeOfMapState*(message: MapState): uint64

proc newPowerSource*(): PowerSource
proc newPowerSource*(data: string): PowerSource
proc newPowerSource*(data: seq[byte]): PowerSource
proc writePowerSource*(stream: Stream, message: PowerSource)
proc readPowerSource*(stream: Stream): PowerSource
proc sizeOfPowerSource*(message: PowerSource): uint64

proc newActionRawToggleAutocast*(): ActionRawToggleAutocast
proc newActionRawToggleAutocast*(data: string): ActionRawToggleAutocast
proc newActionRawToggleAutocast*(data: seq[byte]): ActionRawToggleAutocast
proc writeActionRawToggleAutocast*(stream: Stream, message: ActionRawToggleAutocast)
proc readActionRawToggleAutocast*(stream: Stream): ActionRawToggleAutocast
proc sizeOfActionRawToggleAutocast*(message: ActionRawToggleAutocast): uint64

proc newEffect*(): Effect
proc newEffect*(data: string): Effect
proc newEffect*(data: seq[byte]): Effect
proc writeEffect*(stream: Stream, message: Effect)
proc readEffect*(stream: Stream): Effect
proc sizeOfEffect*(message: Effect): uint64

proc newPlayerRaw*(): PlayerRaw
proc newPlayerRaw*(data: string): PlayerRaw
proc newPlayerRaw*(data: seq[byte]): PlayerRaw
proc writePlayerRaw*(stream: Stream, message: PlayerRaw)
proc readPlayerRaw*(stream: Stream): PlayerRaw
proc sizeOfPlayerRaw*(message: PlayerRaw): uint64

proc newUnitOrder*(): UnitOrder
proc newUnitOrder*(data: string): UnitOrder
proc newUnitOrder*(data: seq[byte]): UnitOrder
proc writeUnitOrder*(stream: Stream, message: UnitOrder)
proc readUnitOrder*(stream: Stream): UnitOrder
proc sizeOfUnitOrder*(message: UnitOrder): uint64

proc newRallyTarget*(): RallyTarget
proc newRallyTarget*(data: string): RallyTarget
proc newRallyTarget*(data: seq[byte]): RallyTarget
proc writeRallyTarget*(stream: Stream, message: RallyTarget)
proc readRallyTarget*(stream: Stream): RallyTarget
proc sizeOfRallyTarget*(message: RallyTarget): uint64

proc newPassengerUnit*(): PassengerUnit
proc newPassengerUnit*(data: string): PassengerUnit
proc newPassengerUnit*(data: seq[byte]): PassengerUnit
proc writePassengerUnit*(stream: Stream, message: PassengerUnit)
proc readPassengerUnit*(stream: Stream): PassengerUnit
proc sizeOfPassengerUnit*(message: PassengerUnit): uint64

proc newUnit*(): Unit
proc newUnit*(data: string): Unit
proc newUnit*(data: seq[byte]): Unit
proc writeUnit*(stream: Stream, message: Unit)
proc readUnit*(stream: Stream): Unit
proc sizeOfUnit*(message: Unit): uint64

proc newActionRawUnitCommand*(): ActionRawUnitCommand
proc newActionRawUnitCommand*(data: string): ActionRawUnitCommand
proc newActionRawUnitCommand*(data: seq[byte]): ActionRawUnitCommand
proc writeActionRawUnitCommand*(stream: Stream, message: ActionRawUnitCommand)
proc readActionRawUnitCommand*(stream: Stream): ActionRawUnitCommand
proc sizeOfActionRawUnitCommand*(message: ActionRawUnitCommand): uint64

proc newActionRawCameraMove*(): ActionRawCameraMove
proc newActionRawCameraMove*(data: string): ActionRawCameraMove
proc newActionRawCameraMove*(data: seq[byte]): ActionRawCameraMove
proc writeActionRawCameraMove*(stream: Stream, message: ActionRawCameraMove)
proc readActionRawCameraMove*(stream: Stream): ActionRawCameraMove
proc sizeOfActionRawCameraMove*(message: ActionRawCameraMove): uint64

proc newActionRaw*(): ActionRaw
proc newActionRaw*(data: string): ActionRaw
proc newActionRaw*(data: seq[byte]): ActionRaw
proc writeActionRaw*(stream: Stream, message: ActionRaw)
proc readActionRaw*(stream: Stream): ActionRaw
proc sizeOfActionRaw*(message: ActionRaw): uint64

proc newRadarRing*(): RadarRing
proc newRadarRing*(data: string): RadarRing
proc newRadarRing*(data: seq[byte]): RadarRing
proc writeRadarRing*(stream: Stream, message: RadarRing)
proc readRadarRing*(stream: Stream): RadarRing
proc sizeOfRadarRing*(message: RadarRing): uint64

proc newObservationRaw*(): ObservationRaw
proc newObservationRaw*(data: string): ObservationRaw
proc newObservationRaw*(data: seq[byte]): ObservationRaw
proc writeObservationRaw*(stream: Stream, message: ObservationRaw)
proc readObservationRaw*(stream: Stream): ObservationRaw
proc sizeOfObservationRaw*(message: ObservationRaw): uint64

proc fullyQualifiedName*(T: typedesc[Event]): string = "Event"

proc readEventImpl(stream: Stream): Message = readEvent(stream)
proc writeEventImpl(stream: Stream, msg: Message) = writeEvent(stream, Event(msg))

proc EventProcs*(): MessageProcs =
    result.readImpl = readEventImpl
    result.writeImpl = writeEventImpl

proc newEvent*(): Event =
    new(result)
    initMessage(result[])
    result.procs = EventProcs()
    result.deadUnits = @[]

proc cleardeadUnits*(message: Event) =
    message.deadUnits = @[]
    clearFields(message, [1])

proc hasdeadUnits*(message: Event): bool =
    result = hasField(message, 1) or (len(message.deadUnits) > 0)

proc setdeadUnits*(message: Event, value: seq[uint64]) =
    message.deadUnits = value
    setField(message, 1)

proc adddeadUnits*(message: Event, value: uint64) =
    add(message.deadUnits, value)

proc deadUnits*(message: Event): seq[uint64] {.inline.} =
    message.deadUnits

proc `deadUnits=`*(message: Event, value: seq[uint64]) {.inline.} =
    setdeadUnits(message, value)

proc `$`*(message: Event): string =
    runnableExamples:
        echo $Event
        echo fmt"{Event}"
        echo &"{Event}"
    var resultSeq: seq[string]
    if message.hasdeadUnits:
        resultSeq.add(&"deadUnits: {message.deadUnits}")
    result = resultSeq.join(", ")
    result = &"Event({result})"

proc sizeOfEvent*(message: Event): uint64 =
    if len(message.deadUnits) > 0:
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(packedFieldSize(message.deadUnits, FieldType.UInt64))
    result = result + sizeOfUnknownFields(message)

proc writeEvent*(stream: Stream, message: Event) =
    for value in message.deadUnits:
        protoWriteUInt64(stream, value, 1)
    writeUnknownFields(stream, message)

proc readEvent*(stream: Stream): Event =
    result = newEvent()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint, WireType.LengthDelimited)
            if wireType == WireType.LengthDelimited:
                let
                    size = readVarint(stream)
                    start = uint64(getPosition(stream))
                var consumed = 0'u64
                while consumed < size:
                    adddeadUnits(result, protoReadUInt64(stream))
                    consumed = uint64(getPosition(stream)) - start
                if consumed != size:
                    raise newException(Exception, "packed field size mismatch")
            else:
                adddeadUnits(result, protoReadUInt64(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: Event): string =
    let
        ss = newStringStream()
    writeEvent(ss, message)
    result = ss.data

proc newEvent*(data: string): Event =
    let
        ss = newStringStream(data)
    result = readEvent(ss)

proc newEvent*(data: seq[byte]): Event =
    let
        ss = newStringStream(cast[string](data))
    result = readEvent(ss)


proc fullyQualifiedName*(T: typedesc[StartRaw]): string = "StartRaw"

proc readStartRawImpl(stream: Stream): Message = readStartRaw(stream)
proc writeStartRawImpl(stream: Stream, msg: Message) = writeStartRaw(stream, StartRaw(msg))

proc StartRawProcs*(): MessageProcs =
    result.readImpl = readStartRawImpl
    result.writeImpl = writeStartRawImpl

proc newStartRaw*(): StartRaw =
    new(result)
    initMessage(result[])
    result.procs = StartRawProcs()
    result.mapSize = nil
    result.pathingGrid = nil
    result.terrainHeight = nil
    result.placementGrid = nil
    result.playableArea = nil
    result.startLocations = @[]

proc clearmapSize*(message: StartRaw) =
    message.mapSize = nil
    clearFields(message, [1])

proc hasmapSize*(message: StartRaw): bool =
    result = hasField(message, 1)

proc setmapSize*(message: StartRaw, value: Size2DI) =
    message.mapSize = value
    setField(message, 1)

proc mapSize*(message: StartRaw): Size2DI {.inline.} =
    message.mapSize

proc `mapSize=`*(message: StartRaw, value: Size2DI) {.inline.} =
    setmapSize(message, value)

proc clearpathingGrid*(message: StartRaw) =
    message.pathingGrid = nil
    clearFields(message, [2])

proc haspathingGrid*(message: StartRaw): bool =
    result = hasField(message, 2)

proc setpathingGrid*(message: StartRaw, value: ImageData) =
    message.pathingGrid = value
    setField(message, 2)

proc pathingGrid*(message: StartRaw): ImageData {.inline.} =
    message.pathingGrid

proc `pathingGrid=`*(message: StartRaw, value: ImageData) {.inline.} =
    setpathingGrid(message, value)

proc clearterrainHeight*(message: StartRaw) =
    message.terrainHeight = nil
    clearFields(message, [3])

proc hasterrainHeight*(message: StartRaw): bool =
    result = hasField(message, 3)

proc setterrainHeight*(message: StartRaw, value: ImageData) =
    message.terrainHeight = value
    setField(message, 3)

proc terrainHeight*(message: StartRaw): ImageData {.inline.} =
    message.terrainHeight

proc `terrainHeight=`*(message: StartRaw, value: ImageData) {.inline.} =
    setterrainHeight(message, value)

proc clearplacementGrid*(message: StartRaw) =
    message.placementGrid = nil
    clearFields(message, [4])

proc hasplacementGrid*(message: StartRaw): bool =
    result = hasField(message, 4)

proc setplacementGrid*(message: StartRaw, value: ImageData) =
    message.placementGrid = value
    setField(message, 4)

proc placementGrid*(message: StartRaw): ImageData {.inline.} =
    message.placementGrid

proc `placementGrid=`*(message: StartRaw, value: ImageData) {.inline.} =
    setplacementGrid(message, value)

proc clearplayableArea*(message: StartRaw) =
    message.playableArea = nil
    clearFields(message, [5])

proc hasplayableArea*(message: StartRaw): bool =
    result = hasField(message, 5)

proc setplayableArea*(message: StartRaw, value: RectangleI) =
    message.playableArea = value
    setField(message, 5)

proc playableArea*(message: StartRaw): RectangleI {.inline.} =
    message.playableArea

proc `playableArea=`*(message: StartRaw, value: RectangleI) {.inline.} =
    setplayableArea(message, value)

proc clearstartLocations*(message: StartRaw) =
    message.startLocations = @[]
    clearFields(message, [6])

proc hasstartLocations*(message: StartRaw): bool =
    result = hasField(message, 6) or (len(message.startLocations) > 0)

proc setstartLocations*(message: StartRaw, value: seq[Point2D]) =
    message.startLocations = value
    setField(message, 6)

proc addstartLocations*(message: StartRaw, value: Point2D) =
    add(message.startLocations, value)

proc startLocations*(message: StartRaw): seq[Point2D] {.inline.} =
    message.startLocations

proc `startLocations=`*(message: StartRaw, value: seq[Point2D]) {.inline.} =
    setstartLocations(message, value)

proc `$`*(message: StartRaw): string =
    runnableExamples:
        echo $StartRaw
        echo fmt"{StartRaw}"
        echo &"{StartRaw}"
    var resultSeq: seq[string]
    if message.hasmapSize:
        resultSeq.add(&"mapSize: {message.mapSize}")
    if message.haspathingGrid:
        resultSeq.add(&"pathingGrid: {message.pathingGrid}")
    if message.hasterrainHeight:
        resultSeq.add(&"terrainHeight: {message.terrainHeight}")
    if message.hasplacementGrid:
        resultSeq.add(&"placementGrid: {message.placementGrid}")
    if message.hasplayableArea:
        resultSeq.add(&"playableArea: {message.playableArea}")
    if message.hasstartLocations:
        resultSeq.add(&"startLocations: {message.startLocations}")
    result = resultSeq.join(", ")
    result = &"StartRaw({result})"

proc sizeOfStartRaw*(message: StartRaw): uint64 =
    if hasmapSize(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfSize2DI(message.mapSize))
    if haspathingGrid(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.pathingGrid))
    if hasterrainHeight(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.terrainHeight))
    if hasplacementGrid(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.placementGrid))
    if hasplayableArea(message):
        result = result + sizeOfTag(5, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRectangleI(message.playableArea))
    for value in message.startLocations:
        result = result + sizeOfTag(6, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint2D(value))
    result = result + sizeOfUnknownFields(message)

proc writeStartRaw*(stream: Stream, message: StartRaw) =
    if hasmapSize(message):
        writeMessage(stream, message.mapSize, 1)
    if haspathingGrid(message):
        writeMessage(stream, message.pathingGrid, 2)
    if hasterrainHeight(message):
        writeMessage(stream, message.terrainHeight, 3)
    if hasplacementGrid(message):
        writeMessage(stream, message.placementGrid, 4)
    if hasplayableArea(message):
        writeMessage(stream, message.playableArea, 5)
    for value in message.startLocations:
        writeMessage(stream, value, 6)
    writeUnknownFields(stream, message)

proc readStartRaw*(stream: Stream): StartRaw =
    result = newStartRaw()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setmapSize(result, newSize2DI(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setpathingGrid(result, newImageData(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setterrainHeight(result, newImageData(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setplacementGrid(result, newImageData(data))
        of 5:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setplayableArea(result, newRectangleI(data))
        of 6:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addstartLocations(result, newPoint2D(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: StartRaw): string =
    let
        ss = newStringStream()
    writeStartRaw(ss, message)
    result = ss.data

proc newStartRaw*(data: string): StartRaw =
    let
        ss = newStringStream(data)
    result = readStartRaw(ss)

proc newStartRaw*(data: seq[byte]): StartRaw =
    let
        ss = newStringStream(cast[string](data))
    result = readStartRaw(ss)


proc fullyQualifiedName*(T: typedesc[MapState]): string = "MapState"

proc readMapStateImpl(stream: Stream): Message = readMapState(stream)
proc writeMapStateImpl(stream: Stream, msg: Message) = writeMapState(stream, MapState(msg))

proc MapStateProcs*(): MessageProcs =
    result.readImpl = readMapStateImpl
    result.writeImpl = writeMapStateImpl

proc newMapState*(): MapState =
    new(result)
    initMessage(result[])
    result.procs = MapStateProcs()
    result.visibility = nil
    result.creep = nil

proc clearvisibility*(message: MapState) =
    message.visibility = nil
    clearFields(message, [1])

proc hasvisibility*(message: MapState): bool =
    result = hasField(message, 1)

proc setvisibility*(message: MapState, value: ImageData) =
    message.visibility = value
    setField(message, 1)

proc visibility*(message: MapState): ImageData {.inline.} =
    message.visibility

proc `visibility=`*(message: MapState, value: ImageData) {.inline.} =
    setvisibility(message, value)

proc clearcreep*(message: MapState) =
    message.creep = nil
    clearFields(message, [2])

proc hascreep*(message: MapState): bool =
    result = hasField(message, 2)

proc setcreep*(message: MapState, value: ImageData) =
    message.creep = value
    setField(message, 2)

proc creep*(message: MapState): ImageData {.inline.} =
    message.creep

proc `creep=`*(message: MapState, value: ImageData) {.inline.} =
    setcreep(message, value)

proc `$`*(message: MapState): string =
    runnableExamples:
        echo $MapState
        echo fmt"{MapState}"
        echo &"{MapState}"
    var resultSeq: seq[string]
    if message.hasvisibility:
        resultSeq.add(&"visibility: {message.visibility}")
    if message.hascreep:
        resultSeq.add(&"creep: {message.creep}")
    result = resultSeq.join(", ")
    result = &"MapState({result})"

proc sizeOfMapState*(message: MapState): uint64 =
    if hasvisibility(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.visibility))
    if hascreep(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfImageData(message.creep))
    result = result + sizeOfUnknownFields(message)

proc writeMapState*(stream: Stream, message: MapState) =
    if hasvisibility(message):
        writeMessage(stream, message.visibility, 1)
    if hascreep(message):
        writeMessage(stream, message.creep, 2)
    writeUnknownFields(stream, message)

proc readMapState*(stream: Stream): MapState =
    result = newMapState()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setvisibility(result, newImageData(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcreep(result, newImageData(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: MapState): string =
    let
        ss = newStringStream()
    writeMapState(ss, message)
    result = ss.data

proc newMapState*(data: string): MapState =
    let
        ss = newStringStream(data)
    result = readMapState(ss)

proc newMapState*(data: seq[byte]): MapState =
    let
        ss = newStringStream(cast[string](data))
    result = readMapState(ss)


proc fullyQualifiedName*(T: typedesc[PowerSource]): string = "PowerSource"

proc readPowerSourceImpl(stream: Stream): Message = readPowerSource(stream)
proc writePowerSourceImpl(stream: Stream, msg: Message) = writePowerSource(stream, PowerSource(msg))

proc PowerSourceProcs*(): MessageProcs =
    result.readImpl = readPowerSourceImpl
    result.writeImpl = writePowerSourceImpl

proc newPowerSource*(): PowerSource =
    new(result)
    initMessage(result[])
    result.procs = PowerSourceProcs()
    result.pos = nil
    result.radius = 0
    result.tag = 0

proc clearpos*(message: PowerSource) =
    message.pos = nil
    clearFields(message, [1])

proc haspos*(message: PowerSource): bool =
    result = hasField(message, 1)

proc setpos*(message: PowerSource, value: Point) =
    message.pos = value
    setField(message, 1)

proc pos*(message: PowerSource): Point {.inline.} =
    message.pos

proc `pos=`*(message: PowerSource, value: Point) {.inline.} =
    setpos(message, value)

proc clearradius*(message: PowerSource) =
    message.radius = 0
    clearFields(message, [2])

proc hasradius*(message: PowerSource): bool =
    result = hasField(message, 2)

proc setradius*(message: PowerSource, value: float32) =
    message.radius = value
    setField(message, 2)

proc radius*(message: PowerSource): float32 {.inline.} =
    message.radius

proc `radius=`*(message: PowerSource, value: float32) {.inline.} =
    setradius(message, value)

proc cleartag*(message: PowerSource) =
    message.tag = 0
    clearFields(message, [3])

proc hastag*(message: PowerSource): bool =
    result = hasField(message, 3)

proc settag*(message: PowerSource, value: uint64) =
    message.tag = value
    setField(message, 3)

proc tag*(message: PowerSource): uint64 {.inline.} =
    message.tag

proc `tag=`*(message: PowerSource, value: uint64) {.inline.} =
    settag(message, value)

proc `$`*(message: PowerSource): string =
    runnableExamples:
        echo $PowerSource
        echo fmt"{PowerSource}"
        echo &"{PowerSource}"
    var resultSeq: seq[string]
    if message.haspos:
        resultSeq.add(&"pos: {message.pos}")
    if message.hasradius:
        resultSeq.add(&"radius: {message.radius}")
    if message.hastag:
        resultSeq.add(&"tag: {message.tag}")
    result = resultSeq.join(", ")
    result = &"PowerSource({result})"

proc sizeOfPowerSource*(message: PowerSource): uint64 =
    if haspos(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint(message.pos))
    if hasradius(message):
        result = result + sizeOfTag(2, WireType.Fixed32)
        result = result + sizeOfFloat(message.radius)
    if hastag(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfUInt64(message.tag)
    result = result + sizeOfUnknownFields(message)

proc writePowerSource*(stream: Stream, message: PowerSource) =
    if haspos(message):
        writeMessage(stream, message.pos, 1)
    if hasradius(message):
        protoWriteFloat(stream, message.radius, 2)
    if hastag(message):
        protoWriteUInt64(stream, message.tag, 3)
    writeUnknownFields(stream, message)

proc readPowerSource*(stream: Stream): PowerSource =
    result = newPowerSource()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setpos(result, newPoint(data))
        of 2:
            expectWireType(wireType, WireType.Fixed32)
            setradius(result, protoReadFloat(stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            settag(result, protoReadUInt64(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: PowerSource): string =
    let
        ss = newStringStream()
    writePowerSource(ss, message)
    result = ss.data

proc newPowerSource*(data: string): PowerSource =
    let
        ss = newStringStream(data)
    result = readPowerSource(ss)

proc newPowerSource*(data: seq[byte]): PowerSource =
    let
        ss = newStringStream(cast[string](data))
    result = readPowerSource(ss)


proc fullyQualifiedName*(T: typedesc[ActionRawToggleAutocast]): string = "ActionRawToggleAutocast"

proc readActionRawToggleAutocastImpl(stream: Stream): Message = readActionRawToggleAutocast(stream)
proc writeActionRawToggleAutocastImpl(stream: Stream, msg: Message) = writeActionRawToggleAutocast(stream, ActionRawToggleAutocast(msg))

proc ActionRawToggleAutocastProcs*(): MessageProcs =
    result.readImpl = readActionRawToggleAutocastImpl
    result.writeImpl = writeActionRawToggleAutocastImpl

proc newActionRawToggleAutocast*(): ActionRawToggleAutocast =
    new(result)
    initMessage(result[])
    result.procs = ActionRawToggleAutocastProcs()
    result.abilityId = 0
    result.unitTags = @[]

proc clearabilityId*(message: ActionRawToggleAutocast) =
    message.abilityId = 0
    clearFields(message, [1])

proc hasabilityId*(message: ActionRawToggleAutocast): bool =
    result = hasField(message, 1)

proc setabilityId*(message: ActionRawToggleAutocast, value: int32) =
    message.abilityId = value
    setField(message, 1)

proc abilityId*(message: ActionRawToggleAutocast): int32 {.inline.} =
    message.abilityId

proc `abilityId=`*(message: ActionRawToggleAutocast, value: int32) {.inline.} =
    setabilityId(message, value)

proc clearunitTags*(message: ActionRawToggleAutocast) =
    message.unitTags = @[]
    clearFields(message, [2])

proc hasunitTags*(message: ActionRawToggleAutocast): bool =
    result = hasField(message, 2) or (len(message.unitTags) > 0)

proc setunitTags*(message: ActionRawToggleAutocast, value: seq[uint64]) =
    message.unitTags = value
    setField(message, 2)

proc addunitTags*(message: ActionRawToggleAutocast, value: uint64) =
    add(message.unitTags, value)

proc unitTags*(message: ActionRawToggleAutocast): seq[uint64] {.inline.} =
    message.unitTags

proc `unitTags=`*(message: ActionRawToggleAutocast, value: seq[uint64]) {.inline.} =
    setunitTags(message, value)

proc `$`*(message: ActionRawToggleAutocast): string =
    runnableExamples:
        echo $ActionRawToggleAutocast
        echo fmt"{ActionRawToggleAutocast}"
        echo &"{ActionRawToggleAutocast}"
    var resultSeq: seq[string]
    if message.hasabilityId:
        resultSeq.add(&"abilityId: {message.abilityId}")
    if message.hasunitTags:
        resultSeq.add(&"unitTags: {message.unitTags}")
    result = resultSeq.join(", ")
    result = &"ActionRawToggleAutocast({result})"

proc sizeOfActionRawToggleAutocast*(message: ActionRawToggleAutocast): uint64 =
    if hasabilityId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfInt32(message.abilityId)
    if len(message.unitTags) > 0:
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(packedFieldSize(message.unitTags, FieldType.UInt64))
    result = result + sizeOfUnknownFields(message)

proc writeActionRawToggleAutocast*(stream: Stream, message: ActionRawToggleAutocast) =
    if hasabilityId(message):
        protoWriteInt32(stream, message.abilityId, 1)
    for value in message.unitTags:
        protoWriteUInt64(stream, value, 2)
    writeUnknownFields(stream, message)

proc readActionRawToggleAutocast*(stream: Stream): ActionRawToggleAutocast =
    result = newActionRawToggleAutocast()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setabilityId(result, protoReadInt32(stream))
        of 2:
            expectWireType(wireType, WireType.Varint, WireType.LengthDelimited)
            if wireType == WireType.LengthDelimited:
                let
                    size = readVarint(stream)
                    start = uint64(getPosition(stream))
                var consumed = 0'u64
                while consumed < size:
                    addunitTags(result, protoReadUInt64(stream))
                    consumed = uint64(getPosition(stream)) - start
                if consumed != size:
                    raise newException(Exception, "packed field size mismatch")
            else:
                addunitTags(result, protoReadUInt64(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionRawToggleAutocast): string =
    let
        ss = newStringStream()
    writeActionRawToggleAutocast(ss, message)
    result = ss.data

proc newActionRawToggleAutocast*(data: string): ActionRawToggleAutocast =
    let
        ss = newStringStream(data)
    result = readActionRawToggleAutocast(ss)

proc newActionRawToggleAutocast*(data: seq[byte]): ActionRawToggleAutocast =
    let
        ss = newStringStream(cast[string](data))
    result = readActionRawToggleAutocast(ss)


proc fullyQualifiedName*(T: typedesc[Effect]): string = "Effect"

proc readEffectImpl(stream: Stream): Message = readEffect(stream)
proc writeEffectImpl(stream: Stream, msg: Message) = writeEffect(stream, Effect(msg))

proc EffectProcs*(): MessageProcs =
    result.readImpl = readEffectImpl
    result.writeImpl = writeEffectImpl

proc newEffect*(): Effect =
    new(result)
    initMessage(result[])
    result.procs = EffectProcs()
    result.effectId = 0
    result.pos = @[]
    result.alliance = Alliance.Self
    result.owner = 0
    result.radius = 0

proc cleareffectId*(message: Effect) =
    message.effectId = 0
    clearFields(message, [1])

proc haseffectId*(message: Effect): bool =
    result = hasField(message, 1)

proc seteffectId*(message: Effect, value: uint32) =
    message.effectId = value
    setField(message, 1)

proc effectId*(message: Effect): uint32 {.inline.} =
    message.effectId

proc `effectId=`*(message: Effect, value: uint32) {.inline.} =
    seteffectId(message, value)

proc clearpos*(message: Effect) =
    message.pos = @[]
    clearFields(message, [2])

proc haspos*(message: Effect): bool =
    result = hasField(message, 2) or (len(message.pos) > 0)

proc setpos*(message: Effect, value: seq[Point2D]) =
    message.pos = value
    setField(message, 2)

proc addpos*(message: Effect, value: Point2D) =
    add(message.pos, value)

proc pos*(message: Effect): seq[Point2D] {.inline.} =
    message.pos

proc `pos=`*(message: Effect, value: seq[Point2D]) {.inline.} =
    setpos(message, value)

proc clearalliance*(message: Effect) =
    message.alliance = Alliance.Self
    clearFields(message, [3])

proc hasalliance*(message: Effect): bool =
    result = hasField(message, 3)

proc setalliance*(message: Effect, value: Alliance) =
    message.alliance = value
    setField(message, 3)

proc alliance*(message: Effect): Alliance {.inline.} =
    message.alliance

proc `alliance=`*(message: Effect, value: Alliance) {.inline.} =
    setalliance(message, value)

proc clearowner*(message: Effect) =
    message.owner = 0
    clearFields(message, [4])

proc hasowner*(message: Effect): bool =
    result = hasField(message, 4)

proc setowner*(message: Effect, value: int32) =
    message.owner = value
    setField(message, 4)

proc owner*(message: Effect): int32 {.inline.} =
    message.owner

proc `owner=`*(message: Effect, value: int32) {.inline.} =
    setowner(message, value)

proc clearradius*(message: Effect) =
    message.radius = 0
    clearFields(message, [5])

proc hasradius*(message: Effect): bool =
    result = hasField(message, 5)

proc setradius*(message: Effect, value: float32) =
    message.radius = value
    setField(message, 5)

proc radius*(message: Effect): float32 {.inline.} =
    message.radius

proc `radius=`*(message: Effect, value: float32) {.inline.} =
    setradius(message, value)

proc `$`*(message: Effect): string =
    runnableExamples:
        echo $Effect
        echo fmt"{Effect}"
        echo &"{Effect}"
    var resultSeq: seq[string]
    if message.haseffectId:
        resultSeq.add(&"effectId: {message.effectId}")
    if message.haspos:
        resultSeq.add(&"pos: {message.pos}")
    if message.hasalliance:
        resultSeq.add(&"alliance: {message.alliance}")
    if message.hasowner:
        resultSeq.add(&"owner: {message.owner}")
    if message.hasradius:
        resultSeq.add(&"radius: {message.radius}")
    result = resultSeq.join(", ")
    result = &"Effect({result})"

proc sizeOfEffect*(message: Effect): uint64 =
    if haseffectId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.effectId)
    for value in message.pos:
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint2D(value))
    if hasalliance(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfEnum[Alliance](message.alliance)
    if hasowner(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfInt32(message.owner)
    if hasradius(message):
        result = result + sizeOfTag(5, WireType.Fixed32)
        result = result + sizeOfFloat(message.radius)
    result = result + sizeOfUnknownFields(message)

proc writeEffect*(stream: Stream, message: Effect) =
    if haseffectId(message):
        protoWriteUInt32(stream, message.effectId, 1)
    for value in message.pos:
        writeMessage(stream, value, 2)
    if hasalliance(message):
        protoWriteEnum(stream, message.alliance, 3)
    if hasowner(message):
        protoWriteInt32(stream, message.owner, 4)
    if hasradius(message):
        protoWriteFloat(stream, message.radius, 5)
    writeUnknownFields(stream, message)

proc readEffect*(stream: Stream): Effect =
    result = newEffect()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            seteffectId(result, protoReadUInt32(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addpos(result, newPoint2D(data))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setalliance(result, protoReadEnum[Alliance](stream))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setowner(result, protoReadInt32(stream))
        of 5:
            expectWireType(wireType, WireType.Fixed32)
            setradius(result, protoReadFloat(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: Effect): string =
    let
        ss = newStringStream()
    writeEffect(ss, message)
    result = ss.data

proc newEffect*(data: string): Effect =
    let
        ss = newStringStream(data)
    result = readEffect(ss)

proc newEffect*(data: seq[byte]): Effect =
    let
        ss = newStringStream(cast[string](data))
    result = readEffect(ss)


proc fullyQualifiedName*(T: typedesc[PlayerRaw]): string = "PlayerRaw"

proc readPlayerRawImpl(stream: Stream): Message = readPlayerRaw(stream)
proc writePlayerRawImpl(stream: Stream, msg: Message) = writePlayerRaw(stream, PlayerRaw(msg))

proc PlayerRawProcs*(): MessageProcs =
    result.readImpl = readPlayerRawImpl
    result.writeImpl = writePlayerRawImpl

proc newPlayerRaw*(): PlayerRaw =
    new(result)
    initMessage(result[])
    result.procs = PlayerRawProcs()
    result.powerSources = @[]
    result.camera = nil
    result.upgradeIds = @[]

proc clearpowerSources*(message: PlayerRaw) =
    message.powerSources = @[]
    clearFields(message, [1])

proc haspowerSources*(message: PlayerRaw): bool =
    result = hasField(message, 1) or (len(message.powerSources) > 0)

proc setpowerSources*(message: PlayerRaw, value: seq[PowerSource]) =
    message.powerSources = value
    setField(message, 1)

proc addpowerSources*(message: PlayerRaw, value: PowerSource) =
    add(message.powerSources, value)

proc powerSources*(message: PlayerRaw): seq[PowerSource] {.inline.} =
    message.powerSources

proc `powerSources=`*(message: PlayerRaw, value: seq[PowerSource]) {.inline.} =
    setpowerSources(message, value)

proc clearcamera*(message: PlayerRaw) =
    message.camera = nil
    clearFields(message, [2])

proc hascamera*(message: PlayerRaw): bool =
    result = hasField(message, 2)

proc setcamera*(message: PlayerRaw, value: Point) =
    message.camera = value
    setField(message, 2)

proc camera*(message: PlayerRaw): Point {.inline.} =
    message.camera

proc `camera=`*(message: PlayerRaw, value: Point) {.inline.} =
    setcamera(message, value)

proc clearupgradeIds*(message: PlayerRaw) =
    message.upgradeIds = @[]
    clearFields(message, [3])

proc hasupgradeIds*(message: PlayerRaw): bool =
    result = hasField(message, 3) or (len(message.upgradeIds) > 0)

proc setupgradeIds*(message: PlayerRaw, value: seq[uint32]) =
    message.upgradeIds = value
    setField(message, 3)

proc addupgradeIds*(message: PlayerRaw, value: uint32) =
    add(message.upgradeIds, value)

proc upgradeIds*(message: PlayerRaw): seq[uint32] {.inline.} =
    message.upgradeIds

proc `upgradeIds=`*(message: PlayerRaw, value: seq[uint32]) {.inline.} =
    setupgradeIds(message, value)

proc `$`*(message: PlayerRaw): string =
    runnableExamples:
        echo $PlayerRaw
        echo fmt"{PlayerRaw}"
        echo &"{PlayerRaw}"
    var resultSeq: seq[string]
    if message.haspowerSources:
        resultSeq.add(&"powerSources: {message.powerSources}")
    if message.hascamera:
        resultSeq.add(&"camera: {message.camera}")
    if message.hasupgradeIds:
        resultSeq.add(&"upgradeIds: {message.upgradeIds}")
    result = resultSeq.join(", ")
    result = &"PlayerRaw({result})"

proc sizeOfPlayerRaw*(message: PlayerRaw): uint64 =
    for value in message.powerSources:
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPowerSource(value))
    if hascamera(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint(message.camera))
    if len(message.upgradeIds) > 0:
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(packedFieldSize(message.upgradeIds, FieldType.UInt32))
    result = result + sizeOfUnknownFields(message)

proc writePlayerRaw*(stream: Stream, message: PlayerRaw) =
    for value in message.powerSources:
        writeMessage(stream, value, 1)
    if hascamera(message):
        writeMessage(stream, message.camera, 2)
    for value in message.upgradeIds:
        protoWriteUInt32(stream, value, 3)
    writeUnknownFields(stream, message)

proc readPlayerRaw*(stream: Stream): PlayerRaw =
    result = newPlayerRaw()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addpowerSources(result, newPowerSource(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcamera(result, newPoint(data))
        of 3:
            expectWireType(wireType, WireType.Varint, WireType.LengthDelimited)
            if wireType == WireType.LengthDelimited:
                let
                    size = readVarint(stream)
                    start = uint64(getPosition(stream))
                var consumed = 0'u64
                while consumed < size:
                    addupgradeIds(result, protoReadUInt32(stream))
                    consumed = uint64(getPosition(stream)) - start
                if consumed != size:
                    raise newException(Exception, "packed field size mismatch")
            else:
                addupgradeIds(result, protoReadUInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: PlayerRaw): string =
    let
        ss = newStringStream()
    writePlayerRaw(ss, message)
    result = ss.data

proc newPlayerRaw*(data: string): PlayerRaw =
    let
        ss = newStringStream(data)
    result = readPlayerRaw(ss)

proc newPlayerRaw*(data: seq[byte]): PlayerRaw =
    let
        ss = newStringStream(cast[string](data))
    result = readPlayerRaw(ss)


proc fullyQualifiedName*(T: typedesc[UnitOrder]): string = "UnitOrder"

proc readUnitOrderImpl(stream: Stream): Message = readUnitOrder(stream)
proc writeUnitOrderImpl(stream: Stream, msg: Message) = writeUnitOrder(stream, UnitOrder(msg))

proc UnitOrderProcs*(): MessageProcs =
    result.readImpl = readUnitOrderImpl
    result.writeImpl = writeUnitOrderImpl

proc newUnitOrder*(): UnitOrder =
    new(result)
    initMessage(result[])
    result.procs = UnitOrderProcs()
    result.abilityId = 0
    result.progress = 0
    result.target = UnitOrder_target_OneOf(kind: UnitOrder_target_Kind.NotSet)

proc clearabilityId*(message: UnitOrder) =
    message.abilityId = 0
    clearFields(message, [1])

proc hasabilityId*(message: UnitOrder): bool =
    result = hasField(message, 1)

proc setabilityId*(message: UnitOrder, value: uint32) =
    message.abilityId = value
    setField(message, 1)

proc abilityId*(message: UnitOrder): uint32 {.inline.} =
    message.abilityId

proc `abilityId=`*(message: UnitOrder, value: uint32) {.inline.} =
    setabilityId(message, value)

proc cleartargetWorldSpacePos*(message: UnitOrder) =
    reset(message.target)
    message.target.kind = UnitOrder_target_Kind.NotSet
    clearFields(message, [2, 3])

proc hastargetWorldSpacePos*(message: UnitOrder): bool =
    result = hasField(message, 2)

proc settargetWorldSpacePos*(message: UnitOrder, value: Point) =
    if message.target.kind != UnitOrder_target_Kind.TargetWorldSpacePos:
        message.target = UnitOrder_target_OneOf(kind: UnitOrder_target_Kind.TargetWorldSpacePos, targetWorldSpacePos: value)
    else:
        message.target.targetWorldSpacePos = value
    setField(message, 2)
    clearFields(message, [3])

proc targetWorldSpacePos*(message: UnitOrder): Point {.inline.} =
    message.target.targetWorldSpacePos

proc `targetWorldSpacePos=`*(message: UnitOrder, value: Point) {.inline.} =
    settargetWorldSpacePos(message, value)

proc cleartargetUnitTag*(message: UnitOrder) =
    reset(message.target)
    message.target.kind = UnitOrder_target_Kind.NotSet
    clearFields(message, [3, 2])

proc hastargetUnitTag*(message: UnitOrder): bool =
    result = hasField(message, 3)

proc settargetUnitTag*(message: UnitOrder, value: uint64) =
    if message.target.kind != UnitOrder_target_Kind.TargetUnitTag:
        message.target = UnitOrder_target_OneOf(kind: UnitOrder_target_Kind.TargetUnitTag, targetUnitTag: value)
    else:
        message.target.targetUnitTag = value
    setField(message, 3)
    clearFields(message, [2])

proc targetUnitTag*(message: UnitOrder): uint64 {.inline.} =
    message.target.targetUnitTag

proc `targetUnitTag=`*(message: UnitOrder, value: uint64) {.inline.} =
    settargetUnitTag(message, value)

proc clearprogress*(message: UnitOrder) =
    message.progress = 0
    clearFields(message, [4])

proc hasprogress*(message: UnitOrder): bool =
    result = hasField(message, 4)

proc setprogress*(message: UnitOrder, value: float32) =
    message.progress = value
    setField(message, 4)

proc progress*(message: UnitOrder): float32 {.inline.} =
    message.progress

proc `progress=`*(message: UnitOrder, value: float32) {.inline.} =
    setprogress(message, value)

proc `$`*(message: UnitOrder): string =
    runnableExamples:
        echo $UnitOrder
        echo fmt"{UnitOrder}"
        echo &"{UnitOrder}"
    var resultSeq: seq[string]
    if message.hasabilityId:
        resultSeq.add(&"abilityId: {message.abilityId}")
    if message.hasprogress:
        resultSeq.add(&"progress: {message.progress}")
    if message.hastargetWorldSpacePos:
        resultSeq.add(&"targetWorldSpacePos: {message.targetWorldSpacePos}")
    if message.hastargetUnitTag:
        resultSeq.add(&"targetUnitTag: {message.targetUnitTag}")
    result = resultSeq.join(", ")
    result = &"UnitOrder({result})"

proc sizeOfUnitOrder*(message: UnitOrder): uint64 =
    if hasabilityId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.abilityId)
    if hastargetWorldSpacePos(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint(message.target.targetWorldSpacePos))
    if hastargetUnitTag(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfUInt64(message.target.targetUnitTag)
    if hasprogress(message):
        result = result + sizeOfTag(4, WireType.Fixed32)
        result = result + sizeOfFloat(message.progress)
    result = result + sizeOfUnknownFields(message)

proc writeUnitOrder*(stream: Stream, message: UnitOrder) =
    if hasabilityId(message):
        protoWriteUInt32(stream, message.abilityId, 1)
    if hastargetWorldSpacePos(message):
        writeMessage(stream, message.target.targetWorldSpacePos, 2)
    if hastargetUnitTag(message):
        protoWriteUInt64(stream, message.target.targetUnitTag, 3)
    if hasprogress(message):
        protoWriteFloat(stream, message.progress, 4)
    writeUnknownFields(stream, message)

proc readUnitOrder*(stream: Stream): UnitOrder =
    result = newUnitOrder()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setabilityId(result, protoReadUInt32(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            settargetWorldSpacePos(result, newPoint(data))
        of 3:
            expectWireType(wireType, WireType.Varint)
            settargetUnitTag(result, protoReadUInt64(stream))
        of 4:
            expectWireType(wireType, WireType.Fixed32)
            setprogress(result, protoReadFloat(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: UnitOrder): string =
    let
        ss = newStringStream()
    writeUnitOrder(ss, message)
    result = ss.data

proc newUnitOrder*(data: string): UnitOrder =
    let
        ss = newStringStream(data)
    result = readUnitOrder(ss)

proc newUnitOrder*(data: seq[byte]): UnitOrder =
    let
        ss = newStringStream(cast[string](data))
    result = readUnitOrder(ss)


proc fullyQualifiedName*(T: typedesc[RallyTarget]): string = "RallyTarget"

proc readRallyTargetImpl(stream: Stream): Message = readRallyTarget(stream)
proc writeRallyTargetImpl(stream: Stream, msg: Message) = writeRallyTarget(stream, RallyTarget(msg))

proc RallyTargetProcs*(): MessageProcs =
    result.readImpl = readRallyTargetImpl
    result.writeImpl = writeRallyTargetImpl

proc newRallyTarget*(): RallyTarget =
    new(result)
    initMessage(result[])
    result.procs = RallyTargetProcs()
    result.point = nil
    result.tag = 0

proc clearpoint*(message: RallyTarget) =
    message.point = nil
    clearFields(message, [1])

proc haspoint*(message: RallyTarget): bool =
    result = hasField(message, 1)

proc setpoint*(message: RallyTarget, value: Point) =
    message.point = value
    setField(message, 1)

proc point*(message: RallyTarget): Point {.inline.} =
    message.point

proc `point=`*(message: RallyTarget, value: Point) {.inline.} =
    setpoint(message, value)

proc cleartag*(message: RallyTarget) =
    message.tag = 0
    clearFields(message, [2])

proc hastag*(message: RallyTarget): bool =
    result = hasField(message, 2)

proc settag*(message: RallyTarget, value: uint64) =
    message.tag = value
    setField(message, 2)

proc tag*(message: RallyTarget): uint64 {.inline.} =
    message.tag

proc `tag=`*(message: RallyTarget, value: uint64) {.inline.} =
    settag(message, value)

proc `$`*(message: RallyTarget): string =
    runnableExamples:
        echo $RallyTarget
        echo fmt"{RallyTarget}"
        echo &"{RallyTarget}"
    var resultSeq: seq[string]
    if message.haspoint:
        resultSeq.add(&"point: {message.point}")
    if message.hastag:
        resultSeq.add(&"tag: {message.tag}")
    result = resultSeq.join(", ")
    result = &"RallyTarget({result})"

proc sizeOfRallyTarget*(message: RallyTarget): uint64 =
    if haspoint(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint(message.point))
    if hastag(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfUInt64(message.tag)
    result = result + sizeOfUnknownFields(message)

proc writeRallyTarget*(stream: Stream, message: RallyTarget) =
    if haspoint(message):
        writeMessage(stream, message.point, 1)
    if hastag(message):
        protoWriteUInt64(stream, message.tag, 2)
    writeUnknownFields(stream, message)

proc readRallyTarget*(stream: Stream): RallyTarget =
    result = newRallyTarget()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setpoint(result, newPoint(data))
        of 2:
            expectWireType(wireType, WireType.Varint)
            settag(result, protoReadUInt64(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RallyTarget): string =
    let
        ss = newStringStream()
    writeRallyTarget(ss, message)
    result = ss.data

proc newRallyTarget*(data: string): RallyTarget =
    let
        ss = newStringStream(data)
    result = readRallyTarget(ss)

proc newRallyTarget*(data: seq[byte]): RallyTarget =
    let
        ss = newStringStream(cast[string](data))
    result = readRallyTarget(ss)


proc fullyQualifiedName*(T: typedesc[PassengerUnit]): string = "PassengerUnit"

proc readPassengerUnitImpl(stream: Stream): Message = readPassengerUnit(stream)
proc writePassengerUnitImpl(stream: Stream, msg: Message) = writePassengerUnit(stream, PassengerUnit(msg))

proc PassengerUnitProcs*(): MessageProcs =
    result.readImpl = readPassengerUnitImpl
    result.writeImpl = writePassengerUnitImpl

proc newPassengerUnit*(): PassengerUnit =
    new(result)
    initMessage(result[])
    result.procs = PassengerUnitProcs()
    result.tag = 0
    result.health = 0
    result.healthMax = 0
    result.shield = 0
    result.shieldMax = 0
    result.energy = 0
    result.energyMax = 0
    result.unitType = 0

proc cleartag*(message: PassengerUnit) =
    message.tag = 0
    clearFields(message, [1])

proc hastag*(message: PassengerUnit): bool =
    result = hasField(message, 1)

proc settag*(message: PassengerUnit, value: uint64) =
    message.tag = value
    setField(message, 1)

proc tag*(message: PassengerUnit): uint64 {.inline.} =
    message.tag

proc `tag=`*(message: PassengerUnit, value: uint64) {.inline.} =
    settag(message, value)

proc clearhealth*(message: PassengerUnit) =
    message.health = 0
    clearFields(message, [2])

proc hashealth*(message: PassengerUnit): bool =
    result = hasField(message, 2)

proc sethealth*(message: PassengerUnit, value: float32) =
    message.health = value
    setField(message, 2)

proc health*(message: PassengerUnit): float32 {.inline.} =
    message.health

proc `health=`*(message: PassengerUnit, value: float32) {.inline.} =
    sethealth(message, value)

proc clearhealthMax*(message: PassengerUnit) =
    message.healthMax = 0
    clearFields(message, [3])

proc hashealthMax*(message: PassengerUnit): bool =
    result = hasField(message, 3)

proc sethealthMax*(message: PassengerUnit, value: float32) =
    message.healthMax = value
    setField(message, 3)

proc healthMax*(message: PassengerUnit): float32 {.inline.} =
    message.healthMax

proc `healthMax=`*(message: PassengerUnit, value: float32) {.inline.} =
    sethealthMax(message, value)

proc clearshield*(message: PassengerUnit) =
    message.shield = 0
    clearFields(message, [4])

proc hasshield*(message: PassengerUnit): bool =
    result = hasField(message, 4)

proc setshield*(message: PassengerUnit, value: float32) =
    message.shield = value
    setField(message, 4)

proc shield*(message: PassengerUnit): float32 {.inline.} =
    message.shield

proc `shield=`*(message: PassengerUnit, value: float32) {.inline.} =
    setshield(message, value)

proc clearshieldMax*(message: PassengerUnit) =
    message.shieldMax = 0
    clearFields(message, [7])

proc hasshieldMax*(message: PassengerUnit): bool =
    result = hasField(message, 7)

proc setshieldMax*(message: PassengerUnit, value: float32) =
    message.shieldMax = value
    setField(message, 7)

proc shieldMax*(message: PassengerUnit): float32 {.inline.} =
    message.shieldMax

proc `shieldMax=`*(message: PassengerUnit, value: float32) {.inline.} =
    setshieldMax(message, value)

proc clearenergy*(message: PassengerUnit) =
    message.energy = 0
    clearFields(message, [5])

proc hasenergy*(message: PassengerUnit): bool =
    result = hasField(message, 5)

proc setenergy*(message: PassengerUnit, value: float32) =
    message.energy = value
    setField(message, 5)

proc energy*(message: PassengerUnit): float32 {.inline.} =
    message.energy

proc `energy=`*(message: PassengerUnit, value: float32) {.inline.} =
    setenergy(message, value)

proc clearenergyMax*(message: PassengerUnit) =
    message.energyMax = 0
    clearFields(message, [8])

proc hasenergyMax*(message: PassengerUnit): bool =
    result = hasField(message, 8)

proc setenergyMax*(message: PassengerUnit, value: float32) =
    message.energyMax = value
    setField(message, 8)

proc energyMax*(message: PassengerUnit): float32 {.inline.} =
    message.energyMax

proc `energyMax=`*(message: PassengerUnit, value: float32) {.inline.} =
    setenergyMax(message, value)

proc clearunitType*(message: PassengerUnit) =
    message.unitType = 0
    clearFields(message, [6])

proc hasunitType*(message: PassengerUnit): bool =
    result = hasField(message, 6)

proc setunitType*(message: PassengerUnit, value: uint32) =
    message.unitType = value
    setField(message, 6)

proc unitType*(message: PassengerUnit): uint32 {.inline.} =
    message.unitType

proc `unitType=`*(message: PassengerUnit, value: uint32) {.inline.} =
    setunitType(message, value)

proc `$`*(message: PassengerUnit): string =
    runnableExamples:
        echo $PassengerUnit
        echo fmt"{PassengerUnit}"
        echo &"{PassengerUnit}"
    var resultSeq: seq[string]
    if message.hastag:
        resultSeq.add(&"tag: {message.tag}")
    if message.hashealth:
        resultSeq.add(&"health: {message.health}")
    if message.hashealthMax:
        resultSeq.add(&"healthMax: {message.healthMax}")
    if message.hasshield:
        resultSeq.add(&"shield: {message.shield}")
    if message.hasshieldMax:
        resultSeq.add(&"shieldMax: {message.shieldMax}")
    if message.hasenergy:
        resultSeq.add(&"energy: {message.energy}")
    if message.hasenergyMax:
        resultSeq.add(&"energyMax: {message.energyMax}")
    if message.hasunitType:
        resultSeq.add(&"unitType: {message.unitType}")
    result = resultSeq.join(", ")
    result = &"PassengerUnit({result})"

proc sizeOfPassengerUnit*(message: PassengerUnit): uint64 =
    if hastag(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt64(message.tag)
    if hashealth(message):
        result = result + sizeOfTag(2, WireType.Fixed32)
        result = result + sizeOfFloat(message.health)
    if hashealthMax(message):
        result = result + sizeOfTag(3, WireType.Fixed32)
        result = result + sizeOfFloat(message.healthMax)
    if hasshield(message):
        result = result + sizeOfTag(4, WireType.Fixed32)
        result = result + sizeOfFloat(message.shield)
    if hasshieldMax(message):
        result = result + sizeOfTag(7, WireType.Fixed32)
        result = result + sizeOfFloat(message.shieldMax)
    if hasenergy(message):
        result = result + sizeOfTag(5, WireType.Fixed32)
        result = result + sizeOfFloat(message.energy)
    if hasenergyMax(message):
        result = result + sizeOfTag(8, WireType.Fixed32)
        result = result + sizeOfFloat(message.energyMax)
    if hasunitType(message):
        result = result + sizeOfTag(6, WireType.Varint)
        result = result + sizeOfUInt32(message.unitType)
    result = result + sizeOfUnknownFields(message)

proc writePassengerUnit*(stream: Stream, message: PassengerUnit) =
    if hastag(message):
        protoWriteUInt64(stream, message.tag, 1)
    if hashealth(message):
        protoWriteFloat(stream, message.health, 2)
    if hashealthMax(message):
        protoWriteFloat(stream, message.healthMax, 3)
    if hasshield(message):
        protoWriteFloat(stream, message.shield, 4)
    if hasshieldMax(message):
        protoWriteFloat(stream, message.shieldMax, 7)
    if hasenergy(message):
        protoWriteFloat(stream, message.energy, 5)
    if hasenergyMax(message):
        protoWriteFloat(stream, message.energyMax, 8)
    if hasunitType(message):
        protoWriteUInt32(stream, message.unitType, 6)
    writeUnknownFields(stream, message)

proc readPassengerUnit*(stream: Stream): PassengerUnit =
    result = newPassengerUnit()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            settag(result, protoReadUInt64(stream))
        of 2:
            expectWireType(wireType, WireType.Fixed32)
            sethealth(result, protoReadFloat(stream))
        of 3:
            expectWireType(wireType, WireType.Fixed32)
            sethealthMax(result, protoReadFloat(stream))
        of 4:
            expectWireType(wireType, WireType.Fixed32)
            setshield(result, protoReadFloat(stream))
        of 7:
            expectWireType(wireType, WireType.Fixed32)
            setshieldMax(result, protoReadFloat(stream))
        of 5:
            expectWireType(wireType, WireType.Fixed32)
            setenergy(result, protoReadFloat(stream))
        of 8:
            expectWireType(wireType, WireType.Fixed32)
            setenergyMax(result, protoReadFloat(stream))
        of 6:
            expectWireType(wireType, WireType.Varint)
            setunitType(result, protoReadUInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: PassengerUnit): string =
    let
        ss = newStringStream()
    writePassengerUnit(ss, message)
    result = ss.data

proc newPassengerUnit*(data: string): PassengerUnit =
    let
        ss = newStringStream(data)
    result = readPassengerUnit(ss)

proc newPassengerUnit*(data: seq[byte]): PassengerUnit =
    let
        ss = newStringStream(cast[string](data))
    result = readPassengerUnit(ss)


proc fullyQualifiedName*(T: typedesc[Unit]): string = "Unit"

proc readUnitImpl(stream: Stream): Message = readUnit(stream)
proc writeUnitImpl(stream: Stream, msg: Message) = writeUnit(stream, Unit(msg))

proc UnitProcs*(): MessageProcs =
    result.readImpl = readUnitImpl
    result.writeImpl = writeUnitImpl

proc newUnit*(): Unit =
    new(result)
    initMessage(result[])
    result.procs = UnitProcs()
    result.displayType = DisplayType.Visible
    result.alliance = Alliance.Self
    result.tag = 0
    result.unitType = 0
    result.owner = 0
    result.pos = nil
    result.facing = 0
    result.radius = 0
    result.buildProgress = 0
    result.cloak = CloakState.CloakedUnknown
    result.buffIds = @[]
    result.detectRange = 0
    result.radarRange = 0
    result.isSelected = false
    result.isOnScreen = false
    result.isBlip = false
    result.isPowered = false
    result.isActive = false
    result.attackUpgradeLevel = 0
    result.armorUpgradeLevel = 0
    result.shieldUpgradeLevel = 0
    result.health = 0
    result.healthMax = 0
    result.shield = 0
    result.shieldMax = 0
    result.energy = 0
    result.energyMax = 0
    result.mineralContents = 0
    result.vespeneContents = 0
    result.isFlying = false
    result.isBurrowed = false
    result.isHallucination = false
    result.orders = @[]
    result.addOnTag = 0
    result.passengers = @[]
    result.cargoSpaceTaken = 0
    result.cargoSpaceMax = 0
    result.assignedHarvesters = 0
    result.idealHarvesters = 0
    result.weaponCooldown = 0
    result.engagedTargetTag = 0
    result.buffDurationRemain = 0
    result.buffDurationMax = 0
    result.rallyTargets = @[]

proc cleardisplayType*(message: Unit) =
    message.displayType = DisplayType.Visible
    clearFields(message, [1])

proc hasdisplayType*(message: Unit): bool =
    result = hasField(message, 1)

proc setdisplayType*(message: Unit, value: DisplayType) =
    message.displayType = value
    setField(message, 1)

proc displayType*(message: Unit): DisplayType {.inline.} =
    message.displayType

proc `displayType=`*(message: Unit, value: DisplayType) {.inline.} =
    setdisplayType(message, value)

proc clearalliance*(message: Unit) =
    message.alliance = Alliance.Self
    clearFields(message, [2])

proc hasalliance*(message: Unit): bool =
    result = hasField(message, 2)

proc setalliance*(message: Unit, value: Alliance) =
    message.alliance = value
    setField(message, 2)

proc alliance*(message: Unit): Alliance {.inline.} =
    message.alliance

proc `alliance=`*(message: Unit, value: Alliance) {.inline.} =
    setalliance(message, value)

proc cleartag*(message: Unit) =
    message.tag = 0
    clearFields(message, [3])

proc hastag*(message: Unit): bool =
    result = hasField(message, 3)

proc settag*(message: Unit, value: uint64) =
    message.tag = value
    setField(message, 3)

proc tag*(message: Unit): uint64 {.inline.} =
    message.tag

proc `tag=`*(message: Unit, value: uint64) {.inline.} =
    settag(message, value)

proc clearunitType*(message: Unit) =
    message.unitType = 0
    clearFields(message, [4])

proc hasunitType*(message: Unit): bool =
    result = hasField(message, 4)

proc setunitType*(message: Unit, value: uint32) =
    message.unitType = value
    setField(message, 4)

proc unitType*(message: Unit): uint32 {.inline.} =
    message.unitType

proc `unitType=`*(message: Unit, value: uint32) {.inline.} =
    setunitType(message, value)

proc clearowner*(message: Unit) =
    message.owner = 0
    clearFields(message, [5])

proc hasowner*(message: Unit): bool =
    result = hasField(message, 5)

proc setowner*(message: Unit, value: int32) =
    message.owner = value
    setField(message, 5)

proc owner*(message: Unit): int32 {.inline.} =
    message.owner

proc `owner=`*(message: Unit, value: int32) {.inline.} =
    setowner(message, value)

proc clearpos*(message: Unit) =
    message.pos = nil
    clearFields(message, [6])

proc haspos*(message: Unit): bool =
    result = hasField(message, 6)

proc setpos*(message: Unit, value: Point) =
    message.pos = value
    setField(message, 6)

proc pos*(message: Unit): Point {.inline.} =
    message.pos

proc `pos=`*(message: Unit, value: Point) {.inline.} =
    setpos(message, value)

proc clearfacing*(message: Unit) =
    message.facing = 0
    clearFields(message, [7])

proc hasfacing*(message: Unit): bool =
    result = hasField(message, 7)

proc setfacing*(message: Unit, value: float32) =
    message.facing = value
    setField(message, 7)

proc facing*(message: Unit): float32 {.inline.} =
    message.facing

proc `facing=`*(message: Unit, value: float32) {.inline.} =
    setfacing(message, value)

proc clearradius*(message: Unit) =
    message.radius = 0
    clearFields(message, [8])

proc hasradius*(message: Unit): bool =
    result = hasField(message, 8)

proc setradius*(message: Unit, value: float32) =
    message.radius = value
    setField(message, 8)

proc radius*(message: Unit): float32 {.inline.} =
    message.radius

proc `radius=`*(message: Unit, value: float32) {.inline.} =
    setradius(message, value)

proc clearbuildProgress*(message: Unit) =
    message.buildProgress = 0
    clearFields(message, [9])

proc hasbuildProgress*(message: Unit): bool =
    result = hasField(message, 9)

proc setbuildProgress*(message: Unit, value: float32) =
    message.buildProgress = value
    setField(message, 9)

proc buildProgress*(message: Unit): float32 {.inline.} =
    message.buildProgress

proc `buildProgress=`*(message: Unit, value: float32) {.inline.} =
    setbuildProgress(message, value)

proc clearcloak*(message: Unit) =
    message.cloak = CloakState.CloakedUnknown
    clearFields(message, [10])

proc hascloak*(message: Unit): bool =
    result = hasField(message, 10)

proc setcloak*(message: Unit, value: CloakState) =
    message.cloak = value
    setField(message, 10)

proc cloak*(message: Unit): CloakState {.inline.} =
    message.cloak

proc `cloak=`*(message: Unit, value: CloakState) {.inline.} =
    setcloak(message, value)

proc clearbuffIds*(message: Unit) =
    message.buffIds = @[]
    clearFields(message, [27])

proc hasbuffIds*(message: Unit): bool =
    result = hasField(message, 27) or (len(message.buffIds) > 0)

proc setbuffIds*(message: Unit, value: seq[uint32]) =
    message.buffIds = value
    setField(message, 27)

proc addbuffIds*(message: Unit, value: uint32) =
    add(message.buffIds, value)

proc buffIds*(message: Unit): seq[uint32] {.inline.} =
    message.buffIds

proc `buffIds=`*(message: Unit, value: seq[uint32]) {.inline.} =
    setbuffIds(message, value)

proc cleardetectRange*(message: Unit) =
    message.detectRange = 0
    clearFields(message, [31])

proc hasdetectRange*(message: Unit): bool =
    result = hasField(message, 31)

proc setdetectRange*(message: Unit, value: float32) =
    message.detectRange = value
    setField(message, 31)

proc detectRange*(message: Unit): float32 {.inline.} =
    message.detectRange

proc `detectRange=`*(message: Unit, value: float32) {.inline.} =
    setdetectRange(message, value)

proc clearradarRange*(message: Unit) =
    message.radarRange = 0
    clearFields(message, [32])

proc hasradarRange*(message: Unit): bool =
    result = hasField(message, 32)

proc setradarRange*(message: Unit, value: float32) =
    message.radarRange = value
    setField(message, 32)

proc radarRange*(message: Unit): float32 {.inline.} =
    message.radarRange

proc `radarRange=`*(message: Unit, value: float32) {.inline.} =
    setradarRange(message, value)

proc clearisSelected*(message: Unit) =
    message.isSelected = false
    clearFields(message, [11])

proc hasisSelected*(message: Unit): bool =
    result = hasField(message, 11)

proc setisSelected*(message: Unit, value: bool) =
    message.isSelected = value
    setField(message, 11)

proc isSelected*(message: Unit): bool {.inline.} =
    message.isSelected

proc `isSelected=`*(message: Unit, value: bool) {.inline.} =
    setisSelected(message, value)

proc clearisOnScreen*(message: Unit) =
    message.isOnScreen = false
    clearFields(message, [12])

proc hasisOnScreen*(message: Unit): bool =
    result = hasField(message, 12)

proc setisOnScreen*(message: Unit, value: bool) =
    message.isOnScreen = value
    setField(message, 12)

proc isOnScreen*(message: Unit): bool {.inline.} =
    message.isOnScreen

proc `isOnScreen=`*(message: Unit, value: bool) {.inline.} =
    setisOnScreen(message, value)

proc clearisBlip*(message: Unit) =
    message.isBlip = false
    clearFields(message, [13])

proc hasisBlip*(message: Unit): bool =
    result = hasField(message, 13)

proc setisBlip*(message: Unit, value: bool) =
    message.isBlip = value
    setField(message, 13)

proc isBlip*(message: Unit): bool {.inline.} =
    message.isBlip

proc `isBlip=`*(message: Unit, value: bool) {.inline.} =
    setisBlip(message, value)

proc clearisPowered*(message: Unit) =
    message.isPowered = false
    clearFields(message, [35])

proc hasisPowered*(message: Unit): bool =
    result = hasField(message, 35)

proc setisPowered*(message: Unit, value: bool) =
    message.isPowered = value
    setField(message, 35)

proc isPowered*(message: Unit): bool {.inline.} =
    message.isPowered

proc `isPowered=`*(message: Unit, value: bool) {.inline.} =
    setisPowered(message, value)

proc clearisActive*(message: Unit) =
    message.isActive = false
    clearFields(message, [39])

proc hasisActive*(message: Unit): bool =
    result = hasField(message, 39)

proc setisActive*(message: Unit, value: bool) =
    message.isActive = value
    setField(message, 39)

proc isActive*(message: Unit): bool {.inline.} =
    message.isActive

proc `isActive=`*(message: Unit, value: bool) {.inline.} =
    setisActive(message, value)

proc clearattackUpgradeLevel*(message: Unit) =
    message.attackUpgradeLevel = 0
    clearFields(message, [40])

proc hasattackUpgradeLevel*(message: Unit): bool =
    result = hasField(message, 40)

proc setattackUpgradeLevel*(message: Unit, value: int32) =
    message.attackUpgradeLevel = value
    setField(message, 40)

proc attackUpgradeLevel*(message: Unit): int32 {.inline.} =
    message.attackUpgradeLevel

proc `attackUpgradeLevel=`*(message: Unit, value: int32) {.inline.} =
    setattackUpgradeLevel(message, value)

proc cleararmorUpgradeLevel*(message: Unit) =
    message.armorUpgradeLevel = 0
    clearFields(message, [41])

proc hasarmorUpgradeLevel*(message: Unit): bool =
    result = hasField(message, 41)

proc setarmorUpgradeLevel*(message: Unit, value: int32) =
    message.armorUpgradeLevel = value
    setField(message, 41)

proc armorUpgradeLevel*(message: Unit): int32 {.inline.} =
    message.armorUpgradeLevel

proc `armorUpgradeLevel=`*(message: Unit, value: int32) {.inline.} =
    setarmorUpgradeLevel(message, value)

proc clearshieldUpgradeLevel*(message: Unit) =
    message.shieldUpgradeLevel = 0
    clearFields(message, [42])

proc hasshieldUpgradeLevel*(message: Unit): bool =
    result = hasField(message, 42)

proc setshieldUpgradeLevel*(message: Unit, value: int32) =
    message.shieldUpgradeLevel = value
    setField(message, 42)

proc shieldUpgradeLevel*(message: Unit): int32 {.inline.} =
    message.shieldUpgradeLevel

proc `shieldUpgradeLevel=`*(message: Unit, value: int32) {.inline.} =
    setshieldUpgradeLevel(message, value)

proc clearhealth*(message: Unit) =
    message.health = 0
    clearFields(message, [14])

proc hashealth*(message: Unit): bool =
    result = hasField(message, 14)

proc sethealth*(message: Unit, value: float32) =
    message.health = value
    setField(message, 14)

proc health*(message: Unit): float32 {.inline.} =
    message.health

proc `health=`*(message: Unit, value: float32) {.inline.} =
    sethealth(message, value)

proc clearhealthMax*(message: Unit) =
    message.healthMax = 0
    clearFields(message, [15])

proc hashealthMax*(message: Unit): bool =
    result = hasField(message, 15)

proc sethealthMax*(message: Unit, value: float32) =
    message.healthMax = value
    setField(message, 15)

proc healthMax*(message: Unit): float32 {.inline.} =
    message.healthMax

proc `healthMax=`*(message: Unit, value: float32) {.inline.} =
    sethealthMax(message, value)

proc clearshield*(message: Unit) =
    message.shield = 0
    clearFields(message, [16])

proc hasshield*(message: Unit): bool =
    result = hasField(message, 16)

proc setshield*(message: Unit, value: float32) =
    message.shield = value
    setField(message, 16)

proc shield*(message: Unit): float32 {.inline.} =
    message.shield

proc `shield=`*(message: Unit, value: float32) {.inline.} =
    setshield(message, value)

proc clearshieldMax*(message: Unit) =
    message.shieldMax = 0
    clearFields(message, [36])

proc hasshieldMax*(message: Unit): bool =
    result = hasField(message, 36)

proc setshieldMax*(message: Unit, value: float32) =
    message.shieldMax = value
    setField(message, 36)

proc shieldMax*(message: Unit): float32 {.inline.} =
    message.shieldMax

proc `shieldMax=`*(message: Unit, value: float32) {.inline.} =
    setshieldMax(message, value)

proc clearenergy*(message: Unit) =
    message.energy = 0
    clearFields(message, [17])

proc hasenergy*(message: Unit): bool =
    result = hasField(message, 17)

proc setenergy*(message: Unit, value: float32) =
    message.energy = value
    setField(message, 17)

proc energy*(message: Unit): float32 {.inline.} =
    message.energy

proc `energy=`*(message: Unit, value: float32) {.inline.} =
    setenergy(message, value)

proc clearenergyMax*(message: Unit) =
    message.energyMax = 0
    clearFields(message, [37])

proc hasenergyMax*(message: Unit): bool =
    result = hasField(message, 37)

proc setenergyMax*(message: Unit, value: float32) =
    message.energyMax = value
    setField(message, 37)

proc energyMax*(message: Unit): float32 {.inline.} =
    message.energyMax

proc `energyMax=`*(message: Unit, value: float32) {.inline.} =
    setenergyMax(message, value)

proc clearmineralContents*(message: Unit) =
    message.mineralContents = 0
    clearFields(message, [18])

proc hasmineralContents*(message: Unit): bool =
    result = hasField(message, 18)

proc setmineralContents*(message: Unit, value: int32) =
    message.mineralContents = value
    setField(message, 18)

proc mineralContents*(message: Unit): int32 {.inline.} =
    message.mineralContents

proc `mineralContents=`*(message: Unit, value: int32) {.inline.} =
    setmineralContents(message, value)

proc clearvespeneContents*(message: Unit) =
    message.vespeneContents = 0
    clearFields(message, [19])

proc hasvespeneContents*(message: Unit): bool =
    result = hasField(message, 19)

proc setvespeneContents*(message: Unit, value: int32) =
    message.vespeneContents = value
    setField(message, 19)

proc vespeneContents*(message: Unit): int32 {.inline.} =
    message.vespeneContents

proc `vespeneContents=`*(message: Unit, value: int32) {.inline.} =
    setvespeneContents(message, value)

proc clearisFlying*(message: Unit) =
    message.isFlying = false
    clearFields(message, [20])

proc hasisFlying*(message: Unit): bool =
    result = hasField(message, 20)

proc setisFlying*(message: Unit, value: bool) =
    message.isFlying = value
    setField(message, 20)

proc isFlying*(message: Unit): bool {.inline.} =
    message.isFlying

proc `isFlying=`*(message: Unit, value: bool) {.inline.} =
    setisFlying(message, value)

proc clearisBurrowed*(message: Unit) =
    message.isBurrowed = false
    clearFields(message, [21])

proc hasisBurrowed*(message: Unit): bool =
    result = hasField(message, 21)

proc setisBurrowed*(message: Unit, value: bool) =
    message.isBurrowed = value
    setField(message, 21)

proc isBurrowed*(message: Unit): bool {.inline.} =
    message.isBurrowed

proc `isBurrowed=`*(message: Unit, value: bool) {.inline.} =
    setisBurrowed(message, value)

proc clearisHallucination*(message: Unit) =
    message.isHallucination = false
    clearFields(message, [38])

proc hasisHallucination*(message: Unit): bool =
    result = hasField(message, 38)

proc setisHallucination*(message: Unit, value: bool) =
    message.isHallucination = value
    setField(message, 38)

proc isHallucination*(message: Unit): bool {.inline.} =
    message.isHallucination

proc `isHallucination=`*(message: Unit, value: bool) {.inline.} =
    setisHallucination(message, value)

proc clearorders*(message: Unit) =
    message.orders = @[]
    clearFields(message, [22])

proc hasorders*(message: Unit): bool =
    result = hasField(message, 22) or (len(message.orders) > 0)

proc setorders*(message: Unit, value: seq[UnitOrder]) =
    message.orders = value
    setField(message, 22)

proc addorders*(message: Unit, value: UnitOrder) =
    add(message.orders, value)

proc orders*(message: Unit): seq[UnitOrder] {.inline.} =
    message.orders

proc `orders=`*(message: Unit, value: seq[UnitOrder]) {.inline.} =
    setorders(message, value)

proc clearaddOnTag*(message: Unit) =
    message.addOnTag = 0
    clearFields(message, [23])

proc hasaddOnTag*(message: Unit): bool =
    result = hasField(message, 23)

proc setaddOnTag*(message: Unit, value: uint64) =
    message.addOnTag = value
    setField(message, 23)

proc addOnTag*(message: Unit): uint64 {.inline.} =
    message.addOnTag

proc `addOnTag=`*(message: Unit, value: uint64) {.inline.} =
    setaddOnTag(message, value)

proc clearpassengers*(message: Unit) =
    message.passengers = @[]
    clearFields(message, [24])

proc haspassengers*(message: Unit): bool =
    result = hasField(message, 24) or (len(message.passengers) > 0)

proc setpassengers*(message: Unit, value: seq[PassengerUnit]) =
    message.passengers = value
    setField(message, 24)

proc addpassengers*(message: Unit, value: PassengerUnit) =
    add(message.passengers, value)

proc passengers*(message: Unit): seq[PassengerUnit] {.inline.} =
    message.passengers

proc `passengers=`*(message: Unit, value: seq[PassengerUnit]) {.inline.} =
    setpassengers(message, value)

proc clearcargoSpaceTaken*(message: Unit) =
    message.cargoSpaceTaken = 0
    clearFields(message, [25])

proc hascargoSpaceTaken*(message: Unit): bool =
    result = hasField(message, 25)

proc setcargoSpaceTaken*(message: Unit, value: int32) =
    message.cargoSpaceTaken = value
    setField(message, 25)

proc cargoSpaceTaken*(message: Unit): int32 {.inline.} =
    message.cargoSpaceTaken

proc `cargoSpaceTaken=`*(message: Unit, value: int32) {.inline.} =
    setcargoSpaceTaken(message, value)

proc clearcargoSpaceMax*(message: Unit) =
    message.cargoSpaceMax = 0
    clearFields(message, [26])

proc hascargoSpaceMax*(message: Unit): bool =
    result = hasField(message, 26)

proc setcargoSpaceMax*(message: Unit, value: int32) =
    message.cargoSpaceMax = value
    setField(message, 26)

proc cargoSpaceMax*(message: Unit): int32 {.inline.} =
    message.cargoSpaceMax

proc `cargoSpaceMax=`*(message: Unit, value: int32) {.inline.} =
    setcargoSpaceMax(message, value)

proc clearassignedHarvesters*(message: Unit) =
    message.assignedHarvesters = 0
    clearFields(message, [28])

proc hasassignedHarvesters*(message: Unit): bool =
    result = hasField(message, 28)

proc setassignedHarvesters*(message: Unit, value: int32) =
    message.assignedHarvesters = value
    setField(message, 28)

proc assignedHarvesters*(message: Unit): int32 {.inline.} =
    message.assignedHarvesters

proc `assignedHarvesters=`*(message: Unit, value: int32) {.inline.} =
    setassignedHarvesters(message, value)

proc clearidealHarvesters*(message: Unit) =
    message.idealHarvesters = 0
    clearFields(message, [29])

proc hasidealHarvesters*(message: Unit): bool =
    result = hasField(message, 29)

proc setidealHarvesters*(message: Unit, value: int32) =
    message.idealHarvesters = value
    setField(message, 29)

proc idealHarvesters*(message: Unit): int32 {.inline.} =
    message.idealHarvesters

proc `idealHarvesters=`*(message: Unit, value: int32) {.inline.} =
    setidealHarvesters(message, value)

proc clearweaponCooldown*(message: Unit) =
    message.weaponCooldown = 0
    clearFields(message, [30])

proc hasweaponCooldown*(message: Unit): bool =
    result = hasField(message, 30)

proc setweaponCooldown*(message: Unit, value: float32) =
    message.weaponCooldown = value
    setField(message, 30)

proc weaponCooldown*(message: Unit): float32 {.inline.} =
    message.weaponCooldown

proc `weaponCooldown=`*(message: Unit, value: float32) {.inline.} =
    setweaponCooldown(message, value)

proc clearengagedTargetTag*(message: Unit) =
    message.engagedTargetTag = 0
    clearFields(message, [34])

proc hasengagedTargetTag*(message: Unit): bool =
    result = hasField(message, 34)

proc setengagedTargetTag*(message: Unit, value: uint64) =
    message.engagedTargetTag = value
    setField(message, 34)

proc engagedTargetTag*(message: Unit): uint64 {.inline.} =
    message.engagedTargetTag

proc `engagedTargetTag=`*(message: Unit, value: uint64) {.inline.} =
    setengagedTargetTag(message, value)

proc clearbuffDurationRemain*(message: Unit) =
    message.buffDurationRemain = 0
    clearFields(message, [43])

proc hasbuffDurationRemain*(message: Unit): bool =
    result = hasField(message, 43)

proc setbuffDurationRemain*(message: Unit, value: int32) =
    message.buffDurationRemain = value
    setField(message, 43)

proc buffDurationRemain*(message: Unit): int32 {.inline.} =
    message.buffDurationRemain

proc `buffDurationRemain=`*(message: Unit, value: int32) {.inline.} =
    setbuffDurationRemain(message, value)

proc clearbuffDurationMax*(message: Unit) =
    message.buffDurationMax = 0
    clearFields(message, [44])

proc hasbuffDurationMax*(message: Unit): bool =
    result = hasField(message, 44)

proc setbuffDurationMax*(message: Unit, value: int32) =
    message.buffDurationMax = value
    setField(message, 44)

proc buffDurationMax*(message: Unit): int32 {.inline.} =
    message.buffDurationMax

proc `buffDurationMax=`*(message: Unit, value: int32) {.inline.} =
    setbuffDurationMax(message, value)

proc clearrallyTargets*(message: Unit) =
    message.rallyTargets = @[]
    clearFields(message, [45])

proc hasrallyTargets*(message: Unit): bool =
    result = hasField(message, 45) or (len(message.rallyTargets) > 0)

proc setrallyTargets*(message: Unit, value: seq[RallyTarget]) =
    message.rallyTargets = value
    setField(message, 45)

proc addrallyTargets*(message: Unit, value: RallyTarget) =
    add(message.rallyTargets, value)

proc rallyTargets*(message: Unit): seq[RallyTarget] {.inline.} =
    message.rallyTargets

proc `rallyTargets=`*(message: Unit, value: seq[RallyTarget]) {.inline.} =
    setrallyTargets(message, value)

proc `$`*(message: Unit): string =
    runnableExamples:
        echo $Unit
        echo fmt"{Unit}"
        echo &"{Unit}"
    var resultSeq: seq[string]
    if message.hasdisplayType:
        resultSeq.add(&"displayType: {message.displayType}")
    if message.hasalliance:
        resultSeq.add(&"alliance: {message.alliance}")
    if message.hastag:
        resultSeq.add(&"tag: {message.tag}")
    if message.hasunitType:
        resultSeq.add(&"unitType: {message.unitType}")
    if message.hasowner:
        resultSeq.add(&"owner: {message.owner}")
    if message.haspos:
        resultSeq.add(&"pos: {message.pos}")
    if message.hasfacing:
        resultSeq.add(&"facing: {message.facing}")
    if message.hasradius:
        resultSeq.add(&"radius: {message.radius}")
    if message.hasbuildProgress:
        resultSeq.add(&"buildProgress: {message.buildProgress}")
    if message.hascloak:
        resultSeq.add(&"cloak: {message.cloak}")
    if message.hasbuffIds:
        resultSeq.add(&"buffIds: {message.buffIds}")
    if message.hasdetectRange:
        resultSeq.add(&"detectRange: {message.detectRange}")
    if message.hasradarRange:
        resultSeq.add(&"radarRange: {message.radarRange}")
    if message.hasisSelected:
        resultSeq.add(&"isSelected: {message.isSelected}")
    if message.hasisOnScreen:
        resultSeq.add(&"isOnScreen: {message.isOnScreen}")
    if message.hasisBlip:
        resultSeq.add(&"isBlip: {message.isBlip}")
    if message.hasisPowered:
        resultSeq.add(&"isPowered: {message.isPowered}")
    if message.hasisActive:
        resultSeq.add(&"isActive: {message.isActive}")
    if message.hasattackUpgradeLevel:
        resultSeq.add(&"attackUpgradeLevel: {message.attackUpgradeLevel}")
    if message.hasarmorUpgradeLevel:
        resultSeq.add(&"armorUpgradeLevel: {message.armorUpgradeLevel}")
    if message.hasshieldUpgradeLevel:
        resultSeq.add(&"shieldUpgradeLevel: {message.shieldUpgradeLevel}")
    if message.hashealth:
        resultSeq.add(&"health: {message.health}")
    if message.hashealthMax:
        resultSeq.add(&"healthMax: {message.healthMax}")
    if message.hasshield:
        resultSeq.add(&"shield: {message.shield}")
    if message.hasshieldMax:
        resultSeq.add(&"shieldMax: {message.shieldMax}")
    if message.hasenergy:
        resultSeq.add(&"energy: {message.energy}")
    if message.hasenergyMax:
        resultSeq.add(&"energyMax: {message.energyMax}")
    if message.hasmineralContents:
        resultSeq.add(&"mineralContents: {message.mineralContents}")
    if message.hasvespeneContents:
        resultSeq.add(&"vespeneContents: {message.vespeneContents}")
    if message.hasisFlying:
        resultSeq.add(&"isFlying: {message.isFlying}")
    if message.hasisBurrowed:
        resultSeq.add(&"isBurrowed: {message.isBurrowed}")
    if message.hasisHallucination:
        resultSeq.add(&"isHallucination: {message.isHallucination}")
    if message.hasorders:
        resultSeq.add(&"orders: {message.orders}")
    if message.hasaddOnTag:
        resultSeq.add(&"addOnTag: {message.addOnTag}")
    if message.haspassengers:
        resultSeq.add(&"passengers: {message.passengers}")
    if message.hascargoSpaceTaken:
        resultSeq.add(&"cargoSpaceTaken: {message.cargoSpaceTaken}")
    if message.hascargoSpaceMax:
        resultSeq.add(&"cargoSpaceMax: {message.cargoSpaceMax}")
    if message.hasassignedHarvesters:
        resultSeq.add(&"assignedHarvesters: {message.assignedHarvesters}")
    if message.hasidealHarvesters:
        resultSeq.add(&"idealHarvesters: {message.idealHarvesters}")
    if message.hasweaponCooldown:
        resultSeq.add(&"weaponCooldown: {message.weaponCooldown}")
    if message.hasengagedTargetTag:
        resultSeq.add(&"engagedTargetTag: {message.engagedTargetTag}")
    if message.hasbuffDurationRemain:
        resultSeq.add(&"buffDurationRemain: {message.buffDurationRemain}")
    if message.hasbuffDurationMax:
        resultSeq.add(&"buffDurationMax: {message.buffDurationMax}")
    if message.hasrallyTargets:
        resultSeq.add(&"rallyTargets: {message.rallyTargets}")
    result = resultSeq.join(", ")
    result = &"Unit({result})"

proc sizeOfUnit*(message: Unit): uint64 =
    if hasdisplayType(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfEnum[DisplayType](message.displayType)
    if hasalliance(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfEnum[Alliance](message.alliance)
    if hastag(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfUInt64(message.tag)
    if hasunitType(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfUInt32(message.unitType)
    if hasowner(message):
        result = result + sizeOfTag(5, WireType.Varint)
        result = result + sizeOfInt32(message.owner)
    if haspos(message):
        result = result + sizeOfTag(6, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint(message.pos))
    if hasfacing(message):
        result = result + sizeOfTag(7, WireType.Fixed32)
        result = result + sizeOfFloat(message.facing)
    if hasradius(message):
        result = result + sizeOfTag(8, WireType.Fixed32)
        result = result + sizeOfFloat(message.radius)
    if hasbuildProgress(message):
        result = result + sizeOfTag(9, WireType.Fixed32)
        result = result + sizeOfFloat(message.buildProgress)
    if hascloak(message):
        result = result + sizeOfTag(10, WireType.Varint)
        result = result + sizeOfEnum[CloakState](message.cloak)
    if len(message.buffIds) > 0:
        result = result + sizeOfTag(27, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(packedFieldSize(message.buffIds, FieldType.UInt32))
    if hasdetectRange(message):
        result = result + sizeOfTag(31, WireType.Fixed32)
        result = result + sizeOfFloat(message.detectRange)
    if hasradarRange(message):
        result = result + sizeOfTag(32, WireType.Fixed32)
        result = result + sizeOfFloat(message.radarRange)
    if hasisSelected(message):
        result = result + sizeOfTag(11, WireType.Varint)
        result = result + sizeOfBool(message.isSelected)
    if hasisOnScreen(message):
        result = result + sizeOfTag(12, WireType.Varint)
        result = result + sizeOfBool(message.isOnScreen)
    if hasisBlip(message):
        result = result + sizeOfTag(13, WireType.Varint)
        result = result + sizeOfBool(message.isBlip)
    if hasisPowered(message):
        result = result + sizeOfTag(35, WireType.Varint)
        result = result + sizeOfBool(message.isPowered)
    if hasisActive(message):
        result = result + sizeOfTag(39, WireType.Varint)
        result = result + sizeOfBool(message.isActive)
    if hasattackUpgradeLevel(message):
        result = result + sizeOfTag(40, WireType.Varint)
        result = result + sizeOfInt32(message.attackUpgradeLevel)
    if hasarmorUpgradeLevel(message):
        result = result + sizeOfTag(41, WireType.Varint)
        result = result + sizeOfInt32(message.armorUpgradeLevel)
    if hasshieldUpgradeLevel(message):
        result = result + sizeOfTag(42, WireType.Varint)
        result = result + sizeOfInt32(message.shieldUpgradeLevel)
    if hashealth(message):
        result = result + sizeOfTag(14, WireType.Fixed32)
        result = result + sizeOfFloat(message.health)
    if hashealthMax(message):
        result = result + sizeOfTag(15, WireType.Fixed32)
        result = result + sizeOfFloat(message.healthMax)
    if hasshield(message):
        result = result + sizeOfTag(16, WireType.Fixed32)
        result = result + sizeOfFloat(message.shield)
    if hasshieldMax(message):
        result = result + sizeOfTag(36, WireType.Fixed32)
        result = result + sizeOfFloat(message.shieldMax)
    if hasenergy(message):
        result = result + sizeOfTag(17, WireType.Fixed32)
        result = result + sizeOfFloat(message.energy)
    if hasenergyMax(message):
        result = result + sizeOfTag(37, WireType.Fixed32)
        result = result + sizeOfFloat(message.energyMax)
    if hasmineralContents(message):
        result = result + sizeOfTag(18, WireType.Varint)
        result = result + sizeOfInt32(message.mineralContents)
    if hasvespeneContents(message):
        result = result + sizeOfTag(19, WireType.Varint)
        result = result + sizeOfInt32(message.vespeneContents)
    if hasisFlying(message):
        result = result + sizeOfTag(20, WireType.Varint)
        result = result + sizeOfBool(message.isFlying)
    if hasisBurrowed(message):
        result = result + sizeOfTag(21, WireType.Varint)
        result = result + sizeOfBool(message.isBurrowed)
    if hasisHallucination(message):
        result = result + sizeOfTag(38, WireType.Varint)
        result = result + sizeOfBool(message.isHallucination)
    for value in message.orders:
        result = result + sizeOfTag(22, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfUnitOrder(value))
    if hasaddOnTag(message):
        result = result + sizeOfTag(23, WireType.Varint)
        result = result + sizeOfUInt64(message.addOnTag)
    for value in message.passengers:
        result = result + sizeOfTag(24, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPassengerUnit(value))
    if hascargoSpaceTaken(message):
        result = result + sizeOfTag(25, WireType.Varint)
        result = result + sizeOfInt32(message.cargoSpaceTaken)
    if hascargoSpaceMax(message):
        result = result + sizeOfTag(26, WireType.Varint)
        result = result + sizeOfInt32(message.cargoSpaceMax)
    if hasassignedHarvesters(message):
        result = result + sizeOfTag(28, WireType.Varint)
        result = result + sizeOfInt32(message.assignedHarvesters)
    if hasidealHarvesters(message):
        result = result + sizeOfTag(29, WireType.Varint)
        result = result + sizeOfInt32(message.idealHarvesters)
    if hasweaponCooldown(message):
        result = result + sizeOfTag(30, WireType.Fixed32)
        result = result + sizeOfFloat(message.weaponCooldown)
    if hasengagedTargetTag(message):
        result = result + sizeOfTag(34, WireType.Varint)
        result = result + sizeOfUInt64(message.engagedTargetTag)
    if hasbuffDurationRemain(message):
        result = result + sizeOfTag(43, WireType.Varint)
        result = result + sizeOfInt32(message.buffDurationRemain)
    if hasbuffDurationMax(message):
        result = result + sizeOfTag(44, WireType.Varint)
        result = result + sizeOfInt32(message.buffDurationMax)
    for value in message.rallyTargets:
        result = result + sizeOfTag(45, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRallyTarget(value))
    result = result + sizeOfUnknownFields(message)

proc writeUnit*(stream: Stream, message: Unit) =
    if hasdisplayType(message):
        protoWriteEnum(stream, message.displayType, 1)
    if hasalliance(message):
        protoWriteEnum(stream, message.alliance, 2)
    if hastag(message):
        protoWriteUInt64(stream, message.tag, 3)
    if hasunitType(message):
        protoWriteUInt32(stream, message.unitType, 4)
    if hasowner(message):
        protoWriteInt32(stream, message.owner, 5)
    if haspos(message):
        writeMessage(stream, message.pos, 6)
    if hasfacing(message):
        protoWriteFloat(stream, message.facing, 7)
    if hasradius(message):
        protoWriteFloat(stream, message.radius, 8)
    if hasbuildProgress(message):
        protoWriteFloat(stream, message.buildProgress, 9)
    if hascloak(message):
        protoWriteEnum(stream, message.cloak, 10)
    for value in message.buffIds:
        protoWriteUInt32(stream, value, 27)
    if hasdetectRange(message):
        protoWriteFloat(stream, message.detectRange, 31)
    if hasradarRange(message):
        protoWriteFloat(stream, message.radarRange, 32)
    if hasisSelected(message):
        protoWriteBool(stream, message.isSelected, 11)
    if hasisOnScreen(message):
        protoWriteBool(stream, message.isOnScreen, 12)
    if hasisBlip(message):
        protoWriteBool(stream, message.isBlip, 13)
    if hasisPowered(message):
        protoWriteBool(stream, message.isPowered, 35)
    if hasisActive(message):
        protoWriteBool(stream, message.isActive, 39)
    if hasattackUpgradeLevel(message):
        protoWriteInt32(stream, message.attackUpgradeLevel, 40)
    if hasarmorUpgradeLevel(message):
        protoWriteInt32(stream, message.armorUpgradeLevel, 41)
    if hasshieldUpgradeLevel(message):
        protoWriteInt32(stream, message.shieldUpgradeLevel, 42)
    if hashealth(message):
        protoWriteFloat(stream, message.health, 14)
    if hashealthMax(message):
        protoWriteFloat(stream, message.healthMax, 15)
    if hasshield(message):
        protoWriteFloat(stream, message.shield, 16)
    if hasshieldMax(message):
        protoWriteFloat(stream, message.shieldMax, 36)
    if hasenergy(message):
        protoWriteFloat(stream, message.energy, 17)
    if hasenergyMax(message):
        protoWriteFloat(stream, message.energyMax, 37)
    if hasmineralContents(message):
        protoWriteInt32(stream, message.mineralContents, 18)
    if hasvespeneContents(message):
        protoWriteInt32(stream, message.vespeneContents, 19)
    if hasisFlying(message):
        protoWriteBool(stream, message.isFlying, 20)
    if hasisBurrowed(message):
        protoWriteBool(stream, message.isBurrowed, 21)
    if hasisHallucination(message):
        protoWriteBool(stream, message.isHallucination, 38)
    for value in message.orders:
        writeMessage(stream, value, 22)
    if hasaddOnTag(message):
        protoWriteUInt64(stream, message.addOnTag, 23)
    for value in message.passengers:
        writeMessage(stream, value, 24)
    if hascargoSpaceTaken(message):
        protoWriteInt32(stream, message.cargoSpaceTaken, 25)
    if hascargoSpaceMax(message):
        protoWriteInt32(stream, message.cargoSpaceMax, 26)
    if hasassignedHarvesters(message):
        protoWriteInt32(stream, message.assignedHarvesters, 28)
    if hasidealHarvesters(message):
        protoWriteInt32(stream, message.idealHarvesters, 29)
    if hasweaponCooldown(message):
        protoWriteFloat(stream, message.weaponCooldown, 30)
    if hasengagedTargetTag(message):
        protoWriteUInt64(stream, message.engagedTargetTag, 34)
    if hasbuffDurationRemain(message):
        protoWriteInt32(stream, message.buffDurationRemain, 43)
    if hasbuffDurationMax(message):
        protoWriteInt32(stream, message.buffDurationMax, 44)
    for value in message.rallyTargets:
        writeMessage(stream, value, 45)
    writeUnknownFields(stream, message)

proc readUnit*(stream: Stream): Unit =
    result = newUnit()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setdisplayType(result, protoReadEnum[DisplayType](stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setalliance(result, protoReadEnum[Alliance](stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            settag(result, protoReadUInt64(stream))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setunitType(result, protoReadUInt32(stream))
        of 5:
            expectWireType(wireType, WireType.Varint)
            setowner(result, protoReadInt32(stream))
        of 6:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setpos(result, newPoint(data))
        of 7:
            expectWireType(wireType, WireType.Fixed32)
            setfacing(result, protoReadFloat(stream))
        of 8:
            expectWireType(wireType, WireType.Fixed32)
            setradius(result, protoReadFloat(stream))
        of 9:
            expectWireType(wireType, WireType.Fixed32)
            setbuildProgress(result, protoReadFloat(stream))
        of 10:
            expectWireType(wireType, WireType.Varint)
            setcloak(result, protoReadEnum[CloakState](stream))
        of 27:
            expectWireType(wireType, WireType.Varint, WireType.LengthDelimited)
            if wireType == WireType.LengthDelimited:
                let
                    size = readVarint(stream)
                    start = uint64(getPosition(stream))
                var consumed = 0'u64
                while consumed < size:
                    addbuffIds(result, protoReadUInt32(stream))
                    consumed = uint64(getPosition(stream)) - start
                if consumed != size:
                    raise newException(Exception, "packed field size mismatch")
            else:
                addbuffIds(result, protoReadUInt32(stream))
        of 31:
            expectWireType(wireType, WireType.Fixed32)
            setdetectRange(result, protoReadFloat(stream))
        of 32:
            expectWireType(wireType, WireType.Fixed32)
            setradarRange(result, protoReadFloat(stream))
        of 11:
            expectWireType(wireType, WireType.Varint)
            setisSelected(result, protoReadBool(stream))
        of 12:
            expectWireType(wireType, WireType.Varint)
            setisOnScreen(result, protoReadBool(stream))
        of 13:
            expectWireType(wireType, WireType.Varint)
            setisBlip(result, protoReadBool(stream))
        of 35:
            expectWireType(wireType, WireType.Varint)
            setisPowered(result, protoReadBool(stream))
        of 39:
            expectWireType(wireType, WireType.Varint)
            setisActive(result, protoReadBool(stream))
        of 40:
            expectWireType(wireType, WireType.Varint)
            setattackUpgradeLevel(result, protoReadInt32(stream))
        of 41:
            expectWireType(wireType, WireType.Varint)
            setarmorUpgradeLevel(result, protoReadInt32(stream))
        of 42:
            expectWireType(wireType, WireType.Varint)
            setshieldUpgradeLevel(result, protoReadInt32(stream))
        of 14:
            expectWireType(wireType, WireType.Fixed32)
            sethealth(result, protoReadFloat(stream))
        of 15:
            expectWireType(wireType, WireType.Fixed32)
            sethealthMax(result, protoReadFloat(stream))
        of 16:
            expectWireType(wireType, WireType.Fixed32)
            setshield(result, protoReadFloat(stream))
        of 36:
            expectWireType(wireType, WireType.Fixed32)
            setshieldMax(result, protoReadFloat(stream))
        of 17:
            expectWireType(wireType, WireType.Fixed32)
            setenergy(result, protoReadFloat(stream))
        of 37:
            expectWireType(wireType, WireType.Fixed32)
            setenergyMax(result, protoReadFloat(stream))
        of 18:
            expectWireType(wireType, WireType.Varint)
            setmineralContents(result, protoReadInt32(stream))
        of 19:
            expectWireType(wireType, WireType.Varint)
            setvespeneContents(result, protoReadInt32(stream))
        of 20:
            expectWireType(wireType, WireType.Varint)
            setisFlying(result, protoReadBool(stream))
        of 21:
            expectWireType(wireType, WireType.Varint)
            setisBurrowed(result, protoReadBool(stream))
        of 38:
            expectWireType(wireType, WireType.Varint)
            setisHallucination(result, protoReadBool(stream))
        of 22:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addorders(result, newUnitOrder(data))
        of 23:
            expectWireType(wireType, WireType.Varint)
            setaddOnTag(result, protoReadUInt64(stream))
        of 24:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addpassengers(result, newPassengerUnit(data))
        of 25:
            expectWireType(wireType, WireType.Varint)
            setcargoSpaceTaken(result, protoReadInt32(stream))
        of 26:
            expectWireType(wireType, WireType.Varint)
            setcargoSpaceMax(result, protoReadInt32(stream))
        of 28:
            expectWireType(wireType, WireType.Varint)
            setassignedHarvesters(result, protoReadInt32(stream))
        of 29:
            expectWireType(wireType, WireType.Varint)
            setidealHarvesters(result, protoReadInt32(stream))
        of 30:
            expectWireType(wireType, WireType.Fixed32)
            setweaponCooldown(result, protoReadFloat(stream))
        of 34:
            expectWireType(wireType, WireType.Varint)
            setengagedTargetTag(result, protoReadUInt64(stream))
        of 43:
            expectWireType(wireType, WireType.Varint)
            setbuffDurationRemain(result, protoReadInt32(stream))
        of 44:
            expectWireType(wireType, WireType.Varint)
            setbuffDurationMax(result, protoReadInt32(stream))
        of 45:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addrallyTargets(result, newRallyTarget(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: Unit): string =
    let
        ss = newStringStream()
    writeUnit(ss, message)
    result = ss.data

proc newUnit*(data: string): Unit =
    let
        ss = newStringStream(data)
    result = readUnit(ss)

proc newUnit*(data: seq[byte]): Unit =
    let
        ss = newStringStream(cast[string](data))
    result = readUnit(ss)


proc fullyQualifiedName*(T: typedesc[ActionRawUnitCommand]): string = "ActionRawUnitCommand"

proc readActionRawUnitCommandImpl(stream: Stream): Message = readActionRawUnitCommand(stream)
proc writeActionRawUnitCommandImpl(stream: Stream, msg: Message) = writeActionRawUnitCommand(stream, ActionRawUnitCommand(msg))

proc ActionRawUnitCommandProcs*(): MessageProcs =
    result.readImpl = readActionRawUnitCommandImpl
    result.writeImpl = writeActionRawUnitCommandImpl

proc newActionRawUnitCommand*(): ActionRawUnitCommand =
    new(result)
    initMessage(result[])
    result.procs = ActionRawUnitCommandProcs()
    result.abilityId = 0
    result.unitTags = @[]
    result.queueCommand = false
    result.target = ActionRawUnitCommand_target_OneOf(kind: ActionRawUnitCommand_target_Kind.NotSet)

proc clearabilityId*(message: ActionRawUnitCommand) =
    message.abilityId = 0
    clearFields(message, [1])

proc hasabilityId*(message: ActionRawUnitCommand): bool =
    result = hasField(message, 1)

proc setabilityId*(message: ActionRawUnitCommand, value: int32) =
    message.abilityId = value
    setField(message, 1)

proc abilityId*(message: ActionRawUnitCommand): int32 {.inline.} =
    message.abilityId

proc `abilityId=`*(message: ActionRawUnitCommand, value: int32) {.inline.} =
    setabilityId(message, value)

proc cleartargetWorldSpacePos*(message: ActionRawUnitCommand) =
    reset(message.target)
    message.target.kind = ActionRawUnitCommand_target_Kind.NotSet
    clearFields(message, [2, 3])

proc hastargetWorldSpacePos*(message: ActionRawUnitCommand): bool =
    result = hasField(message, 2)

proc settargetWorldSpacePos*(message: ActionRawUnitCommand, value: Point2D) =
    if message.target.kind != ActionRawUnitCommand_target_Kind.TargetWorldSpacePos:
        message.target = ActionRawUnitCommand_target_OneOf(kind: ActionRawUnitCommand_target_Kind.TargetWorldSpacePos, targetWorldSpacePos: value)
    else:
        message.target.targetWorldSpacePos = value
    setField(message, 2)
    clearFields(message, [3])

proc targetWorldSpacePos*(message: ActionRawUnitCommand): Point2D {.inline.} =
    message.target.targetWorldSpacePos

proc `targetWorldSpacePos=`*(message: ActionRawUnitCommand, value: Point2D) {.inline.} =
    settargetWorldSpacePos(message, value)

proc cleartargetUnitTag*(message: ActionRawUnitCommand) =
    reset(message.target)
    message.target.kind = ActionRawUnitCommand_target_Kind.NotSet
    clearFields(message, [3, 2])

proc hastargetUnitTag*(message: ActionRawUnitCommand): bool =
    result = hasField(message, 3)

proc settargetUnitTag*(message: ActionRawUnitCommand, value: uint64) =
    if message.target.kind != ActionRawUnitCommand_target_Kind.TargetUnitTag:
        message.target = ActionRawUnitCommand_target_OneOf(kind: ActionRawUnitCommand_target_Kind.TargetUnitTag, targetUnitTag: value)
    else:
        message.target.targetUnitTag = value
    setField(message, 3)
    clearFields(message, [2])

proc targetUnitTag*(message: ActionRawUnitCommand): uint64 {.inline.} =
    message.target.targetUnitTag

proc `targetUnitTag=`*(message: ActionRawUnitCommand, value: uint64) {.inline.} =
    settargetUnitTag(message, value)

proc clearunitTags*(message: ActionRawUnitCommand) =
    message.unitTags = @[]
    clearFields(message, [4])

proc hasunitTags*(message: ActionRawUnitCommand): bool =
    result = hasField(message, 4) or (len(message.unitTags) > 0)

proc setunitTags*(message: ActionRawUnitCommand, value: seq[uint64]) =
    message.unitTags = value
    setField(message, 4)

proc addunitTags*(message: ActionRawUnitCommand, value: uint64) =
    add(message.unitTags, value)

proc unitTags*(message: ActionRawUnitCommand): seq[uint64] {.inline.} =
    message.unitTags

proc `unitTags=`*(message: ActionRawUnitCommand, value: seq[uint64]) {.inline.} =
    setunitTags(message, value)

proc clearqueueCommand*(message: ActionRawUnitCommand) =
    message.queueCommand = false
    clearFields(message, [5])

proc hasqueueCommand*(message: ActionRawUnitCommand): bool =
    result = hasField(message, 5)

proc setqueueCommand*(message: ActionRawUnitCommand, value: bool) =
    message.queueCommand = value
    setField(message, 5)

proc queueCommand*(message: ActionRawUnitCommand): bool {.inline.} =
    message.queueCommand

proc `queueCommand=`*(message: ActionRawUnitCommand, value: bool) {.inline.} =
    setqueueCommand(message, value)

proc `$`*(message: ActionRawUnitCommand): string =
    runnableExamples:
        echo $ActionRawUnitCommand
        echo fmt"{ActionRawUnitCommand}"
        echo &"{ActionRawUnitCommand}"
    var resultSeq: seq[string]
    if message.hasabilityId:
        resultSeq.add(&"abilityId: {message.abilityId}")
    if message.hasunitTags:
        resultSeq.add(&"unitTags: {message.unitTags}")
    if message.hasqueueCommand:
        resultSeq.add(&"queueCommand: {message.queueCommand}")
    if message.hastargetWorldSpacePos:
        resultSeq.add(&"targetWorldSpacePos: {message.targetWorldSpacePos}")
    if message.hastargetUnitTag:
        resultSeq.add(&"targetUnitTag: {message.targetUnitTag}")
    result = resultSeq.join(", ")
    result = &"ActionRawUnitCommand({result})"

proc sizeOfActionRawUnitCommand*(message: ActionRawUnitCommand): uint64 =
    if hasabilityId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfInt32(message.abilityId)
    if hastargetWorldSpacePos(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint2D(message.target.targetWorldSpacePos))
    if hastargetUnitTag(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfUInt64(message.target.targetUnitTag)
    if len(message.unitTags) > 0:
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(packedFieldSize(message.unitTags, FieldType.UInt64))
    if hasqueueCommand(message):
        result = result + sizeOfTag(5, WireType.Varint)
        result = result + sizeOfBool(message.queueCommand)
    result = result + sizeOfUnknownFields(message)

proc writeActionRawUnitCommand*(stream: Stream, message: ActionRawUnitCommand) =
    if hasabilityId(message):
        protoWriteInt32(stream, message.abilityId, 1)
    if hastargetWorldSpacePos(message):
        writeMessage(stream, message.target.targetWorldSpacePos, 2)
    if hastargetUnitTag(message):
        protoWriteUInt64(stream, message.target.targetUnitTag, 3)
    for value in message.unitTags:
        protoWriteUInt64(stream, value, 4)
    if hasqueueCommand(message):
        protoWriteBool(stream, message.queueCommand, 5)
    writeUnknownFields(stream, message)

proc readActionRawUnitCommand*(stream: Stream): ActionRawUnitCommand =
    result = newActionRawUnitCommand()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setabilityId(result, protoReadInt32(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            settargetWorldSpacePos(result, newPoint2D(data))
        of 3:
            expectWireType(wireType, WireType.Varint)
            settargetUnitTag(result, protoReadUInt64(stream))
        of 4:
            expectWireType(wireType, WireType.Varint, WireType.LengthDelimited)
            if wireType == WireType.LengthDelimited:
                let
                    size = readVarint(stream)
                    start = uint64(getPosition(stream))
                var consumed = 0'u64
                while consumed < size:
                    addunitTags(result, protoReadUInt64(stream))
                    consumed = uint64(getPosition(stream)) - start
                if consumed != size:
                    raise newException(Exception, "packed field size mismatch")
            else:
                addunitTags(result, protoReadUInt64(stream))
        of 5:
            expectWireType(wireType, WireType.Varint)
            setqueueCommand(result, protoReadBool(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionRawUnitCommand): string =
    let
        ss = newStringStream()
    writeActionRawUnitCommand(ss, message)
    result = ss.data

proc newActionRawUnitCommand*(data: string): ActionRawUnitCommand =
    let
        ss = newStringStream(data)
    result = readActionRawUnitCommand(ss)

proc newActionRawUnitCommand*(data: seq[byte]): ActionRawUnitCommand =
    let
        ss = newStringStream(cast[string](data))
    result = readActionRawUnitCommand(ss)


proc fullyQualifiedName*(T: typedesc[ActionRawCameraMove]): string = "ActionRawCameraMove"

proc readActionRawCameraMoveImpl(stream: Stream): Message = readActionRawCameraMove(stream)
proc writeActionRawCameraMoveImpl(stream: Stream, msg: Message) = writeActionRawCameraMove(stream, ActionRawCameraMove(msg))

proc ActionRawCameraMoveProcs*(): MessageProcs =
    result.readImpl = readActionRawCameraMoveImpl
    result.writeImpl = writeActionRawCameraMoveImpl

proc newActionRawCameraMove*(): ActionRawCameraMove =
    new(result)
    initMessage(result[])
    result.procs = ActionRawCameraMoveProcs()
    result.centerWorldSpace = nil

proc clearcenterWorldSpace*(message: ActionRawCameraMove) =
    message.centerWorldSpace = nil
    clearFields(message, [1])

proc hascenterWorldSpace*(message: ActionRawCameraMove): bool =
    result = hasField(message, 1)

proc setcenterWorldSpace*(message: ActionRawCameraMove, value: Point) =
    message.centerWorldSpace = value
    setField(message, 1)

proc centerWorldSpace*(message: ActionRawCameraMove): Point {.inline.} =
    message.centerWorldSpace

proc `centerWorldSpace=`*(message: ActionRawCameraMove, value: Point) {.inline.} =
    setcenterWorldSpace(message, value)

proc `$`*(message: ActionRawCameraMove): string =
    runnableExamples:
        echo $ActionRawCameraMove
        echo fmt"{ActionRawCameraMove}"
        echo &"{ActionRawCameraMove}"
    var resultSeq: seq[string]
    if message.hascenterWorldSpace:
        resultSeq.add(&"centerWorldSpace: {message.centerWorldSpace}")
    result = resultSeq.join(", ")
    result = &"ActionRawCameraMove({result})"

proc sizeOfActionRawCameraMove*(message: ActionRawCameraMove): uint64 =
    if hascenterWorldSpace(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint(message.centerWorldSpace))
    result = result + sizeOfUnknownFields(message)

proc writeActionRawCameraMove*(stream: Stream, message: ActionRawCameraMove) =
    if hascenterWorldSpace(message):
        writeMessage(stream, message.centerWorldSpace, 1)
    writeUnknownFields(stream, message)

proc readActionRawCameraMove*(stream: Stream): ActionRawCameraMove =
    result = newActionRawCameraMove()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcenterWorldSpace(result, newPoint(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionRawCameraMove): string =
    let
        ss = newStringStream()
    writeActionRawCameraMove(ss, message)
    result = ss.data

proc newActionRawCameraMove*(data: string): ActionRawCameraMove =
    let
        ss = newStringStream(data)
    result = readActionRawCameraMove(ss)

proc newActionRawCameraMove*(data: seq[byte]): ActionRawCameraMove =
    let
        ss = newStringStream(cast[string](data))
    result = readActionRawCameraMove(ss)


proc fullyQualifiedName*(T: typedesc[ActionRaw]): string = "ActionRaw"

proc readActionRawImpl(stream: Stream): Message = readActionRaw(stream)
proc writeActionRawImpl(stream: Stream, msg: Message) = writeActionRaw(stream, ActionRaw(msg))

proc ActionRawProcs*(): MessageProcs =
    result.readImpl = readActionRawImpl
    result.writeImpl = writeActionRawImpl

proc newActionRaw*(): ActionRaw =
    new(result)
    initMessage(result[])
    result.procs = ActionRawProcs()
    result.action = ActionRaw_action_OneOf(kind: ActionRaw_action_Kind.NotSet)

proc clearunitCommand*(message: ActionRaw) =
    reset(message.action)
    message.action.kind = ActionRaw_action_Kind.NotSet
    clearFields(message, [1, 2, 3])

proc hasunitCommand*(message: ActionRaw): bool =
    result = hasField(message, 1)

proc setunitCommand*(message: ActionRaw, value: ActionRawUnitCommand) =
    if message.action.kind != ActionRaw_action_Kind.UnitCommand:
        message.action = ActionRaw_action_OneOf(kind: ActionRaw_action_Kind.UnitCommand, unitCommand: value)
    else:
        message.action.unitCommand = value
    setField(message, 1)
    clearFields(message, [2, 3])

proc unitCommand*(message: ActionRaw): ActionRawUnitCommand {.inline.} =
    message.action.unitCommand

proc `unitCommand=`*(message: ActionRaw, value: ActionRawUnitCommand) {.inline.} =
    setunitCommand(message, value)

proc clearcameraMove*(message: ActionRaw) =
    reset(message.action)
    message.action.kind = ActionRaw_action_Kind.NotSet
    clearFields(message, [2, 1, 3])

proc hascameraMove*(message: ActionRaw): bool =
    result = hasField(message, 2)

proc setcameraMove*(message: ActionRaw, value: ActionRawCameraMove) =
    if message.action.kind != ActionRaw_action_Kind.CameraMove:
        message.action = ActionRaw_action_OneOf(kind: ActionRaw_action_Kind.CameraMove, cameraMove: value)
    else:
        message.action.cameraMove = value
    setField(message, 2)
    clearFields(message, [1, 3])

proc cameraMove*(message: ActionRaw): ActionRawCameraMove {.inline.} =
    message.action.cameraMove

proc `cameraMove=`*(message: ActionRaw, value: ActionRawCameraMove) {.inline.} =
    setcameraMove(message, value)

proc cleartoggleAutocast*(message: ActionRaw) =
    reset(message.action)
    message.action.kind = ActionRaw_action_Kind.NotSet
    clearFields(message, [3, 1, 2])

proc hastoggleAutocast*(message: ActionRaw): bool =
    result = hasField(message, 3)

proc settoggleAutocast*(message: ActionRaw, value: ActionRawToggleAutocast) =
    if message.action.kind != ActionRaw_action_Kind.ToggleAutocast:
        message.action = ActionRaw_action_OneOf(kind: ActionRaw_action_Kind.ToggleAutocast, toggleAutocast: value)
    else:
        message.action.toggleAutocast = value
    setField(message, 3)
    clearFields(message, [1, 2])

proc toggleAutocast*(message: ActionRaw): ActionRawToggleAutocast {.inline.} =
    message.action.toggleAutocast

proc `toggleAutocast=`*(message: ActionRaw, value: ActionRawToggleAutocast) {.inline.} =
    settoggleAutocast(message, value)

proc `$`*(message: ActionRaw): string =
    runnableExamples:
        echo $ActionRaw
        echo fmt"{ActionRaw}"
        echo &"{ActionRaw}"
    var resultSeq: seq[string]
    if message.hasunitCommand:
        resultSeq.add(&"unitCommand: {message.unitCommand}")
    if message.hascameraMove:
        resultSeq.add(&"cameraMove: {message.cameraMove}")
    if message.hastoggleAutocast:
        resultSeq.add(&"toggleAutocast: {message.toggleAutocast}")
    result = resultSeq.join(", ")
    result = &"ActionRaw({result})"

proc sizeOfActionRaw*(message: ActionRaw): uint64 =
    if hasunitCommand(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionRawUnitCommand(message.action.unitCommand))
    if hascameraMove(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionRawCameraMove(message.action.cameraMove))
    if hastoggleAutocast(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionRawToggleAutocast(message.action.toggleAutocast))
    result = result + sizeOfUnknownFields(message)

proc writeActionRaw*(stream: Stream, message: ActionRaw) =
    if hasunitCommand(message):
        writeMessage(stream, message.action.unitCommand, 1)
    if hascameraMove(message):
        writeMessage(stream, message.action.cameraMove, 2)
    if hastoggleAutocast(message):
        writeMessage(stream, message.action.toggleAutocast, 3)
    writeUnknownFields(stream, message)

proc readActionRaw*(stream: Stream): ActionRaw =
    result = newActionRaw()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunitCommand(result, newActionRawUnitCommand(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcameraMove(result, newActionRawCameraMove(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            settoggleAutocast(result, newActionRawToggleAutocast(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionRaw): string =
    let
        ss = newStringStream()
    writeActionRaw(ss, message)
    result = ss.data

proc newActionRaw*(data: string): ActionRaw =
    let
        ss = newStringStream(data)
    result = readActionRaw(ss)

proc newActionRaw*(data: seq[byte]): ActionRaw =
    let
        ss = newStringStream(cast[string](data))
    result = readActionRaw(ss)


proc fullyQualifiedName*(T: typedesc[RadarRing]): string = "RadarRing"

proc readRadarRingImpl(stream: Stream): Message = readRadarRing(stream)
proc writeRadarRingImpl(stream: Stream, msg: Message) = writeRadarRing(stream, RadarRing(msg))

proc RadarRingProcs*(): MessageProcs =
    result.readImpl = readRadarRingImpl
    result.writeImpl = writeRadarRingImpl

proc newRadarRing*(): RadarRing =
    new(result)
    initMessage(result[])
    result.procs = RadarRingProcs()
    result.pos = nil
    result.radius = 0

proc clearpos*(message: RadarRing) =
    message.pos = nil
    clearFields(message, [1])

proc haspos*(message: RadarRing): bool =
    result = hasField(message, 1)

proc setpos*(message: RadarRing, value: Point) =
    message.pos = value
    setField(message, 1)

proc pos*(message: RadarRing): Point {.inline.} =
    message.pos

proc `pos=`*(message: RadarRing, value: Point) {.inline.} =
    setpos(message, value)

proc clearradius*(message: RadarRing) =
    message.radius = 0
    clearFields(message, [2])

proc hasradius*(message: RadarRing): bool =
    result = hasField(message, 2)

proc setradius*(message: RadarRing, value: float32) =
    message.radius = value
    setField(message, 2)

proc radius*(message: RadarRing): float32 {.inline.} =
    message.radius

proc `radius=`*(message: RadarRing, value: float32) {.inline.} =
    setradius(message, value)

proc `$`*(message: RadarRing): string =
    runnableExamples:
        echo $RadarRing
        echo fmt"{RadarRing}"
        echo &"{RadarRing}"
    var resultSeq: seq[string]
    if message.haspos:
        resultSeq.add(&"pos: {message.pos}")
    if message.hasradius:
        resultSeq.add(&"radius: {message.radius}")
    result = resultSeq.join(", ")
    result = &"RadarRing({result})"

proc sizeOfRadarRing*(message: RadarRing): uint64 =
    if haspos(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint(message.pos))
    if hasradius(message):
        result = result + sizeOfTag(2, WireType.Fixed32)
        result = result + sizeOfFloat(message.radius)
    result = result + sizeOfUnknownFields(message)

proc writeRadarRing*(stream: Stream, message: RadarRing) =
    if haspos(message):
        writeMessage(stream, message.pos, 1)
    if hasradius(message):
        protoWriteFloat(stream, message.radius, 2)
    writeUnknownFields(stream, message)

proc readRadarRing*(stream: Stream): RadarRing =
    result = newRadarRing()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setpos(result, newPoint(data))
        of 2:
            expectWireType(wireType, WireType.Fixed32)
            setradius(result, protoReadFloat(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RadarRing): string =
    let
        ss = newStringStream()
    writeRadarRing(ss, message)
    result = ss.data

proc newRadarRing*(data: string): RadarRing =
    let
        ss = newStringStream(data)
    result = readRadarRing(ss)

proc newRadarRing*(data: seq[byte]): RadarRing =
    let
        ss = newStringStream(cast[string](data))
    result = readRadarRing(ss)


proc fullyQualifiedName*(T: typedesc[ObservationRaw]): string = "ObservationRaw"

proc readObservationRawImpl(stream: Stream): Message = readObservationRaw(stream)
proc writeObservationRawImpl(stream: Stream, msg: Message) = writeObservationRaw(stream, ObservationRaw(msg))

proc ObservationRawProcs*(): MessageProcs =
    result.readImpl = readObservationRawImpl
    result.writeImpl = writeObservationRawImpl

proc newObservationRaw*(): ObservationRaw =
    new(result)
    initMessage(result[])
    result.procs = ObservationRawProcs()
    result.player = nil
    result.units = @[]
    result.mapState = nil
    result.event = nil
    result.effects = @[]
    result.radar = @[]

proc clearplayer*(message: ObservationRaw) =
    message.player = nil
    clearFields(message, [1])

proc hasplayer*(message: ObservationRaw): bool =
    result = hasField(message, 1)

proc setplayer*(message: ObservationRaw, value: PlayerRaw) =
    message.player = value
    setField(message, 1)

proc player*(message: ObservationRaw): PlayerRaw {.inline.} =
    message.player

proc `player=`*(message: ObservationRaw, value: PlayerRaw) {.inline.} =
    setplayer(message, value)

proc clearunits*(message: ObservationRaw) =
    message.units = @[]
    clearFields(message, [2])

proc hasunits*(message: ObservationRaw): bool =
    result = hasField(message, 2) or (len(message.units) > 0)

proc setunits*(message: ObservationRaw, value: seq[Unit]) =
    message.units = value
    setField(message, 2)

proc addunits*(message: ObservationRaw, value: Unit) =
    add(message.units, value)

proc units*(message: ObservationRaw): seq[Unit] {.inline.} =
    message.units

proc `units=`*(message: ObservationRaw, value: seq[Unit]) {.inline.} =
    setunits(message, value)

proc clearmapState*(message: ObservationRaw) =
    message.mapState = nil
    clearFields(message, [3])

proc hasmapState*(message: ObservationRaw): bool =
    result = hasField(message, 3)

proc setmapState*(message: ObservationRaw, value: MapState) =
    message.mapState = value
    setField(message, 3)

proc mapState*(message: ObservationRaw): MapState {.inline.} =
    message.mapState

proc `mapState=`*(message: ObservationRaw, value: MapState) {.inline.} =
    setmapState(message, value)

proc clearevent*(message: ObservationRaw) =
    message.event = nil
    clearFields(message, [4])

proc hasevent*(message: ObservationRaw): bool =
    result = hasField(message, 4)

proc setevent*(message: ObservationRaw, value: Event) =
    message.event = value
    setField(message, 4)

proc event*(message: ObservationRaw): Event {.inline.} =
    message.event

proc `event=`*(message: ObservationRaw, value: Event) {.inline.} =
    setevent(message, value)

proc cleareffects*(message: ObservationRaw) =
    message.effects = @[]
    clearFields(message, [5])

proc haseffects*(message: ObservationRaw): bool =
    result = hasField(message, 5) or (len(message.effects) > 0)

proc seteffects*(message: ObservationRaw, value: seq[Effect]) =
    message.effects = value
    setField(message, 5)

proc addeffects*(message: ObservationRaw, value: Effect) =
    add(message.effects, value)

proc effects*(message: ObservationRaw): seq[Effect] {.inline.} =
    message.effects

proc `effects=`*(message: ObservationRaw, value: seq[Effect]) {.inline.} =
    seteffects(message, value)

proc clearradar*(message: ObservationRaw) =
    message.radar = @[]
    clearFields(message, [6])

proc hasradar*(message: ObservationRaw): bool =
    result = hasField(message, 6) or (len(message.radar) > 0)

proc setradar*(message: ObservationRaw, value: seq[RadarRing]) =
    message.radar = value
    setField(message, 6)

proc addradar*(message: ObservationRaw, value: RadarRing) =
    add(message.radar, value)

proc radar*(message: ObservationRaw): seq[RadarRing] {.inline.} =
    message.radar

proc `radar=`*(message: ObservationRaw, value: seq[RadarRing]) {.inline.} =
    setradar(message, value)

proc `$`*(message: ObservationRaw): string =
    runnableExamples:
        echo $ObservationRaw
        echo fmt"{ObservationRaw}"
        echo &"{ObservationRaw}"
    var resultSeq: seq[string]
    if message.hasplayer:
        resultSeq.add(&"player: {message.player}")
    if message.hasunits:
        resultSeq.add(&"units: {message.units}")
    if message.hasmapState:
        resultSeq.add(&"mapState: {message.mapState}")
    if message.hasevent:
        resultSeq.add(&"event: {message.event}")
    if message.haseffects:
        resultSeq.add(&"effects: {message.effects}")
    if message.hasradar:
        resultSeq.add(&"radar: {message.radar}")
    result = resultSeq.join(", ")
    result = &"ObservationRaw({result})"

proc sizeOfObservationRaw*(message: ObservationRaw): uint64 =
    if hasplayer(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPlayerRaw(message.player))
    for value in message.units:
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfUnit(value))
    if hasmapState(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfMapState(message.mapState))
    if hasevent(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfEvent(message.event))
    for value in message.effects:
        result = result + sizeOfTag(5, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfEffect(value))
    for value in message.radar:
        result = result + sizeOfTag(6, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfRadarRing(value))
    result = result + sizeOfUnknownFields(message)

proc writeObservationRaw*(stream: Stream, message: ObservationRaw) =
    if hasplayer(message):
        writeMessage(stream, message.player, 1)
    for value in message.units:
        writeMessage(stream, value, 2)
    if hasmapState(message):
        writeMessage(stream, message.mapState, 3)
    if hasevent(message):
        writeMessage(stream, message.event, 4)
    for value in message.effects:
        writeMessage(stream, value, 5)
    for value in message.radar:
        writeMessage(stream, value, 6)
    writeUnknownFields(stream, message)

proc readObservationRaw*(stream: Stream): ObservationRaw =
    result = newObservationRaw()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setplayer(result, newPlayerRaw(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addunits(result, newUnit(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setmapState(result, newMapState(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setevent(result, newEvent(data))
        of 5:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addeffects(result, newEffect(data))
        of 6:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addradar(result, newRadarRing(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ObservationRaw): string =
    let
        ss = newStringStream()
    writeObservationRaw(ss, message)
    result = ss.data

proc newObservationRaw*(data: string): ObservationRaw =
    let
        ss = newStringStream(data)
    result = readObservationRaw(ss)

proc newObservationRaw*(data: seq[byte]): ObservationRaw =
    let
        ss = newStringStream(cast[string](data))
    result = readObservationRaw(ss)


