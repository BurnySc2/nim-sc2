# Generated by protoc_gen_nim. Do not edit!

import base64
import intsets
import json
import strformat
import strutils

import nimpb/nimpb
import nimpb/json as nimpb_json

type
    ActionControlGroup_ControlGroupAction* {.pure.} = enum
        Recall = 1
        Set = 2
        Append = 3
        SetAndSteal = 4
        AppendAndSteal = 5
    ActionSelectIdleWorker_Type* {.pure.} = enum
        Set = 1
        Add = 2
        All = 3
        AddAll = 4
    ActionMultiPanel_Type* {.pure.} = enum
        SingleSelect = 1
        DeselectUnit = 2
        SelectAllOfType = 3
        DeselectAllOfType = 4
    ObservationUI* = ref ObservationUIObj
    ObservationUIObj* = object of Message
        groups: seq[ControlGroup]
        panel: ObservationUI_panel_OneOf

    ObservationUI_panel_Kind* {.pure.} = enum
        Single
        Multi
        Cargo
        Production
        NotSet

    ObservationUI_panel_OneOf* = object
        case kind*: ObservationUI_panel_Kind
        of ObservationUI_panel_Kind.Single: single*: SinglePanel
        of ObservationUI_panel_Kind.Multi: multi*: MultiPanel
        of ObservationUI_panel_Kind.Cargo: cargo*: CargoPanel
        of ObservationUI_panel_Kind.Production: production*: ProductionPanel
        of ObservationUI_panel_Kind.NotSet: nil
    ControlGroup* = ref ControlGroupObj
    ControlGroupObj* = object of Message
        controlGroupIndex: uint32
        leaderUnitType: uint32
        count: uint32
    UnitInfo* = ref UnitInfoObj
    UnitInfoObj* = object of Message
        unitType: uint32
        playerRelative: uint32
        health: int32
        shields: int32
        energy: int32
        transportSlotsTaken: int32
        buildProgress: float32
        addOn: UnitInfo
        maxHealth: int32
        maxShields: int32
        maxEnergy: int32
    SinglePanel* = ref SinglePanelObj
    SinglePanelObj* = object of Message
        unit: UnitInfo
        attackUpgradeLevel: int32
        armorUpgradeLevel: int32
        shieldUpgradeLevel: int32
        buffs: seq[int32]
    MultiPanel* = ref MultiPanelObj
    MultiPanelObj* = object of Message
        units: seq[UnitInfo]
    CargoPanel* = ref CargoPanelObj
    CargoPanelObj* = object of Message
        unit: UnitInfo
        passengers: seq[UnitInfo]
        slotsAvailable: int32
    BuildItem* = ref BuildItemObj
    BuildItemObj* = object of Message
        abilityId: uint32
        buildProgress: float32
    ProductionPanel* = ref ProductionPanelObj
    ProductionPanelObj* = object of Message
        unit: UnitInfo
        buildQueue: seq[UnitInfo]
        productionQueue: seq[BuildItem]
    ActionUI* = ref ActionUIObj
    ActionUIObj* = object of Message
        action: ActionUI_action_OneOf

    ActionUI_action_Kind* {.pure.} = enum
        ControlGroup
        SelectArmy
        SelectWarpGates
        SelectLarva
        SelectIdleWorker
        MultiPanel
        CargoPanel
        ProductionPanel
        ToggleAutocast
        NotSet

    ActionUI_action_OneOf* = object
        case kind*: ActionUI_action_Kind
        of ActionUI_action_Kind.ControlGroup: controlGroup*: ActionControlGroup
        of ActionUI_action_Kind.SelectArmy: selectArmy*: ActionSelectArmy
        of ActionUI_action_Kind.SelectWarpGates: selectWarpGates*: ActionSelectWarpGates
        of ActionUI_action_Kind.SelectLarva: selectLarva*: ActionSelectLarva
        of ActionUI_action_Kind.SelectIdleWorker: selectIdleWorker*: ActionSelectIdleWorker
        of ActionUI_action_Kind.MultiPanel: multiPanel*: ActionMultiPanel
        of ActionUI_action_Kind.CargoPanel: cargoPanel*: ActionCargoPanelUnload
        of ActionUI_action_Kind.ProductionPanel: productionPanel*: ActionProductionPanelRemoveFromQueue
        of ActionUI_action_Kind.ToggleAutocast: toggleAutocast*: ActionToggleAutocast
        of ActionUI_action_Kind.NotSet: nil
    ActionControlGroup* = ref ActionControlGroupObj
    ActionControlGroupObj* = object of Message
        action: ActionControlGroup_ControlGroupAction
        controlGroupIndex: uint32
    ActionSelectArmy* = ref ActionSelectArmyObj
    ActionSelectArmyObj* = object of Message
        selectionAdd: bool
    ActionSelectWarpGates* = ref ActionSelectWarpGatesObj
    ActionSelectWarpGatesObj* = object of Message
        selectionAdd: bool
    ActionSelectLarva* = ref ActionSelectLarvaObj
    ActionSelectLarvaObj* = object of Message
    ActionSelectIdleWorker* = ref ActionSelectIdleWorkerObj
    ActionSelectIdleWorkerObj* = object of Message
        ftype: ActionSelectIdleWorker_Type
    ActionMultiPanel* = ref ActionMultiPanelObj
    ActionMultiPanelObj* = object of Message
        ftype: ActionMultiPanel_Type
        unitIndex: int32
    ActionCargoPanelUnload* = ref ActionCargoPanelUnloadObj
    ActionCargoPanelUnloadObj* = object of Message
        unitIndex: int32
    ActionProductionPanelRemoveFromQueue* = ref ActionProductionPanelRemoveFromQueueObj
    ActionProductionPanelRemoveFromQueueObj* = object of Message
        unitIndex: int32
    ActionToggleAutocast* = ref ActionToggleAutocastObj
    ActionToggleAutocastObj* = object of Message
        abilityId: int32

proc newActionProductionPanelRemoveFromQueue*(): ActionProductionPanelRemoveFromQueue
proc newActionProductionPanelRemoveFromQueue*(data: string): ActionProductionPanelRemoveFromQueue
proc newActionProductionPanelRemoveFromQueue*(data: seq[byte]): ActionProductionPanelRemoveFromQueue
proc writeActionProductionPanelRemoveFromQueue*(stream: Stream, message: ActionProductionPanelRemoveFromQueue)
proc readActionProductionPanelRemoveFromQueue*(stream: Stream): ActionProductionPanelRemoveFromQueue
proc sizeOfActionProductionPanelRemoveFromQueue*(message: ActionProductionPanelRemoveFromQueue): uint64

proc newActionSelectIdleWorker*(): ActionSelectIdleWorker
proc newActionSelectIdleWorker*(data: string): ActionSelectIdleWorker
proc newActionSelectIdleWorker*(data: seq[byte]): ActionSelectIdleWorker
proc writeActionSelectIdleWorker*(stream: Stream, message: ActionSelectIdleWorker)
proc readActionSelectIdleWorker*(stream: Stream): ActionSelectIdleWorker
proc sizeOfActionSelectIdleWorker*(message: ActionSelectIdleWorker): uint64

proc newActionCargoPanelUnload*(): ActionCargoPanelUnload
proc newActionCargoPanelUnload*(data: string): ActionCargoPanelUnload
proc newActionCargoPanelUnload*(data: seq[byte]): ActionCargoPanelUnload
proc writeActionCargoPanelUnload*(stream: Stream, message: ActionCargoPanelUnload)
proc readActionCargoPanelUnload*(stream: Stream): ActionCargoPanelUnload
proc sizeOfActionCargoPanelUnload*(message: ActionCargoPanelUnload): uint64

proc newUnitInfo*(): UnitInfo
proc newUnitInfo*(data: string): UnitInfo
proc newUnitInfo*(data: seq[byte]): UnitInfo
proc writeUnitInfo*(stream: Stream, message: UnitInfo)
proc readUnitInfo*(stream: Stream): UnitInfo
proc sizeOfUnitInfo*(message: UnitInfo): uint64

proc newSinglePanel*(): SinglePanel
proc newSinglePanel*(data: string): SinglePanel
proc newSinglePanel*(data: seq[byte]): SinglePanel
proc writeSinglePanel*(stream: Stream, message: SinglePanel)
proc readSinglePanel*(stream: Stream): SinglePanel
proc sizeOfSinglePanel*(message: SinglePanel): uint64

proc newActionSelectLarva*(): ActionSelectLarva
proc newActionSelectLarva*(data: string): ActionSelectLarva
proc newActionSelectLarva*(data: seq[byte]): ActionSelectLarva
proc writeActionSelectLarva*(stream: Stream, message: ActionSelectLarva)
proc readActionSelectLarva*(stream: Stream): ActionSelectLarva
proc sizeOfActionSelectLarva*(message: ActionSelectLarva): uint64

proc newBuildItem*(): BuildItem
proc newBuildItem*(data: string): BuildItem
proc newBuildItem*(data: seq[byte]): BuildItem
proc writeBuildItem*(stream: Stream, message: BuildItem)
proc readBuildItem*(stream: Stream): BuildItem
proc sizeOfBuildItem*(message: BuildItem): uint64

proc newProductionPanel*(): ProductionPanel
proc newProductionPanel*(data: string): ProductionPanel
proc newProductionPanel*(data: seq[byte]): ProductionPanel
proc writeProductionPanel*(stream: Stream, message: ProductionPanel)
proc readProductionPanel*(stream: Stream): ProductionPanel
proc sizeOfProductionPanel*(message: ProductionPanel): uint64

proc newActionMultiPanel*(): ActionMultiPanel
proc newActionMultiPanel*(data: string): ActionMultiPanel
proc newActionMultiPanel*(data: seq[byte]): ActionMultiPanel
proc writeActionMultiPanel*(stream: Stream, message: ActionMultiPanel)
proc readActionMultiPanel*(stream: Stream): ActionMultiPanel
proc sizeOfActionMultiPanel*(message: ActionMultiPanel): uint64

proc newActionControlGroup*(): ActionControlGroup
proc newActionControlGroup*(data: string): ActionControlGroup
proc newActionControlGroup*(data: seq[byte]): ActionControlGroup
proc writeActionControlGroup*(stream: Stream, message: ActionControlGroup)
proc readActionControlGroup*(stream: Stream): ActionControlGroup
proc sizeOfActionControlGroup*(message: ActionControlGroup): uint64

proc newControlGroup*(): ControlGroup
proc newControlGroup*(data: string): ControlGroup
proc newControlGroup*(data: seq[byte]): ControlGroup
proc writeControlGroup*(stream: Stream, message: ControlGroup)
proc readControlGroup*(stream: Stream): ControlGroup
proc sizeOfControlGroup*(message: ControlGroup): uint64

proc newMultiPanel*(): MultiPanel
proc newMultiPanel*(data: string): MultiPanel
proc newMultiPanel*(data: seq[byte]): MultiPanel
proc writeMultiPanel*(stream: Stream, message: MultiPanel)
proc readMultiPanel*(stream: Stream): MultiPanel
proc sizeOfMultiPanel*(message: MultiPanel): uint64

proc newCargoPanel*(): CargoPanel
proc newCargoPanel*(data: string): CargoPanel
proc newCargoPanel*(data: seq[byte]): CargoPanel
proc writeCargoPanel*(stream: Stream, message: CargoPanel)
proc readCargoPanel*(stream: Stream): CargoPanel
proc sizeOfCargoPanel*(message: CargoPanel): uint64

proc newObservationUI*(): ObservationUI
proc newObservationUI*(data: string): ObservationUI
proc newObservationUI*(data: seq[byte]): ObservationUI
proc writeObservationUI*(stream: Stream, message: ObservationUI)
proc readObservationUI*(stream: Stream): ObservationUI
proc sizeOfObservationUI*(message: ObservationUI): uint64

proc newActionSelectArmy*(): ActionSelectArmy
proc newActionSelectArmy*(data: string): ActionSelectArmy
proc newActionSelectArmy*(data: seq[byte]): ActionSelectArmy
proc writeActionSelectArmy*(stream: Stream, message: ActionSelectArmy)
proc readActionSelectArmy*(stream: Stream): ActionSelectArmy
proc sizeOfActionSelectArmy*(message: ActionSelectArmy): uint64

proc newActionSelectWarpGates*(): ActionSelectWarpGates
proc newActionSelectWarpGates*(data: string): ActionSelectWarpGates
proc newActionSelectWarpGates*(data: seq[byte]): ActionSelectWarpGates
proc writeActionSelectWarpGates*(stream: Stream, message: ActionSelectWarpGates)
proc readActionSelectWarpGates*(stream: Stream): ActionSelectWarpGates
proc sizeOfActionSelectWarpGates*(message: ActionSelectWarpGates): uint64

proc newActionToggleAutocast*(): ActionToggleAutocast
proc newActionToggleAutocast*(data: string): ActionToggleAutocast
proc newActionToggleAutocast*(data: seq[byte]): ActionToggleAutocast
proc writeActionToggleAutocast*(stream: Stream, message: ActionToggleAutocast)
proc readActionToggleAutocast*(stream: Stream): ActionToggleAutocast
proc sizeOfActionToggleAutocast*(message: ActionToggleAutocast): uint64

proc newActionUI*(): ActionUI
proc newActionUI*(data: string): ActionUI
proc newActionUI*(data: seq[byte]): ActionUI
proc writeActionUI*(stream: Stream, message: ActionUI)
proc readActionUI*(stream: Stream): ActionUI
proc sizeOfActionUI*(message: ActionUI): uint64

proc fullyQualifiedName*(T: typedesc[ActionProductionPanelRemoveFromQueue]): string = "ActionProductionPanelRemoveFromQueue"

proc readActionProductionPanelRemoveFromQueueImpl(stream: Stream): Message = readActionProductionPanelRemoveFromQueue(stream)
proc writeActionProductionPanelRemoveFromQueueImpl(stream: Stream, msg: Message) = writeActionProductionPanelRemoveFromQueue(stream, ActionProductionPanelRemoveFromQueue(msg))

proc ActionProductionPanelRemoveFromQueueProcs*(): MessageProcs =
    result.readImpl = readActionProductionPanelRemoveFromQueueImpl
    result.writeImpl = writeActionProductionPanelRemoveFromQueueImpl

proc newActionProductionPanelRemoveFromQueue*(): ActionProductionPanelRemoveFromQueue =
    new(result)
    initMessage(result[])
    result.procs = ActionProductionPanelRemoveFromQueueProcs()
    result.unitIndex = 0

proc clearunitIndex*(message: ActionProductionPanelRemoveFromQueue) =
    message.unitIndex = 0
    clearFields(message, [1])

proc hasunitIndex*(message: ActionProductionPanelRemoveFromQueue): bool =
    result = hasField(message, 1)

proc setunitIndex*(message: ActionProductionPanelRemoveFromQueue, value: int32) =
    message.unitIndex = value
    setField(message, 1)

proc unitIndex*(message: ActionProductionPanelRemoveFromQueue): int32 {.inline.} =
    message.unitIndex

proc `unitIndex=`*(message: ActionProductionPanelRemoveFromQueue, value: int32) {.inline.} =
    setunitIndex(message, value)

proc `$`*(message: ActionProductionPanelRemoveFromQueue): string =
    runnableExamples:
        echo $ActionProductionPanelRemoveFromQueue
        echo fmt"{ActionProductionPanelRemoveFromQueue}"
        echo &"{ActionProductionPanelRemoveFromQueue}"
    var resultSeq: seq[string]
    if message.hasunitIndex:
        resultSeq.add(&"unitIndex: {message.unitIndex}")
    result = resultSeq.join(", ")
    result = &"ActionProductionPanelRemoveFromQueue({result})"

proc sizeOfActionProductionPanelRemoveFromQueue*(message: ActionProductionPanelRemoveFromQueue): uint64 =
    if hasunitIndex(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfInt32(message.unitIndex)
    result = result + sizeOfUnknownFields(message)

proc writeActionProductionPanelRemoveFromQueue*(stream: Stream, message: ActionProductionPanelRemoveFromQueue) =
    if hasunitIndex(message):
        protoWriteInt32(stream, message.unitIndex, 1)
    writeUnknownFields(stream, message)

proc readActionProductionPanelRemoveFromQueue*(stream: Stream): ActionProductionPanelRemoveFromQueue =
    result = newActionProductionPanelRemoveFromQueue()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setunitIndex(result, protoReadInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionProductionPanelRemoveFromQueue): string =
    let
        ss = newStringStream()
    writeActionProductionPanelRemoveFromQueue(ss, message)
    result = ss.data

proc newActionProductionPanelRemoveFromQueue*(data: string): ActionProductionPanelRemoveFromQueue =
    let
        ss = newStringStream(data)
    result = readActionProductionPanelRemoveFromQueue(ss)

proc newActionProductionPanelRemoveFromQueue*(data: seq[byte]): ActionProductionPanelRemoveFromQueue =
    let
        ss = newStringStream(cast[string](data))
    result = readActionProductionPanelRemoveFromQueue(ss)


proc fullyQualifiedName*(T: typedesc[ActionSelectIdleWorker]): string = "ActionSelectIdleWorker"

proc readActionSelectIdleWorkerImpl(stream: Stream): Message = readActionSelectIdleWorker(stream)
proc writeActionSelectIdleWorkerImpl(stream: Stream, msg: Message) = writeActionSelectIdleWorker(stream, ActionSelectIdleWorker(msg))

proc ActionSelectIdleWorkerProcs*(): MessageProcs =
    result.readImpl = readActionSelectIdleWorkerImpl
    result.writeImpl = writeActionSelectIdleWorkerImpl

proc newActionSelectIdleWorker*(): ActionSelectIdleWorker =
    new(result)
    initMessage(result[])
    result.procs = ActionSelectIdleWorkerProcs()
    result.ftype = ActionSelectIdleWorker_Type.Set

proc clearftype*(message: ActionSelectIdleWorker) =
    message.ftype = ActionSelectIdleWorker_Type.Set
    clearFields(message, [1])

proc hasftype*(message: ActionSelectIdleWorker): bool =
    result = hasField(message, 1)

proc setftype*(message: ActionSelectIdleWorker, value: ActionSelectIdleWorker_Type) =
    message.ftype = value
    setField(message, 1)

proc ftype*(message: ActionSelectIdleWorker): ActionSelectIdleWorker_Type {.inline.} =
    message.ftype

proc `ftype=`*(message: ActionSelectIdleWorker, value: ActionSelectIdleWorker_Type) {.inline.} =
    setftype(message, value)

proc `$`*(message: ActionSelectIdleWorker): string =
    runnableExamples:
        echo $ActionSelectIdleWorker
        echo fmt"{ActionSelectIdleWorker}"
        echo &"{ActionSelectIdleWorker}"
    var resultSeq: seq[string]
    if message.hasftype:
        resultSeq.add(&"ftype: {message.ftype}")
    result = resultSeq.join(", ")
    result = &"ActionSelectIdleWorker({result})"

proc sizeOfActionSelectIdleWorker*(message: ActionSelectIdleWorker): uint64 =
    if hasftype(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfEnum[ActionSelectIdleWorker_Type](message.ftype)
    result = result + sizeOfUnknownFields(message)

proc writeActionSelectIdleWorker*(stream: Stream, message: ActionSelectIdleWorker) =
    if hasftype(message):
        protoWriteEnum(stream, message.ftype, 1)
    writeUnknownFields(stream, message)

proc readActionSelectIdleWorker*(stream: Stream): ActionSelectIdleWorker =
    result = newActionSelectIdleWorker()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setftype(result, protoReadEnum[ActionSelectIdleWorker_Type](stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionSelectIdleWorker): string =
    let
        ss = newStringStream()
    writeActionSelectIdleWorker(ss, message)
    result = ss.data

proc newActionSelectIdleWorker*(data: string): ActionSelectIdleWorker =
    let
        ss = newStringStream(data)
    result = readActionSelectIdleWorker(ss)

proc newActionSelectIdleWorker*(data: seq[byte]): ActionSelectIdleWorker =
    let
        ss = newStringStream(cast[string](data))
    result = readActionSelectIdleWorker(ss)


proc fullyQualifiedName*(T: typedesc[ActionCargoPanelUnload]): string = "ActionCargoPanelUnload"

proc readActionCargoPanelUnloadImpl(stream: Stream): Message = readActionCargoPanelUnload(stream)
proc writeActionCargoPanelUnloadImpl(stream: Stream, msg: Message) = writeActionCargoPanelUnload(stream, ActionCargoPanelUnload(msg))

proc ActionCargoPanelUnloadProcs*(): MessageProcs =
    result.readImpl = readActionCargoPanelUnloadImpl
    result.writeImpl = writeActionCargoPanelUnloadImpl

proc newActionCargoPanelUnload*(): ActionCargoPanelUnload =
    new(result)
    initMessage(result[])
    result.procs = ActionCargoPanelUnloadProcs()
    result.unitIndex = 0

proc clearunitIndex*(message: ActionCargoPanelUnload) =
    message.unitIndex = 0
    clearFields(message, [1])

proc hasunitIndex*(message: ActionCargoPanelUnload): bool =
    result = hasField(message, 1)

proc setunitIndex*(message: ActionCargoPanelUnload, value: int32) =
    message.unitIndex = value
    setField(message, 1)

proc unitIndex*(message: ActionCargoPanelUnload): int32 {.inline.} =
    message.unitIndex

proc `unitIndex=`*(message: ActionCargoPanelUnload, value: int32) {.inline.} =
    setunitIndex(message, value)

proc `$`*(message: ActionCargoPanelUnload): string =
    runnableExamples:
        echo $ActionCargoPanelUnload
        echo fmt"{ActionCargoPanelUnload}"
        echo &"{ActionCargoPanelUnload}"
    var resultSeq: seq[string]
    if message.hasunitIndex:
        resultSeq.add(&"unitIndex: {message.unitIndex}")
    result = resultSeq.join(", ")
    result = &"ActionCargoPanelUnload({result})"

proc sizeOfActionCargoPanelUnload*(message: ActionCargoPanelUnload): uint64 =
    if hasunitIndex(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfInt32(message.unitIndex)
    result = result + sizeOfUnknownFields(message)

proc writeActionCargoPanelUnload*(stream: Stream, message: ActionCargoPanelUnload) =
    if hasunitIndex(message):
        protoWriteInt32(stream, message.unitIndex, 1)
    writeUnknownFields(stream, message)

proc readActionCargoPanelUnload*(stream: Stream): ActionCargoPanelUnload =
    result = newActionCargoPanelUnload()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setunitIndex(result, protoReadInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionCargoPanelUnload): string =
    let
        ss = newStringStream()
    writeActionCargoPanelUnload(ss, message)
    result = ss.data

proc newActionCargoPanelUnload*(data: string): ActionCargoPanelUnload =
    let
        ss = newStringStream(data)
    result = readActionCargoPanelUnload(ss)

proc newActionCargoPanelUnload*(data: seq[byte]): ActionCargoPanelUnload =
    let
        ss = newStringStream(cast[string](data))
    result = readActionCargoPanelUnload(ss)


proc fullyQualifiedName*(T: typedesc[UnitInfo]): string = "UnitInfo"

proc readUnitInfoImpl(stream: Stream): Message = readUnitInfo(stream)
proc writeUnitInfoImpl(stream: Stream, msg: Message) = writeUnitInfo(stream, UnitInfo(msg))

proc UnitInfoProcs*(): MessageProcs =
    result.readImpl = readUnitInfoImpl
    result.writeImpl = writeUnitInfoImpl

proc newUnitInfo*(): UnitInfo =
    new(result)
    initMessage(result[])
    result.procs = UnitInfoProcs()
    result.unitType = 0
    result.playerRelative = 0
    result.health = 0
    result.shields = 0
    result.energy = 0
    result.transportSlotsTaken = 0
    result.buildProgress = 0
    result.addOn = nil
    result.maxHealth = 0
    result.maxShields = 0
    result.maxEnergy = 0

proc clearunitType*(message: UnitInfo) =
    message.unitType = 0
    clearFields(message, [1])

proc hasunitType*(message: UnitInfo): bool =
    result = hasField(message, 1)

proc setunitType*(message: UnitInfo, value: uint32) =
    message.unitType = value
    setField(message, 1)

proc unitType*(message: UnitInfo): uint32 {.inline.} =
    message.unitType

proc `unitType=`*(message: UnitInfo, value: uint32) {.inline.} =
    setunitType(message, value)

proc clearplayerRelative*(message: UnitInfo) =
    message.playerRelative = 0
    clearFields(message, [2])

proc hasplayerRelative*(message: UnitInfo): bool =
    result = hasField(message, 2)

proc setplayerRelative*(message: UnitInfo, value: uint32) =
    message.playerRelative = value
    setField(message, 2)

proc playerRelative*(message: UnitInfo): uint32 {.inline.} =
    message.playerRelative

proc `playerRelative=`*(message: UnitInfo, value: uint32) {.inline.} =
    setplayerRelative(message, value)

proc clearhealth*(message: UnitInfo) =
    message.health = 0
    clearFields(message, [3])

proc hashealth*(message: UnitInfo): bool =
    result = hasField(message, 3)

proc sethealth*(message: UnitInfo, value: int32) =
    message.health = value
    setField(message, 3)

proc health*(message: UnitInfo): int32 {.inline.} =
    message.health

proc `health=`*(message: UnitInfo, value: int32) {.inline.} =
    sethealth(message, value)

proc clearshields*(message: UnitInfo) =
    message.shields = 0
    clearFields(message, [4])

proc hasshields*(message: UnitInfo): bool =
    result = hasField(message, 4)

proc setshields*(message: UnitInfo, value: int32) =
    message.shields = value
    setField(message, 4)

proc shields*(message: UnitInfo): int32 {.inline.} =
    message.shields

proc `shields=`*(message: UnitInfo, value: int32) {.inline.} =
    setshields(message, value)

proc clearenergy*(message: UnitInfo) =
    message.energy = 0
    clearFields(message, [5])

proc hasenergy*(message: UnitInfo): bool =
    result = hasField(message, 5)

proc setenergy*(message: UnitInfo, value: int32) =
    message.energy = value
    setField(message, 5)

proc energy*(message: UnitInfo): int32 {.inline.} =
    message.energy

proc `energy=`*(message: UnitInfo, value: int32) {.inline.} =
    setenergy(message, value)

proc cleartransportSlotsTaken*(message: UnitInfo) =
    message.transportSlotsTaken = 0
    clearFields(message, [6])

proc hastransportSlotsTaken*(message: UnitInfo): bool =
    result = hasField(message, 6)

proc settransportSlotsTaken*(message: UnitInfo, value: int32) =
    message.transportSlotsTaken = value
    setField(message, 6)

proc transportSlotsTaken*(message: UnitInfo): int32 {.inline.} =
    message.transportSlotsTaken

proc `transportSlotsTaken=`*(message: UnitInfo, value: int32) {.inline.} =
    settransportSlotsTaken(message, value)

proc clearbuildProgress*(message: UnitInfo) =
    message.buildProgress = 0
    clearFields(message, [7])

proc hasbuildProgress*(message: UnitInfo): bool =
    result = hasField(message, 7)

proc setbuildProgress*(message: UnitInfo, value: float32) =
    message.buildProgress = value
    setField(message, 7)

proc buildProgress*(message: UnitInfo): float32 {.inline.} =
    message.buildProgress

proc `buildProgress=`*(message: UnitInfo, value: float32) {.inline.} =
    setbuildProgress(message, value)

proc clearaddOn*(message: UnitInfo) =
    message.addOn = nil
    clearFields(message, [8])

proc hasaddOn*(message: UnitInfo): bool =
    result = hasField(message, 8)

proc setaddOn*(message: UnitInfo, value: UnitInfo) =
    message.addOn = value
    setField(message, 8)

proc addOn*(message: UnitInfo): UnitInfo {.inline.} =
    message.addOn

proc `addOn=`*(message: UnitInfo, value: UnitInfo) {.inline.} =
    setaddOn(message, value)

proc clearmaxHealth*(message: UnitInfo) =
    message.maxHealth = 0
    clearFields(message, [9])

proc hasmaxHealth*(message: UnitInfo): bool =
    result = hasField(message, 9)

proc setmaxHealth*(message: UnitInfo, value: int32) =
    message.maxHealth = value
    setField(message, 9)

proc maxHealth*(message: UnitInfo): int32 {.inline.} =
    message.maxHealth

proc `maxHealth=`*(message: UnitInfo, value: int32) {.inline.} =
    setmaxHealth(message, value)

proc clearmaxShields*(message: UnitInfo) =
    message.maxShields = 0
    clearFields(message, [10])

proc hasmaxShields*(message: UnitInfo): bool =
    result = hasField(message, 10)

proc setmaxShields*(message: UnitInfo, value: int32) =
    message.maxShields = value
    setField(message, 10)

proc maxShields*(message: UnitInfo): int32 {.inline.} =
    message.maxShields

proc `maxShields=`*(message: UnitInfo, value: int32) {.inline.} =
    setmaxShields(message, value)

proc clearmaxEnergy*(message: UnitInfo) =
    message.maxEnergy = 0
    clearFields(message, [11])

proc hasmaxEnergy*(message: UnitInfo): bool =
    result = hasField(message, 11)

proc setmaxEnergy*(message: UnitInfo, value: int32) =
    message.maxEnergy = value
    setField(message, 11)

proc maxEnergy*(message: UnitInfo): int32 {.inline.} =
    message.maxEnergy

proc `maxEnergy=`*(message: UnitInfo, value: int32) {.inline.} =
    setmaxEnergy(message, value)

proc `$`*(message: UnitInfo): string =
    runnableExamples:
        echo $UnitInfo
        echo fmt"{UnitInfo}"
        echo &"{UnitInfo}"
    var resultSeq: seq[string]
    if message.hasunitType:
        resultSeq.add(&"unitType: {message.unitType}")
    if message.hasplayerRelative:
        resultSeq.add(&"playerRelative: {message.playerRelative}")
    if message.hashealth:
        resultSeq.add(&"health: {message.health}")
    if message.hasshields:
        resultSeq.add(&"shields: {message.shields}")
    if message.hasenergy:
        resultSeq.add(&"energy: {message.energy}")
    if message.hastransportSlotsTaken:
        resultSeq.add(&"transportSlotsTaken: {message.transportSlotsTaken}")
    if message.hasbuildProgress:
        resultSeq.add(&"buildProgress: {message.buildProgress}")
    if message.hasaddOn:
        resultSeq.add(&"addOn: {message.addOn}")
    if message.hasmaxHealth:
        resultSeq.add(&"maxHealth: {message.maxHealth}")
    if message.hasmaxShields:
        resultSeq.add(&"maxShields: {message.maxShields}")
    if message.hasmaxEnergy:
        resultSeq.add(&"maxEnergy: {message.maxEnergy}")
    result = resultSeq.join(", ")
    result = &"UnitInfo({result})"

proc sizeOfUnitInfo*(message: UnitInfo): uint64 =
    if hasunitType(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.unitType)
    if hasplayerRelative(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfUInt32(message.playerRelative)
    if hashealth(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfInt32(message.health)
    if hasshields(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfInt32(message.shields)
    if hasenergy(message):
        result = result + sizeOfTag(5, WireType.Varint)
        result = result + sizeOfInt32(message.energy)
    if hastransportSlotsTaken(message):
        result = result + sizeOfTag(6, WireType.Varint)
        result = result + sizeOfInt32(message.transportSlotsTaken)
    if hasbuildProgress(message):
        result = result + sizeOfTag(7, WireType.Fixed32)
        result = result + sizeOfFloat(message.buildProgress)
    if hasaddOn(message):
        result = result + sizeOfTag(8, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfUnitInfo(message.addOn))
    if hasmaxHealth(message):
        result = result + sizeOfTag(9, WireType.Varint)
        result = result + sizeOfInt32(message.maxHealth)
    if hasmaxShields(message):
        result = result + sizeOfTag(10, WireType.Varint)
        result = result + sizeOfInt32(message.maxShields)
    if hasmaxEnergy(message):
        result = result + sizeOfTag(11, WireType.Varint)
        result = result + sizeOfInt32(message.maxEnergy)
    result = result + sizeOfUnknownFields(message)

proc writeUnitInfo*(stream: Stream, message: UnitInfo) =
    if hasunitType(message):
        protoWriteUInt32(stream, message.unitType, 1)
    if hasplayerRelative(message):
        protoWriteUInt32(stream, message.playerRelative, 2)
    if hashealth(message):
        protoWriteInt32(stream, message.health, 3)
    if hasshields(message):
        protoWriteInt32(stream, message.shields, 4)
    if hasenergy(message):
        protoWriteInt32(stream, message.energy, 5)
    if hastransportSlotsTaken(message):
        protoWriteInt32(stream, message.transportSlotsTaken, 6)
    if hasbuildProgress(message):
        protoWriteFloat(stream, message.buildProgress, 7)
    if hasaddOn(message):
        writeMessage(stream, message.addOn, 8)
    if hasmaxHealth(message):
        protoWriteInt32(stream, message.maxHealth, 9)
    if hasmaxShields(message):
        protoWriteInt32(stream, message.maxShields, 10)
    if hasmaxEnergy(message):
        protoWriteInt32(stream, message.maxEnergy, 11)
    writeUnknownFields(stream, message)

proc readUnitInfo*(stream: Stream): UnitInfo =
    result = newUnitInfo()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setunitType(result, protoReadUInt32(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setplayerRelative(result, protoReadUInt32(stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            sethealth(result, protoReadInt32(stream))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setshields(result, protoReadInt32(stream))
        of 5:
            expectWireType(wireType, WireType.Varint)
            setenergy(result, protoReadInt32(stream))
        of 6:
            expectWireType(wireType, WireType.Varint)
            settransportSlotsTaken(result, protoReadInt32(stream))
        of 7:
            expectWireType(wireType, WireType.Fixed32)
            setbuildProgress(result, protoReadFloat(stream))
        of 8:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setaddOn(result, newUnitInfo(data))
        of 9:
            expectWireType(wireType, WireType.Varint)
            setmaxHealth(result, protoReadInt32(stream))
        of 10:
            expectWireType(wireType, WireType.Varint)
            setmaxShields(result, protoReadInt32(stream))
        of 11:
            expectWireType(wireType, WireType.Varint)
            setmaxEnergy(result, protoReadInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: UnitInfo): string =
    let
        ss = newStringStream()
    writeUnitInfo(ss, message)
    result = ss.data

proc newUnitInfo*(data: string): UnitInfo =
    let
        ss = newStringStream(data)
    result = readUnitInfo(ss)

proc newUnitInfo*(data: seq[byte]): UnitInfo =
    let
        ss = newStringStream(cast[string](data))
    result = readUnitInfo(ss)


proc fullyQualifiedName*(T: typedesc[SinglePanel]): string = "SinglePanel"

proc readSinglePanelImpl(stream: Stream): Message = readSinglePanel(stream)
proc writeSinglePanelImpl(stream: Stream, msg: Message) = writeSinglePanel(stream, SinglePanel(msg))

proc SinglePanelProcs*(): MessageProcs =
    result.readImpl = readSinglePanelImpl
    result.writeImpl = writeSinglePanelImpl

proc newSinglePanel*(): SinglePanel =
    new(result)
    initMessage(result[])
    result.procs = SinglePanelProcs()
    result.unit = nil
    result.attackUpgradeLevel = 0
    result.armorUpgradeLevel = 0
    result.shieldUpgradeLevel = 0
    result.buffs = @[]

proc clearunit*(message: SinglePanel) =
    message.unit = nil
    clearFields(message, [1])

proc hasunit*(message: SinglePanel): bool =
    result = hasField(message, 1)

proc setunit*(message: SinglePanel, value: UnitInfo) =
    message.unit = value
    setField(message, 1)

proc unit*(message: SinglePanel): UnitInfo {.inline.} =
    message.unit

proc `unit=`*(message: SinglePanel, value: UnitInfo) {.inline.} =
    setunit(message, value)

proc clearattackUpgradeLevel*(message: SinglePanel) =
    message.attackUpgradeLevel = 0
    clearFields(message, [2])

proc hasattackUpgradeLevel*(message: SinglePanel): bool =
    result = hasField(message, 2)

proc setattackUpgradeLevel*(message: SinglePanel, value: int32) =
    message.attackUpgradeLevel = value
    setField(message, 2)

proc attackUpgradeLevel*(message: SinglePanel): int32 {.inline.} =
    message.attackUpgradeLevel

proc `attackUpgradeLevel=`*(message: SinglePanel, value: int32) {.inline.} =
    setattackUpgradeLevel(message, value)

proc cleararmorUpgradeLevel*(message: SinglePanel) =
    message.armorUpgradeLevel = 0
    clearFields(message, [3])

proc hasarmorUpgradeLevel*(message: SinglePanel): bool =
    result = hasField(message, 3)

proc setarmorUpgradeLevel*(message: SinglePanel, value: int32) =
    message.armorUpgradeLevel = value
    setField(message, 3)

proc armorUpgradeLevel*(message: SinglePanel): int32 {.inline.} =
    message.armorUpgradeLevel

proc `armorUpgradeLevel=`*(message: SinglePanel, value: int32) {.inline.} =
    setarmorUpgradeLevel(message, value)

proc clearshieldUpgradeLevel*(message: SinglePanel) =
    message.shieldUpgradeLevel = 0
    clearFields(message, [4])

proc hasshieldUpgradeLevel*(message: SinglePanel): bool =
    result = hasField(message, 4)

proc setshieldUpgradeLevel*(message: SinglePanel, value: int32) =
    message.shieldUpgradeLevel = value
    setField(message, 4)

proc shieldUpgradeLevel*(message: SinglePanel): int32 {.inline.} =
    message.shieldUpgradeLevel

proc `shieldUpgradeLevel=`*(message: SinglePanel, value: int32) {.inline.} =
    setshieldUpgradeLevel(message, value)

proc clearbuffs*(message: SinglePanel) =
    message.buffs = @[]
    clearFields(message, [5])

proc hasbuffs*(message: SinglePanel): bool =
    result = hasField(message, 5) or (len(message.buffs) > 0)

proc setbuffs*(message: SinglePanel, value: seq[int32]) =
    message.buffs = value
    setField(message, 5)

proc addbuffs*(message: SinglePanel, value: int32) =
    add(message.buffs, value)

proc buffs*(message: SinglePanel): seq[int32] {.inline.} =
    message.buffs

proc `buffs=`*(message: SinglePanel, value: seq[int32]) {.inline.} =
    setbuffs(message, value)

proc `$`*(message: SinglePanel): string =
    runnableExamples:
        echo $SinglePanel
        echo fmt"{SinglePanel}"
        echo &"{SinglePanel}"
    var resultSeq: seq[string]
    if message.hasunit:
        resultSeq.add(&"unit: {message.unit}")
    if message.hasattackUpgradeLevel:
        resultSeq.add(&"attackUpgradeLevel: {message.attackUpgradeLevel}")
    if message.hasarmorUpgradeLevel:
        resultSeq.add(&"armorUpgradeLevel: {message.armorUpgradeLevel}")
    if message.hasshieldUpgradeLevel:
        resultSeq.add(&"shieldUpgradeLevel: {message.shieldUpgradeLevel}")
    if message.hasbuffs:
        resultSeq.add(&"buffs: {message.buffs}")
    result = resultSeq.join(", ")
    result = &"SinglePanel({result})"

proc sizeOfSinglePanel*(message: SinglePanel): uint64 =
    if hasunit(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfUnitInfo(message.unit))
    if hasattackUpgradeLevel(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfInt32(message.attackUpgradeLevel)
    if hasarmorUpgradeLevel(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfInt32(message.armorUpgradeLevel)
    if hasshieldUpgradeLevel(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfInt32(message.shieldUpgradeLevel)
    if len(message.buffs) > 0:
        for value in message.buffs:
            result = result + sizeOfTag(5, WireType.Varint)
            result = result + sizeOfInt32(value)
    result = result + sizeOfUnknownFields(message)

proc writeSinglePanel*(stream: Stream, message: SinglePanel) =
    if hasunit(message):
        writeMessage(stream, message.unit, 1)
    if hasattackUpgradeLevel(message):
        protoWriteInt32(stream, message.attackUpgradeLevel, 2)
    if hasarmorUpgradeLevel(message):
        protoWriteInt32(stream, message.armorUpgradeLevel, 3)
    if hasshieldUpgradeLevel(message):
        protoWriteInt32(stream, message.shieldUpgradeLevel, 4)
    for value in message.buffs:
        protoWriteInt32(stream, value, 5)
    writeUnknownFields(stream, message)

proc readSinglePanel*(stream: Stream): SinglePanel =
    result = newSinglePanel()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunit(result, newUnitInfo(data))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setattackUpgradeLevel(result, protoReadInt32(stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setarmorUpgradeLevel(result, protoReadInt32(stream))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setshieldUpgradeLevel(result, protoReadInt32(stream))
        of 5:
            expectWireType(wireType, WireType.Varint, WireType.LengthDelimited)
            if wireType == WireType.LengthDelimited:
                let
                    size = readVarint(stream)
                    start = uint64(getPosition(stream))
                var consumed = 0'u64
                while consumed < size:
                    addbuffs(result, protoReadInt32(stream))
                    consumed = uint64(getPosition(stream)) - start
                if consumed != size:
                    raise newException(Exception, "packed field size mismatch")
            else:
                addbuffs(result, protoReadInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: SinglePanel): string =
    let
        ss = newStringStream()
    writeSinglePanel(ss, message)
    result = ss.data

proc newSinglePanel*(data: string): SinglePanel =
    let
        ss = newStringStream(data)
    result = readSinglePanel(ss)

proc newSinglePanel*(data: seq[byte]): SinglePanel =
    let
        ss = newStringStream(cast[string](data))
    result = readSinglePanel(ss)


proc fullyQualifiedName*(T: typedesc[ActionSelectLarva]): string = "ActionSelectLarva"

proc readActionSelectLarvaImpl(stream: Stream): Message = readActionSelectLarva(stream)
proc writeActionSelectLarvaImpl(stream: Stream, msg: Message) = writeActionSelectLarva(stream, ActionSelectLarva(msg))

proc ActionSelectLarvaProcs*(): MessageProcs =
    result.readImpl = readActionSelectLarvaImpl
    result.writeImpl = writeActionSelectLarvaImpl

proc newActionSelectLarva*(): ActionSelectLarva =
    new(result)
    initMessage(result[])
    result.procs = ActionSelectLarvaProcs()

proc `$`*(message: ActionSelectLarva): string =
    runnableExamples:
        echo $ActionSelectLarva
        echo fmt"{ActionSelectLarva}"
        echo &"{ActionSelectLarva}"
    var resultSeq: seq[string]
    result = resultSeq.join(", ")
    result = &"ActionSelectLarva({result})"

proc sizeOfActionSelectLarva*(message: ActionSelectLarva): uint64 =
    result = result + sizeOfUnknownFields(message)

proc writeActionSelectLarva*(stream: Stream, message: ActionSelectLarva) =
    writeUnknownFields(stream, message)

proc readActionSelectLarva*(stream: Stream): ActionSelectLarva =
    result = newActionSelectLarva()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionSelectLarva): string =
    let
        ss = newStringStream()
    writeActionSelectLarva(ss, message)
    result = ss.data

proc newActionSelectLarva*(data: string): ActionSelectLarva =
    let
        ss = newStringStream(data)
    result = readActionSelectLarva(ss)

proc newActionSelectLarva*(data: seq[byte]): ActionSelectLarva =
    let
        ss = newStringStream(cast[string](data))
    result = readActionSelectLarva(ss)


proc fullyQualifiedName*(T: typedesc[BuildItem]): string = "BuildItem"

proc readBuildItemImpl(stream: Stream): Message = readBuildItem(stream)
proc writeBuildItemImpl(stream: Stream, msg: Message) = writeBuildItem(stream, BuildItem(msg))

proc BuildItemProcs*(): MessageProcs =
    result.readImpl = readBuildItemImpl
    result.writeImpl = writeBuildItemImpl

proc newBuildItem*(): BuildItem =
    new(result)
    initMessage(result[])
    result.procs = BuildItemProcs()
    result.abilityId = 0
    result.buildProgress = 0

proc clearabilityId*(message: BuildItem) =
    message.abilityId = 0
    clearFields(message, [1])

proc hasabilityId*(message: BuildItem): bool =
    result = hasField(message, 1)

proc setabilityId*(message: BuildItem, value: uint32) =
    message.abilityId = value
    setField(message, 1)

proc abilityId*(message: BuildItem): uint32 {.inline.} =
    message.abilityId

proc `abilityId=`*(message: BuildItem, value: uint32) {.inline.} =
    setabilityId(message, value)

proc clearbuildProgress*(message: BuildItem) =
    message.buildProgress = 0
    clearFields(message, [2])

proc hasbuildProgress*(message: BuildItem): bool =
    result = hasField(message, 2)

proc setbuildProgress*(message: BuildItem, value: float32) =
    message.buildProgress = value
    setField(message, 2)

proc buildProgress*(message: BuildItem): float32 {.inline.} =
    message.buildProgress

proc `buildProgress=`*(message: BuildItem, value: float32) {.inline.} =
    setbuildProgress(message, value)

proc `$`*(message: BuildItem): string =
    runnableExamples:
        echo $BuildItem
        echo fmt"{BuildItem}"
        echo &"{BuildItem}"
    var resultSeq: seq[string]
    if message.hasabilityId:
        resultSeq.add(&"abilityId: {message.abilityId}")
    if message.hasbuildProgress:
        resultSeq.add(&"buildProgress: {message.buildProgress}")
    result = resultSeq.join(", ")
    result = &"BuildItem({result})"

proc sizeOfBuildItem*(message: BuildItem): uint64 =
    if hasabilityId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.abilityId)
    if hasbuildProgress(message):
        result = result + sizeOfTag(2, WireType.Fixed32)
        result = result + sizeOfFloat(message.buildProgress)
    result = result + sizeOfUnknownFields(message)

proc writeBuildItem*(stream: Stream, message: BuildItem) =
    if hasabilityId(message):
        protoWriteUInt32(stream, message.abilityId, 1)
    if hasbuildProgress(message):
        protoWriteFloat(stream, message.buildProgress, 2)
    writeUnknownFields(stream, message)

proc readBuildItem*(stream: Stream): BuildItem =
    result = newBuildItem()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setabilityId(result, protoReadUInt32(stream))
        of 2:
            expectWireType(wireType, WireType.Fixed32)
            setbuildProgress(result, protoReadFloat(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: BuildItem): string =
    let
        ss = newStringStream()
    writeBuildItem(ss, message)
    result = ss.data

proc newBuildItem*(data: string): BuildItem =
    let
        ss = newStringStream(data)
    result = readBuildItem(ss)

proc newBuildItem*(data: seq[byte]): BuildItem =
    let
        ss = newStringStream(cast[string](data))
    result = readBuildItem(ss)


proc fullyQualifiedName*(T: typedesc[ProductionPanel]): string = "ProductionPanel"

proc readProductionPanelImpl(stream: Stream): Message = readProductionPanel(stream)
proc writeProductionPanelImpl(stream: Stream, msg: Message) = writeProductionPanel(stream, ProductionPanel(msg))

proc ProductionPanelProcs*(): MessageProcs =
    result.readImpl = readProductionPanelImpl
    result.writeImpl = writeProductionPanelImpl

proc newProductionPanel*(): ProductionPanel =
    new(result)
    initMessage(result[])
    result.procs = ProductionPanelProcs()
    result.unit = nil
    result.buildQueue = @[]
    result.productionQueue = @[]

proc clearunit*(message: ProductionPanel) =
    message.unit = nil
    clearFields(message, [1])

proc hasunit*(message: ProductionPanel): bool =
    result = hasField(message, 1)

proc setunit*(message: ProductionPanel, value: UnitInfo) =
    message.unit = value
    setField(message, 1)

proc unit*(message: ProductionPanel): UnitInfo {.inline.} =
    message.unit

proc `unit=`*(message: ProductionPanel, value: UnitInfo) {.inline.} =
    setunit(message, value)

proc clearbuildQueue*(message: ProductionPanel) =
    message.buildQueue = @[]
    clearFields(message, [2])

proc hasbuildQueue*(message: ProductionPanel): bool =
    result = hasField(message, 2) or (len(message.buildQueue) > 0)

proc setbuildQueue*(message: ProductionPanel, value: seq[UnitInfo]) =
    message.buildQueue = value
    setField(message, 2)

proc addbuildQueue*(message: ProductionPanel, value: UnitInfo) =
    add(message.buildQueue, value)

proc buildQueue*(message: ProductionPanel): seq[UnitInfo] {.inline.} =
    message.buildQueue

proc `buildQueue=`*(message: ProductionPanel, value: seq[UnitInfo]) {.inline.} =
    setbuildQueue(message, value)

proc clearproductionQueue*(message: ProductionPanel) =
    message.productionQueue = @[]
    clearFields(message, [3])

proc hasproductionQueue*(message: ProductionPanel): bool =
    result = hasField(message, 3) or (len(message.productionQueue) > 0)

proc setproductionQueue*(message: ProductionPanel, value: seq[BuildItem]) =
    message.productionQueue = value
    setField(message, 3)

proc addproductionQueue*(message: ProductionPanel, value: BuildItem) =
    add(message.productionQueue, value)

proc productionQueue*(message: ProductionPanel): seq[BuildItem] {.inline.} =
    message.productionQueue

proc `productionQueue=`*(message: ProductionPanel, value: seq[BuildItem]) {.inline.} =
    setproductionQueue(message, value)

proc `$`*(message: ProductionPanel): string =
    runnableExamples:
        echo $ProductionPanel
        echo fmt"{ProductionPanel}"
        echo &"{ProductionPanel}"
    var resultSeq: seq[string]
    if message.hasunit:
        resultSeq.add(&"unit: {message.unit}")
    if message.hasbuildQueue:
        resultSeq.add(&"buildQueue: {message.buildQueue}")
    if message.hasproductionQueue:
        resultSeq.add(&"productionQueue: {message.productionQueue}")
    result = resultSeq.join(", ")
    result = &"ProductionPanel({result})"

proc sizeOfProductionPanel*(message: ProductionPanel): uint64 =
    if hasunit(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfUnitInfo(message.unit))
    for value in message.buildQueue:
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfUnitInfo(value))
    for value in message.productionQueue:
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfBuildItem(value))
    result = result + sizeOfUnknownFields(message)

proc writeProductionPanel*(stream: Stream, message: ProductionPanel) =
    if hasunit(message):
        writeMessage(stream, message.unit, 1)
    for value in message.buildQueue:
        writeMessage(stream, value, 2)
    for value in message.productionQueue:
        writeMessage(stream, value, 3)
    writeUnknownFields(stream, message)

proc readProductionPanel*(stream: Stream): ProductionPanel =
    result = newProductionPanel()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunit(result, newUnitInfo(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addbuildQueue(result, newUnitInfo(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addproductionQueue(result, newBuildItem(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ProductionPanel): string =
    let
        ss = newStringStream()
    writeProductionPanel(ss, message)
    result = ss.data

proc newProductionPanel*(data: string): ProductionPanel =
    let
        ss = newStringStream(data)
    result = readProductionPanel(ss)

proc newProductionPanel*(data: seq[byte]): ProductionPanel =
    let
        ss = newStringStream(cast[string](data))
    result = readProductionPanel(ss)


proc fullyQualifiedName*(T: typedesc[ActionMultiPanel]): string = "ActionMultiPanel"

proc readActionMultiPanelImpl(stream: Stream): Message = readActionMultiPanel(stream)
proc writeActionMultiPanelImpl(stream: Stream, msg: Message) = writeActionMultiPanel(stream, ActionMultiPanel(msg))

proc ActionMultiPanelProcs*(): MessageProcs =
    result.readImpl = readActionMultiPanelImpl
    result.writeImpl = writeActionMultiPanelImpl

proc newActionMultiPanel*(): ActionMultiPanel =
    new(result)
    initMessage(result[])
    result.procs = ActionMultiPanelProcs()
    result.ftype = ActionMultiPanel_Type.SingleSelect
    result.unitIndex = 0

proc clearftype*(message: ActionMultiPanel) =
    message.ftype = ActionMultiPanel_Type.SingleSelect
    clearFields(message, [1])

proc hasftype*(message: ActionMultiPanel): bool =
    result = hasField(message, 1)

proc setftype*(message: ActionMultiPanel, value: ActionMultiPanel_Type) =
    message.ftype = value
    setField(message, 1)

proc ftype*(message: ActionMultiPanel): ActionMultiPanel_Type {.inline.} =
    message.ftype

proc `ftype=`*(message: ActionMultiPanel, value: ActionMultiPanel_Type) {.inline.} =
    setftype(message, value)

proc clearunitIndex*(message: ActionMultiPanel) =
    message.unitIndex = 0
    clearFields(message, [2])

proc hasunitIndex*(message: ActionMultiPanel): bool =
    result = hasField(message, 2)

proc setunitIndex*(message: ActionMultiPanel, value: int32) =
    message.unitIndex = value
    setField(message, 2)

proc unitIndex*(message: ActionMultiPanel): int32 {.inline.} =
    message.unitIndex

proc `unitIndex=`*(message: ActionMultiPanel, value: int32) {.inline.} =
    setunitIndex(message, value)

proc `$`*(message: ActionMultiPanel): string =
    runnableExamples:
        echo $ActionMultiPanel
        echo fmt"{ActionMultiPanel}"
        echo &"{ActionMultiPanel}"
    var resultSeq: seq[string]
    if message.hasftype:
        resultSeq.add(&"ftype: {message.ftype}")
    if message.hasunitIndex:
        resultSeq.add(&"unitIndex: {message.unitIndex}")
    result = resultSeq.join(", ")
    result = &"ActionMultiPanel({result})"

proc sizeOfActionMultiPanel*(message: ActionMultiPanel): uint64 =
    if hasftype(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfEnum[ActionMultiPanel_Type](message.ftype)
    if hasunitIndex(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfInt32(message.unitIndex)
    result = result + sizeOfUnknownFields(message)

proc writeActionMultiPanel*(stream: Stream, message: ActionMultiPanel) =
    if hasftype(message):
        protoWriteEnum(stream, message.ftype, 1)
    if hasunitIndex(message):
        protoWriteInt32(stream, message.unitIndex, 2)
    writeUnknownFields(stream, message)

proc readActionMultiPanel*(stream: Stream): ActionMultiPanel =
    result = newActionMultiPanel()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setftype(result, protoReadEnum[ActionMultiPanel_Type](stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setunitIndex(result, protoReadInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionMultiPanel): string =
    let
        ss = newStringStream()
    writeActionMultiPanel(ss, message)
    result = ss.data

proc newActionMultiPanel*(data: string): ActionMultiPanel =
    let
        ss = newStringStream(data)
    result = readActionMultiPanel(ss)

proc newActionMultiPanel*(data: seq[byte]): ActionMultiPanel =
    let
        ss = newStringStream(cast[string](data))
    result = readActionMultiPanel(ss)


proc fullyQualifiedName*(T: typedesc[ActionControlGroup]): string = "ActionControlGroup"

proc readActionControlGroupImpl(stream: Stream): Message = readActionControlGroup(stream)
proc writeActionControlGroupImpl(stream: Stream, msg: Message) = writeActionControlGroup(stream, ActionControlGroup(msg))

proc ActionControlGroupProcs*(): MessageProcs =
    result.readImpl = readActionControlGroupImpl
    result.writeImpl = writeActionControlGroupImpl

proc newActionControlGroup*(): ActionControlGroup =
    new(result)
    initMessage(result[])
    result.procs = ActionControlGroupProcs()
    result.action = ActionControlGroup_ControlGroupAction.Recall
    result.controlGroupIndex = 0

proc clearaction*(message: ActionControlGroup) =
    message.action = ActionControlGroup_ControlGroupAction.Recall
    clearFields(message, [1])

proc hasaction*(message: ActionControlGroup): bool =
    result = hasField(message, 1)

proc setaction*(message: ActionControlGroup, value: ActionControlGroup_ControlGroupAction) =
    message.action = value
    setField(message, 1)

proc action*(message: ActionControlGroup): ActionControlGroup_ControlGroupAction {.inline.} =
    message.action

proc `action=`*(message: ActionControlGroup, value: ActionControlGroup_ControlGroupAction) {.inline.} =
    setaction(message, value)

proc clearcontrolGroupIndex*(message: ActionControlGroup) =
    message.controlGroupIndex = 0
    clearFields(message, [2])

proc hascontrolGroupIndex*(message: ActionControlGroup): bool =
    result = hasField(message, 2)

proc setcontrolGroupIndex*(message: ActionControlGroup, value: uint32) =
    message.controlGroupIndex = value
    setField(message, 2)

proc controlGroupIndex*(message: ActionControlGroup): uint32 {.inline.} =
    message.controlGroupIndex

proc `controlGroupIndex=`*(message: ActionControlGroup, value: uint32) {.inline.} =
    setcontrolGroupIndex(message, value)

proc `$`*(message: ActionControlGroup): string =
    runnableExamples:
        echo $ActionControlGroup
        echo fmt"{ActionControlGroup}"
        echo &"{ActionControlGroup}"
    var resultSeq: seq[string]
    if message.hasaction:
        resultSeq.add(&"action: {message.action}")
    if message.hascontrolGroupIndex:
        resultSeq.add(&"controlGroupIndex: {message.controlGroupIndex}")
    result = resultSeq.join(", ")
    result = &"ActionControlGroup({result})"

proc sizeOfActionControlGroup*(message: ActionControlGroup): uint64 =
    if hasaction(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfEnum[ActionControlGroup_ControlGroupAction](message.action)
    if hascontrolGroupIndex(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfUInt32(message.controlGroupIndex)
    result = result + sizeOfUnknownFields(message)

proc writeActionControlGroup*(stream: Stream, message: ActionControlGroup) =
    if hasaction(message):
        protoWriteEnum(stream, message.action, 1)
    if hascontrolGroupIndex(message):
        protoWriteUInt32(stream, message.controlGroupIndex, 2)
    writeUnknownFields(stream, message)

proc readActionControlGroup*(stream: Stream): ActionControlGroup =
    result = newActionControlGroup()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setaction(result, protoReadEnum[ActionControlGroup_ControlGroupAction](stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setcontrolGroupIndex(result, protoReadUInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionControlGroup): string =
    let
        ss = newStringStream()
    writeActionControlGroup(ss, message)
    result = ss.data

proc newActionControlGroup*(data: string): ActionControlGroup =
    let
        ss = newStringStream(data)
    result = readActionControlGroup(ss)

proc newActionControlGroup*(data: seq[byte]): ActionControlGroup =
    let
        ss = newStringStream(cast[string](data))
    result = readActionControlGroup(ss)


proc fullyQualifiedName*(T: typedesc[ControlGroup]): string = "ControlGroup"

proc readControlGroupImpl(stream: Stream): Message = readControlGroup(stream)
proc writeControlGroupImpl(stream: Stream, msg: Message) = writeControlGroup(stream, ControlGroup(msg))

proc ControlGroupProcs*(): MessageProcs =
    result.readImpl = readControlGroupImpl
    result.writeImpl = writeControlGroupImpl

proc newControlGroup*(): ControlGroup =
    new(result)
    initMessage(result[])
    result.procs = ControlGroupProcs()
    result.controlGroupIndex = 0
    result.leaderUnitType = 0
    result.count = 0

proc clearcontrolGroupIndex*(message: ControlGroup) =
    message.controlGroupIndex = 0
    clearFields(message, [1])

proc hascontrolGroupIndex*(message: ControlGroup): bool =
    result = hasField(message, 1)

proc setcontrolGroupIndex*(message: ControlGroup, value: uint32) =
    message.controlGroupIndex = value
    setField(message, 1)

proc controlGroupIndex*(message: ControlGroup): uint32 {.inline.} =
    message.controlGroupIndex

proc `controlGroupIndex=`*(message: ControlGroup, value: uint32) {.inline.} =
    setcontrolGroupIndex(message, value)

proc clearleaderUnitType*(message: ControlGroup) =
    message.leaderUnitType = 0
    clearFields(message, [2])

proc hasleaderUnitType*(message: ControlGroup): bool =
    result = hasField(message, 2)

proc setleaderUnitType*(message: ControlGroup, value: uint32) =
    message.leaderUnitType = value
    setField(message, 2)

proc leaderUnitType*(message: ControlGroup): uint32 {.inline.} =
    message.leaderUnitType

proc `leaderUnitType=`*(message: ControlGroup, value: uint32) {.inline.} =
    setleaderUnitType(message, value)

proc clearcount*(message: ControlGroup) =
    message.count = 0
    clearFields(message, [3])

proc hascount*(message: ControlGroup): bool =
    result = hasField(message, 3)

proc setcount*(message: ControlGroup, value: uint32) =
    message.count = value
    setField(message, 3)

proc count*(message: ControlGroup): uint32 {.inline.} =
    message.count

proc `count=`*(message: ControlGroup, value: uint32) {.inline.} =
    setcount(message, value)

proc `$`*(message: ControlGroup): string =
    runnableExamples:
        echo $ControlGroup
        echo fmt"{ControlGroup}"
        echo &"{ControlGroup}"
    var resultSeq: seq[string]
    if message.hascontrolGroupIndex:
        resultSeq.add(&"controlGroupIndex: {message.controlGroupIndex}")
    if message.hasleaderUnitType:
        resultSeq.add(&"leaderUnitType: {message.leaderUnitType}")
    if message.hascount:
        resultSeq.add(&"count: {message.count}")
    result = resultSeq.join(", ")
    result = &"ControlGroup({result})"

proc sizeOfControlGroup*(message: ControlGroup): uint64 =
    if hascontrolGroupIndex(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.controlGroupIndex)
    if hasleaderUnitType(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfUInt32(message.leaderUnitType)
    if hascount(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfUInt32(message.count)
    result = result + sizeOfUnknownFields(message)

proc writeControlGroup*(stream: Stream, message: ControlGroup) =
    if hascontrolGroupIndex(message):
        protoWriteUInt32(stream, message.controlGroupIndex, 1)
    if hasleaderUnitType(message):
        protoWriteUInt32(stream, message.leaderUnitType, 2)
    if hascount(message):
        protoWriteUInt32(stream, message.count, 3)
    writeUnknownFields(stream, message)

proc readControlGroup*(stream: Stream): ControlGroup =
    result = newControlGroup()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setcontrolGroupIndex(result, protoReadUInt32(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setleaderUnitType(result, protoReadUInt32(stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setcount(result, protoReadUInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ControlGroup): string =
    let
        ss = newStringStream()
    writeControlGroup(ss, message)
    result = ss.data

proc newControlGroup*(data: string): ControlGroup =
    let
        ss = newStringStream(data)
    result = readControlGroup(ss)

proc newControlGroup*(data: seq[byte]): ControlGroup =
    let
        ss = newStringStream(cast[string](data))
    result = readControlGroup(ss)


proc fullyQualifiedName*(T: typedesc[MultiPanel]): string = "MultiPanel"

proc readMultiPanelImpl(stream: Stream): Message = readMultiPanel(stream)
proc writeMultiPanelImpl(stream: Stream, msg: Message) = writeMultiPanel(stream, MultiPanel(msg))

proc MultiPanelProcs*(): MessageProcs =
    result.readImpl = readMultiPanelImpl
    result.writeImpl = writeMultiPanelImpl

proc newMultiPanel*(): MultiPanel =
    new(result)
    initMessage(result[])
    result.procs = MultiPanelProcs()
    result.units = @[]

proc clearunits*(message: MultiPanel) =
    message.units = @[]
    clearFields(message, [1])

proc hasunits*(message: MultiPanel): bool =
    result = hasField(message, 1) or (len(message.units) > 0)

proc setunits*(message: MultiPanel, value: seq[UnitInfo]) =
    message.units = value
    setField(message, 1)

proc addunits*(message: MultiPanel, value: UnitInfo) =
    add(message.units, value)

proc units*(message: MultiPanel): seq[UnitInfo] {.inline.} =
    message.units

proc `units=`*(message: MultiPanel, value: seq[UnitInfo]) {.inline.} =
    setunits(message, value)

proc `$`*(message: MultiPanel): string =
    runnableExamples:
        echo $MultiPanel
        echo fmt"{MultiPanel}"
        echo &"{MultiPanel}"
    var resultSeq: seq[string]
    if message.hasunits:
        resultSeq.add(&"units: {message.units}")
    result = resultSeq.join(", ")
    result = &"MultiPanel({result})"

proc sizeOfMultiPanel*(message: MultiPanel): uint64 =
    for value in message.units:
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfUnitInfo(value))
    result = result + sizeOfUnknownFields(message)

proc writeMultiPanel*(stream: Stream, message: MultiPanel) =
    for value in message.units:
        writeMessage(stream, value, 1)
    writeUnknownFields(stream, message)

proc readMultiPanel*(stream: Stream): MultiPanel =
    result = newMultiPanel()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addunits(result, newUnitInfo(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: MultiPanel): string =
    let
        ss = newStringStream()
    writeMultiPanel(ss, message)
    result = ss.data

proc newMultiPanel*(data: string): MultiPanel =
    let
        ss = newStringStream(data)
    result = readMultiPanel(ss)

proc newMultiPanel*(data: seq[byte]): MultiPanel =
    let
        ss = newStringStream(cast[string](data))
    result = readMultiPanel(ss)


proc fullyQualifiedName*(T: typedesc[CargoPanel]): string = "CargoPanel"

proc readCargoPanelImpl(stream: Stream): Message = readCargoPanel(stream)
proc writeCargoPanelImpl(stream: Stream, msg: Message) = writeCargoPanel(stream, CargoPanel(msg))

proc CargoPanelProcs*(): MessageProcs =
    result.readImpl = readCargoPanelImpl
    result.writeImpl = writeCargoPanelImpl

proc newCargoPanel*(): CargoPanel =
    new(result)
    initMessage(result[])
    result.procs = CargoPanelProcs()
    result.unit = nil
    result.passengers = @[]
    result.slotsAvailable = 0

proc clearunit*(message: CargoPanel) =
    message.unit = nil
    clearFields(message, [1])

proc hasunit*(message: CargoPanel): bool =
    result = hasField(message, 1)

proc setunit*(message: CargoPanel, value: UnitInfo) =
    message.unit = value
    setField(message, 1)

proc unit*(message: CargoPanel): UnitInfo {.inline.} =
    message.unit

proc `unit=`*(message: CargoPanel, value: UnitInfo) {.inline.} =
    setunit(message, value)

proc clearpassengers*(message: CargoPanel) =
    message.passengers = @[]
    clearFields(message, [2])

proc haspassengers*(message: CargoPanel): bool =
    result = hasField(message, 2) or (len(message.passengers) > 0)

proc setpassengers*(message: CargoPanel, value: seq[UnitInfo]) =
    message.passengers = value
    setField(message, 2)

proc addpassengers*(message: CargoPanel, value: UnitInfo) =
    add(message.passengers, value)

proc passengers*(message: CargoPanel): seq[UnitInfo] {.inline.} =
    message.passengers

proc `passengers=`*(message: CargoPanel, value: seq[UnitInfo]) {.inline.} =
    setpassengers(message, value)

proc clearslotsAvailable*(message: CargoPanel) =
    message.slotsAvailable = 0
    clearFields(message, [3])

proc hasslotsAvailable*(message: CargoPanel): bool =
    result = hasField(message, 3)

proc setslotsAvailable*(message: CargoPanel, value: int32) =
    message.slotsAvailable = value
    setField(message, 3)

proc slotsAvailable*(message: CargoPanel): int32 {.inline.} =
    message.slotsAvailable

proc `slotsAvailable=`*(message: CargoPanel, value: int32) {.inline.} =
    setslotsAvailable(message, value)

proc `$`*(message: CargoPanel): string =
    runnableExamples:
        echo $CargoPanel
        echo fmt"{CargoPanel}"
        echo &"{CargoPanel}"
    var resultSeq: seq[string]
    if message.hasunit:
        resultSeq.add(&"unit: {message.unit}")
    if message.haspassengers:
        resultSeq.add(&"passengers: {message.passengers}")
    if message.hasslotsAvailable:
        resultSeq.add(&"slotsAvailable: {message.slotsAvailable}")
    result = resultSeq.join(", ")
    result = &"CargoPanel({result})"

proc sizeOfCargoPanel*(message: CargoPanel): uint64 =
    if hasunit(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfUnitInfo(message.unit))
    for value in message.passengers:
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfUnitInfo(value))
    if hasslotsAvailable(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfInt32(message.slotsAvailable)
    result = result + sizeOfUnknownFields(message)

proc writeCargoPanel*(stream: Stream, message: CargoPanel) =
    if hasunit(message):
        writeMessage(stream, message.unit, 1)
    for value in message.passengers:
        writeMessage(stream, value, 2)
    if hasslotsAvailable(message):
        protoWriteInt32(stream, message.slotsAvailable, 3)
    writeUnknownFields(stream, message)

proc readCargoPanel*(stream: Stream): CargoPanel =
    result = newCargoPanel()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunit(result, newUnitInfo(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addpassengers(result, newUnitInfo(data))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setslotsAvailable(result, protoReadInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: CargoPanel): string =
    let
        ss = newStringStream()
    writeCargoPanel(ss, message)
    result = ss.data

proc newCargoPanel*(data: string): CargoPanel =
    let
        ss = newStringStream(data)
    result = readCargoPanel(ss)

proc newCargoPanel*(data: seq[byte]): CargoPanel =
    let
        ss = newStringStream(cast[string](data))
    result = readCargoPanel(ss)


proc fullyQualifiedName*(T: typedesc[ObservationUI]): string = "ObservationUI"

proc readObservationUIImpl(stream: Stream): Message = readObservationUI(stream)
proc writeObservationUIImpl(stream: Stream, msg: Message) = writeObservationUI(stream, ObservationUI(msg))

proc ObservationUIProcs*(): MessageProcs =
    result.readImpl = readObservationUIImpl
    result.writeImpl = writeObservationUIImpl

proc newObservationUI*(): ObservationUI =
    new(result)
    initMessage(result[])
    result.procs = ObservationUIProcs()
    result.groups = @[]
    result.panel = ObservationUI_panel_OneOf(kind: ObservationUI_panel_Kind.NotSet)

proc cleargroups*(message: ObservationUI) =
    message.groups = @[]
    clearFields(message, [1])

proc hasgroups*(message: ObservationUI): bool =
    result = hasField(message, 1) or (len(message.groups) > 0)

proc setgroups*(message: ObservationUI, value: seq[ControlGroup]) =
    message.groups = value
    setField(message, 1)

proc addgroups*(message: ObservationUI, value: ControlGroup) =
    add(message.groups, value)

proc groups*(message: ObservationUI): seq[ControlGroup] {.inline.} =
    message.groups

proc `groups=`*(message: ObservationUI, value: seq[ControlGroup]) {.inline.} =
    setgroups(message, value)

proc clearsingle*(message: ObservationUI) =
    reset(message.panel)
    message.panel.kind = ObservationUI_panel_Kind.NotSet
    clearFields(message, [2, 3, 4, 5])

proc hassingle*(message: ObservationUI): bool =
    result = hasField(message, 2)

proc setsingle*(message: ObservationUI, value: SinglePanel) =
    if message.panel.kind != ObservationUI_panel_Kind.Single:
        message.panel = ObservationUI_panel_OneOf(kind: ObservationUI_panel_Kind.Single, single: value)
    else:
        message.panel.single = value
    setField(message, 2)
    clearFields(message, [3, 4, 5])

proc single*(message: ObservationUI): SinglePanel {.inline.} =
    message.panel.single

proc `single=`*(message: ObservationUI, value: SinglePanel) {.inline.} =
    setsingle(message, value)

proc clearmulti*(message: ObservationUI) =
    reset(message.panel)
    message.panel.kind = ObservationUI_panel_Kind.NotSet
    clearFields(message, [3, 2, 4, 5])

proc hasmulti*(message: ObservationUI): bool =
    result = hasField(message, 3)

proc setmulti*(message: ObservationUI, value: MultiPanel) =
    if message.panel.kind != ObservationUI_panel_Kind.Multi:
        message.panel = ObservationUI_panel_OneOf(kind: ObservationUI_panel_Kind.Multi, multi: value)
    else:
        message.panel.multi = value
    setField(message, 3)
    clearFields(message, [2, 4, 5])

proc multi*(message: ObservationUI): MultiPanel {.inline.} =
    message.panel.multi

proc `multi=`*(message: ObservationUI, value: MultiPanel) {.inline.} =
    setmulti(message, value)

proc clearcargo*(message: ObservationUI) =
    reset(message.panel)
    message.panel.kind = ObservationUI_panel_Kind.NotSet
    clearFields(message, [4, 2, 3, 5])

proc hascargo*(message: ObservationUI): bool =
    result = hasField(message, 4)

proc setcargo*(message: ObservationUI, value: CargoPanel) =
    if message.panel.kind != ObservationUI_panel_Kind.Cargo:
        message.panel = ObservationUI_panel_OneOf(kind: ObservationUI_panel_Kind.Cargo, cargo: value)
    else:
        message.panel.cargo = value
    setField(message, 4)
    clearFields(message, [2, 3, 5])

proc cargo*(message: ObservationUI): CargoPanel {.inline.} =
    message.panel.cargo

proc `cargo=`*(message: ObservationUI, value: CargoPanel) {.inline.} =
    setcargo(message, value)

proc clearproduction*(message: ObservationUI) =
    reset(message.panel)
    message.panel.kind = ObservationUI_panel_Kind.NotSet
    clearFields(message, [5, 2, 3, 4])

proc hasproduction*(message: ObservationUI): bool =
    result = hasField(message, 5)

proc setproduction*(message: ObservationUI, value: ProductionPanel) =
    if message.panel.kind != ObservationUI_panel_Kind.Production:
        message.panel = ObservationUI_panel_OneOf(kind: ObservationUI_panel_Kind.Production, production: value)
    else:
        message.panel.production = value
    setField(message, 5)
    clearFields(message, [2, 3, 4])

proc production*(message: ObservationUI): ProductionPanel {.inline.} =
    message.panel.production

proc `production=`*(message: ObservationUI, value: ProductionPanel) {.inline.} =
    setproduction(message, value)

proc `$`*(message: ObservationUI): string =
    runnableExamples:
        echo $ObservationUI
        echo fmt"{ObservationUI}"
        echo &"{ObservationUI}"
    var resultSeq: seq[string]
    if message.hasgroups:
        resultSeq.add(&"groups: {message.groups}")
    if message.hassingle:
        resultSeq.add(&"single: {message.single}")
    if message.hasmulti:
        resultSeq.add(&"multi: {message.multi}")
    if message.hascargo:
        resultSeq.add(&"cargo: {message.cargo}")
    if message.hasproduction:
        resultSeq.add(&"production: {message.production}")
    result = resultSeq.join(", ")
    result = &"ObservationUI({result})"

proc sizeOfObservationUI*(message: ObservationUI): uint64 =
    for value in message.groups:
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfControlGroup(value))
    if hassingle(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfSinglePanel(message.panel.single))
    if hasmulti(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfMultiPanel(message.panel.multi))
    if hascargo(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfCargoPanel(message.panel.cargo))
    if hasproduction(message):
        result = result + sizeOfTag(5, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfProductionPanel(message.panel.production))
    result = result + sizeOfUnknownFields(message)

proc writeObservationUI*(stream: Stream, message: ObservationUI) =
    for value in message.groups:
        writeMessage(stream, value, 1)
    if hassingle(message):
        writeMessage(stream, message.panel.single, 2)
    if hasmulti(message):
        writeMessage(stream, message.panel.multi, 3)
    if hascargo(message):
        writeMessage(stream, message.panel.cargo, 4)
    if hasproduction(message):
        writeMessage(stream, message.panel.production, 5)
    writeUnknownFields(stream, message)

proc readObservationUI*(stream: Stream): ObservationUI =
    result = newObservationUI()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addgroups(result, newControlGroup(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setsingle(result, newSinglePanel(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setmulti(result, newMultiPanel(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcargo(result, newCargoPanel(data))
        of 5:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setproduction(result, newProductionPanel(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ObservationUI): string =
    let
        ss = newStringStream()
    writeObservationUI(ss, message)
    result = ss.data

proc newObservationUI*(data: string): ObservationUI =
    let
        ss = newStringStream(data)
    result = readObservationUI(ss)

proc newObservationUI*(data: seq[byte]): ObservationUI =
    let
        ss = newStringStream(cast[string](data))
    result = readObservationUI(ss)


proc fullyQualifiedName*(T: typedesc[ActionSelectArmy]): string = "ActionSelectArmy"

proc readActionSelectArmyImpl(stream: Stream): Message = readActionSelectArmy(stream)
proc writeActionSelectArmyImpl(stream: Stream, msg: Message) = writeActionSelectArmy(stream, ActionSelectArmy(msg))

proc ActionSelectArmyProcs*(): MessageProcs =
    result.readImpl = readActionSelectArmyImpl
    result.writeImpl = writeActionSelectArmyImpl

proc newActionSelectArmy*(): ActionSelectArmy =
    new(result)
    initMessage(result[])
    result.procs = ActionSelectArmyProcs()
    result.selectionAdd = false

proc clearselectionAdd*(message: ActionSelectArmy) =
    message.selectionAdd = false
    clearFields(message, [1])

proc hasselectionAdd*(message: ActionSelectArmy): bool =
    result = hasField(message, 1)

proc setselectionAdd*(message: ActionSelectArmy, value: bool) =
    message.selectionAdd = value
    setField(message, 1)

proc selectionAdd*(message: ActionSelectArmy): bool {.inline.} =
    message.selectionAdd

proc `selectionAdd=`*(message: ActionSelectArmy, value: bool) {.inline.} =
    setselectionAdd(message, value)

proc `$`*(message: ActionSelectArmy): string =
    runnableExamples:
        echo $ActionSelectArmy
        echo fmt"{ActionSelectArmy}"
        echo &"{ActionSelectArmy}"
    var resultSeq: seq[string]
    if message.hasselectionAdd:
        resultSeq.add(&"selectionAdd: {message.selectionAdd}")
    result = resultSeq.join(", ")
    result = &"ActionSelectArmy({result})"

proc sizeOfActionSelectArmy*(message: ActionSelectArmy): uint64 =
    if hasselectionAdd(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfBool(message.selectionAdd)
    result = result + sizeOfUnknownFields(message)

proc writeActionSelectArmy*(stream: Stream, message: ActionSelectArmy) =
    if hasselectionAdd(message):
        protoWriteBool(stream, message.selectionAdd, 1)
    writeUnknownFields(stream, message)

proc readActionSelectArmy*(stream: Stream): ActionSelectArmy =
    result = newActionSelectArmy()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setselectionAdd(result, protoReadBool(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionSelectArmy): string =
    let
        ss = newStringStream()
    writeActionSelectArmy(ss, message)
    result = ss.data

proc newActionSelectArmy*(data: string): ActionSelectArmy =
    let
        ss = newStringStream(data)
    result = readActionSelectArmy(ss)

proc newActionSelectArmy*(data: seq[byte]): ActionSelectArmy =
    let
        ss = newStringStream(cast[string](data))
    result = readActionSelectArmy(ss)


proc fullyQualifiedName*(T: typedesc[ActionSelectWarpGates]): string = "ActionSelectWarpGates"

proc readActionSelectWarpGatesImpl(stream: Stream): Message = readActionSelectWarpGates(stream)
proc writeActionSelectWarpGatesImpl(stream: Stream, msg: Message) = writeActionSelectWarpGates(stream, ActionSelectWarpGates(msg))

proc ActionSelectWarpGatesProcs*(): MessageProcs =
    result.readImpl = readActionSelectWarpGatesImpl
    result.writeImpl = writeActionSelectWarpGatesImpl

proc newActionSelectWarpGates*(): ActionSelectWarpGates =
    new(result)
    initMessage(result[])
    result.procs = ActionSelectWarpGatesProcs()
    result.selectionAdd = false

proc clearselectionAdd*(message: ActionSelectWarpGates) =
    message.selectionAdd = false
    clearFields(message, [1])

proc hasselectionAdd*(message: ActionSelectWarpGates): bool =
    result = hasField(message, 1)

proc setselectionAdd*(message: ActionSelectWarpGates, value: bool) =
    message.selectionAdd = value
    setField(message, 1)

proc selectionAdd*(message: ActionSelectWarpGates): bool {.inline.} =
    message.selectionAdd

proc `selectionAdd=`*(message: ActionSelectWarpGates, value: bool) {.inline.} =
    setselectionAdd(message, value)

proc `$`*(message: ActionSelectWarpGates): string =
    runnableExamples:
        echo $ActionSelectWarpGates
        echo fmt"{ActionSelectWarpGates}"
        echo &"{ActionSelectWarpGates}"
    var resultSeq: seq[string]
    if message.hasselectionAdd:
        resultSeq.add(&"selectionAdd: {message.selectionAdd}")
    result = resultSeq.join(", ")
    result = &"ActionSelectWarpGates({result})"

proc sizeOfActionSelectWarpGates*(message: ActionSelectWarpGates): uint64 =
    if hasselectionAdd(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfBool(message.selectionAdd)
    result = result + sizeOfUnknownFields(message)

proc writeActionSelectWarpGates*(stream: Stream, message: ActionSelectWarpGates) =
    if hasselectionAdd(message):
        protoWriteBool(stream, message.selectionAdd, 1)
    writeUnknownFields(stream, message)

proc readActionSelectWarpGates*(stream: Stream): ActionSelectWarpGates =
    result = newActionSelectWarpGates()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setselectionAdd(result, protoReadBool(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionSelectWarpGates): string =
    let
        ss = newStringStream()
    writeActionSelectWarpGates(ss, message)
    result = ss.data

proc newActionSelectWarpGates*(data: string): ActionSelectWarpGates =
    let
        ss = newStringStream(data)
    result = readActionSelectWarpGates(ss)

proc newActionSelectWarpGates*(data: seq[byte]): ActionSelectWarpGates =
    let
        ss = newStringStream(cast[string](data))
    result = readActionSelectWarpGates(ss)


proc fullyQualifiedName*(T: typedesc[ActionToggleAutocast]): string = "ActionToggleAutocast"

proc readActionToggleAutocastImpl(stream: Stream): Message = readActionToggleAutocast(stream)
proc writeActionToggleAutocastImpl(stream: Stream, msg: Message) = writeActionToggleAutocast(stream, ActionToggleAutocast(msg))

proc ActionToggleAutocastProcs*(): MessageProcs =
    result.readImpl = readActionToggleAutocastImpl
    result.writeImpl = writeActionToggleAutocastImpl

proc newActionToggleAutocast*(): ActionToggleAutocast =
    new(result)
    initMessage(result[])
    result.procs = ActionToggleAutocastProcs()
    result.abilityId = 0

proc clearabilityId*(message: ActionToggleAutocast) =
    message.abilityId = 0
    clearFields(message, [1])

proc hasabilityId*(message: ActionToggleAutocast): bool =
    result = hasField(message, 1)

proc setabilityId*(message: ActionToggleAutocast, value: int32) =
    message.abilityId = value
    setField(message, 1)

proc abilityId*(message: ActionToggleAutocast): int32 {.inline.} =
    message.abilityId

proc `abilityId=`*(message: ActionToggleAutocast, value: int32) {.inline.} =
    setabilityId(message, value)

proc `$`*(message: ActionToggleAutocast): string =
    runnableExamples:
        echo $ActionToggleAutocast
        echo fmt"{ActionToggleAutocast}"
        echo &"{ActionToggleAutocast}"
    var resultSeq: seq[string]
    if message.hasabilityId:
        resultSeq.add(&"abilityId: {message.abilityId}")
    result = resultSeq.join(", ")
    result = &"ActionToggleAutocast({result})"

proc sizeOfActionToggleAutocast*(message: ActionToggleAutocast): uint64 =
    if hasabilityId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfInt32(message.abilityId)
    result = result + sizeOfUnknownFields(message)

proc writeActionToggleAutocast*(stream: Stream, message: ActionToggleAutocast) =
    if hasabilityId(message):
        protoWriteInt32(stream, message.abilityId, 1)
    writeUnknownFields(stream, message)

proc readActionToggleAutocast*(stream: Stream): ActionToggleAutocast =
    result = newActionToggleAutocast()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setabilityId(result, protoReadInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionToggleAutocast): string =
    let
        ss = newStringStream()
    writeActionToggleAutocast(ss, message)
    result = ss.data

proc newActionToggleAutocast*(data: string): ActionToggleAutocast =
    let
        ss = newStringStream(data)
    result = readActionToggleAutocast(ss)

proc newActionToggleAutocast*(data: seq[byte]): ActionToggleAutocast =
    let
        ss = newStringStream(cast[string](data))
    result = readActionToggleAutocast(ss)


proc fullyQualifiedName*(T: typedesc[ActionUI]): string = "ActionUI"

proc readActionUIImpl(stream: Stream): Message = readActionUI(stream)
proc writeActionUIImpl(stream: Stream, msg: Message) = writeActionUI(stream, ActionUI(msg))

proc ActionUIProcs*(): MessageProcs =
    result.readImpl = readActionUIImpl
    result.writeImpl = writeActionUIImpl

proc newActionUI*(): ActionUI =
    new(result)
    initMessage(result[])
    result.procs = ActionUIProcs()
    result.action = ActionUI_action_OneOf(kind: ActionUI_action_Kind.NotSet)

proc clearcontrolGroup*(message: ActionUI) =
    reset(message.action)
    message.action.kind = ActionUI_action_Kind.NotSet
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8, 9])

proc hascontrolGroup*(message: ActionUI): bool =
    result = hasField(message, 1)

proc setcontrolGroup*(message: ActionUI, value: ActionControlGroup) =
    if message.action.kind != ActionUI_action_Kind.ControlGroup:
        message.action = ActionUI_action_OneOf(kind: ActionUI_action_Kind.ControlGroup, controlGroup: value)
    else:
        message.action.controlGroup = value
    setField(message, 1)
    clearFields(message, [2, 3, 4, 5, 6, 7, 8, 9])

proc controlGroup*(message: ActionUI): ActionControlGroup {.inline.} =
    message.action.controlGroup

proc `controlGroup=`*(message: ActionUI, value: ActionControlGroup) {.inline.} =
    setcontrolGroup(message, value)

proc clearselectArmy*(message: ActionUI) =
    reset(message.action)
    message.action.kind = ActionUI_action_Kind.NotSet
    clearFields(message, [2, 1, 3, 4, 5, 6, 7, 8, 9])

proc hasselectArmy*(message: ActionUI): bool =
    result = hasField(message, 2)

proc setselectArmy*(message: ActionUI, value: ActionSelectArmy) =
    if message.action.kind != ActionUI_action_Kind.SelectArmy:
        message.action = ActionUI_action_OneOf(kind: ActionUI_action_Kind.SelectArmy, selectArmy: value)
    else:
        message.action.selectArmy = value
    setField(message, 2)
    clearFields(message, [1, 3, 4, 5, 6, 7, 8, 9])

proc selectArmy*(message: ActionUI): ActionSelectArmy {.inline.} =
    message.action.selectArmy

proc `selectArmy=`*(message: ActionUI, value: ActionSelectArmy) {.inline.} =
    setselectArmy(message, value)

proc clearselectWarpGates*(message: ActionUI) =
    reset(message.action)
    message.action.kind = ActionUI_action_Kind.NotSet
    clearFields(message, [3, 1, 2, 4, 5, 6, 7, 8, 9])

proc hasselectWarpGates*(message: ActionUI): bool =
    result = hasField(message, 3)

proc setselectWarpGates*(message: ActionUI, value: ActionSelectWarpGates) =
    if message.action.kind != ActionUI_action_Kind.SelectWarpGates:
        message.action = ActionUI_action_OneOf(kind: ActionUI_action_Kind.SelectWarpGates, selectWarpGates: value)
    else:
        message.action.selectWarpGates = value
    setField(message, 3)
    clearFields(message, [1, 2, 4, 5, 6, 7, 8, 9])

proc selectWarpGates*(message: ActionUI): ActionSelectWarpGates {.inline.} =
    message.action.selectWarpGates

proc `selectWarpGates=`*(message: ActionUI, value: ActionSelectWarpGates) {.inline.} =
    setselectWarpGates(message, value)

proc clearselectLarva*(message: ActionUI) =
    reset(message.action)
    message.action.kind = ActionUI_action_Kind.NotSet
    clearFields(message, [4, 1, 2, 3, 5, 6, 7, 8, 9])

proc hasselectLarva*(message: ActionUI): bool =
    result = hasField(message, 4)

proc setselectLarva*(message: ActionUI, value: ActionSelectLarva) =
    if message.action.kind != ActionUI_action_Kind.SelectLarva:
        message.action = ActionUI_action_OneOf(kind: ActionUI_action_Kind.SelectLarva, selectLarva: value)
    else:
        message.action.selectLarva = value
    setField(message, 4)
    clearFields(message, [1, 2, 3, 5, 6, 7, 8, 9])

proc selectLarva*(message: ActionUI): ActionSelectLarva {.inline.} =
    message.action.selectLarva

proc `selectLarva=`*(message: ActionUI, value: ActionSelectLarva) {.inline.} =
    setselectLarva(message, value)

proc clearselectIdleWorker*(message: ActionUI) =
    reset(message.action)
    message.action.kind = ActionUI_action_Kind.NotSet
    clearFields(message, [5, 1, 2, 3, 4, 6, 7, 8, 9])

proc hasselectIdleWorker*(message: ActionUI): bool =
    result = hasField(message, 5)

proc setselectIdleWorker*(message: ActionUI, value: ActionSelectIdleWorker) =
    if message.action.kind != ActionUI_action_Kind.SelectIdleWorker:
        message.action = ActionUI_action_OneOf(kind: ActionUI_action_Kind.SelectIdleWorker, selectIdleWorker: value)
    else:
        message.action.selectIdleWorker = value
    setField(message, 5)
    clearFields(message, [1, 2, 3, 4, 6, 7, 8, 9])

proc selectIdleWorker*(message: ActionUI): ActionSelectIdleWorker {.inline.} =
    message.action.selectIdleWorker

proc `selectIdleWorker=`*(message: ActionUI, value: ActionSelectIdleWorker) {.inline.} =
    setselectIdleWorker(message, value)

proc clearmultiPanel*(message: ActionUI) =
    reset(message.action)
    message.action.kind = ActionUI_action_Kind.NotSet
    clearFields(message, [6, 1, 2, 3, 4, 5, 7, 8, 9])

proc hasmultiPanel*(message: ActionUI): bool =
    result = hasField(message, 6)

proc setmultiPanel*(message: ActionUI, value: ActionMultiPanel) =
    if message.action.kind != ActionUI_action_Kind.MultiPanel:
        message.action = ActionUI_action_OneOf(kind: ActionUI_action_Kind.MultiPanel, multiPanel: value)
    else:
        message.action.multiPanel = value
    setField(message, 6)
    clearFields(message, [1, 2, 3, 4, 5, 7, 8, 9])

proc multiPanel*(message: ActionUI): ActionMultiPanel {.inline.} =
    message.action.multiPanel

proc `multiPanel=`*(message: ActionUI, value: ActionMultiPanel) {.inline.} =
    setmultiPanel(message, value)

proc clearcargoPanel*(message: ActionUI) =
    reset(message.action)
    message.action.kind = ActionUI_action_Kind.NotSet
    clearFields(message, [7, 1, 2, 3, 4, 5, 6, 8, 9])

proc hascargoPanel*(message: ActionUI): bool =
    result = hasField(message, 7)

proc setcargoPanel*(message: ActionUI, value: ActionCargoPanelUnload) =
    if message.action.kind != ActionUI_action_Kind.CargoPanel:
        message.action = ActionUI_action_OneOf(kind: ActionUI_action_Kind.CargoPanel, cargoPanel: value)
    else:
        message.action.cargoPanel = value
    setField(message, 7)
    clearFields(message, [1, 2, 3, 4, 5, 6, 8, 9])

proc cargoPanel*(message: ActionUI): ActionCargoPanelUnload {.inline.} =
    message.action.cargoPanel

proc `cargoPanel=`*(message: ActionUI, value: ActionCargoPanelUnload) {.inline.} =
    setcargoPanel(message, value)

proc clearproductionPanel*(message: ActionUI) =
    reset(message.action)
    message.action.kind = ActionUI_action_Kind.NotSet
    clearFields(message, [8, 1, 2, 3, 4, 5, 6, 7, 9])

proc hasproductionPanel*(message: ActionUI): bool =
    result = hasField(message, 8)

proc setproductionPanel*(message: ActionUI, value: ActionProductionPanelRemoveFromQueue) =
    if message.action.kind != ActionUI_action_Kind.ProductionPanel:
        message.action = ActionUI_action_OneOf(kind: ActionUI_action_Kind.ProductionPanel, productionPanel: value)
    else:
        message.action.productionPanel = value
    setField(message, 8)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 9])

proc productionPanel*(message: ActionUI): ActionProductionPanelRemoveFromQueue {.inline.} =
    message.action.productionPanel

proc `productionPanel=`*(message: ActionUI, value: ActionProductionPanelRemoveFromQueue) {.inline.} =
    setproductionPanel(message, value)

proc cleartoggleAutocast*(message: ActionUI) =
    reset(message.action)
    message.action.kind = ActionUI_action_Kind.NotSet
    clearFields(message, [9, 1, 2, 3, 4, 5, 6, 7, 8])

proc hastoggleAutocast*(message: ActionUI): bool =
    result = hasField(message, 9)

proc settoggleAutocast*(message: ActionUI, value: ActionToggleAutocast) =
    if message.action.kind != ActionUI_action_Kind.ToggleAutocast:
        message.action = ActionUI_action_OneOf(kind: ActionUI_action_Kind.ToggleAutocast, toggleAutocast: value)
    else:
        message.action.toggleAutocast = value
    setField(message, 9)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8])

proc toggleAutocast*(message: ActionUI): ActionToggleAutocast {.inline.} =
    message.action.toggleAutocast

proc `toggleAutocast=`*(message: ActionUI, value: ActionToggleAutocast) {.inline.} =
    settoggleAutocast(message, value)

proc `$`*(message: ActionUI): string =
    runnableExamples:
        echo $ActionUI
        echo fmt"{ActionUI}"
        echo &"{ActionUI}"
    var resultSeq: seq[string]
    if message.hascontrolGroup:
        resultSeq.add(&"controlGroup: {message.controlGroup}")
    if message.hasselectArmy:
        resultSeq.add(&"selectArmy: {message.selectArmy}")
    if message.hasselectWarpGates:
        resultSeq.add(&"selectWarpGates: {message.selectWarpGates}")
    if message.hasselectLarva:
        resultSeq.add(&"selectLarva: {message.selectLarva}")
    if message.hasselectIdleWorker:
        resultSeq.add(&"selectIdleWorker: {message.selectIdleWorker}")
    if message.hasmultiPanel:
        resultSeq.add(&"multiPanel: {message.multiPanel}")
    if message.hascargoPanel:
        resultSeq.add(&"cargoPanel: {message.cargoPanel}")
    if message.hasproductionPanel:
        resultSeq.add(&"productionPanel: {message.productionPanel}")
    if message.hastoggleAutocast:
        resultSeq.add(&"toggleAutocast: {message.toggleAutocast}")
    result = resultSeq.join(", ")
    result = &"ActionUI({result})"

proc sizeOfActionUI*(message: ActionUI): uint64 =
    if hascontrolGroup(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionControlGroup(message.action.controlGroup))
    if hasselectArmy(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionSelectArmy(message.action.selectArmy))
    if hasselectWarpGates(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionSelectWarpGates(message.action.selectWarpGates))
    if hasselectLarva(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionSelectLarva(message.action.selectLarva))
    if hasselectIdleWorker(message):
        result = result + sizeOfTag(5, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionSelectIdleWorker(message.action.selectIdleWorker))
    if hasmultiPanel(message):
        result = result + sizeOfTag(6, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionMultiPanel(message.action.multiPanel))
    if hascargoPanel(message):
        result = result + sizeOfTag(7, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionCargoPanelUnload(message.action.cargoPanel))
    if hasproductionPanel(message):
        result = result + sizeOfTag(8, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionProductionPanelRemoveFromQueue(message.action.productionPanel))
    if hastoggleAutocast(message):
        result = result + sizeOfTag(9, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfActionToggleAutocast(message.action.toggleAutocast))
    result = result + sizeOfUnknownFields(message)

proc writeActionUI*(stream: Stream, message: ActionUI) =
    if hascontrolGroup(message):
        writeMessage(stream, message.action.controlGroup, 1)
    if hasselectArmy(message):
        writeMessage(stream, message.action.selectArmy, 2)
    if hasselectWarpGates(message):
        writeMessage(stream, message.action.selectWarpGates, 3)
    if hasselectLarva(message):
        writeMessage(stream, message.action.selectLarva, 4)
    if hasselectIdleWorker(message):
        writeMessage(stream, message.action.selectIdleWorker, 5)
    if hasmultiPanel(message):
        writeMessage(stream, message.action.multiPanel, 6)
    if hascargoPanel(message):
        writeMessage(stream, message.action.cargoPanel, 7)
    if hasproductionPanel(message):
        writeMessage(stream, message.action.productionPanel, 8)
    if hastoggleAutocast(message):
        writeMessage(stream, message.action.toggleAutocast, 9)
    writeUnknownFields(stream, message)

proc readActionUI*(stream: Stream): ActionUI =
    result = newActionUI()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcontrolGroup(result, newActionControlGroup(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setselectArmy(result, newActionSelectArmy(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setselectWarpGates(result, newActionSelectWarpGates(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setselectLarva(result, newActionSelectLarva(data))
        of 5:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setselectIdleWorker(result, newActionSelectIdleWorker(data))
        of 6:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setmultiPanel(result, newActionMultiPanel(data))
        of 7:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcargoPanel(result, newActionCargoPanelUnload(data))
        of 8:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setproductionPanel(result, newActionProductionPanelRemoveFromQueue(data))
        of 9:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            settoggleAutocast(result, newActionToggleAutocast(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ActionUI): string =
    let
        ss = newStringStream()
    writeActionUI(ss, message)
    result = ss.data

proc newActionUI*(data: string): ActionUI =
    let
        ss = newStringStream(data)
    result = readActionUI(ss)

proc newActionUI*(data: seq[byte]): ActionUI =
    let
        ss = newStringStream(cast[string](data))
    result = readActionUI(ss)


