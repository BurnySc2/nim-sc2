# Generated by protoc_gen_nim. Do not edit!

import base64
import intsets
import json
import strformat
import strutils

import nimpb/nimpb
import nimpb/json as nimpb_json

import common_pb

type
    DebugGameState* {.pure.} = enum
        show_map = 1
        control_enemy = 2
        food = 3
        free = 4
        all_resources = 5
        god = 6
        minerals = 7
        gas = 8
        cooldown = 9
        tech_tree = 10
        upgrade = 11
        fast_build = 12
    DebugTestProcess_Test* {.pure.} = enum
        hang = 1
        crash = 2
        exit = 3
    DebugEndGame_EndResult* {.pure.} = enum
        Surrender = 1
        DeclareVictory = 2
    DebugSetUnitValue_UnitValue* {.pure.} = enum
        Energy = 1
        Life = 2
        Shields = 3
    DebugCommand* = ref DebugCommandObj
    DebugCommandObj* = object of Message
        command: DebugCommand_command_OneOf

    DebugCommand_command_Kind* {.pure.} = enum
        Draw
        GameState
        CreateUnit
        KillUnit
        TestProcess
        Score
        EndGame
        UnitValue
        NotSet

    DebugCommand_command_OneOf* = object
        case kind*: DebugCommand_command_Kind
        of DebugCommand_command_Kind.Draw: draw*: DebugDraw
        of DebugCommand_command_Kind.GameState: gameState*: DebugGameState
        of DebugCommand_command_Kind.CreateUnit: createUnit*: DebugCreateUnit
        of DebugCommand_command_Kind.KillUnit: killUnit*: DebugKillUnit
        of DebugCommand_command_Kind.TestProcess: testProcess*: DebugTestProcess
        of DebugCommand_command_Kind.Score: score*: DebugSetScore
        of DebugCommand_command_Kind.EndGame: endGame*: DebugEndGame
        of DebugCommand_command_Kind.UnitValue: unitValue*: DebugSetUnitValue
        of DebugCommand_command_Kind.NotSet: nil
    DebugDraw* = ref DebugDrawObj
    DebugDrawObj* = object of Message
        text: seq[DebugText]
        lines: seq[DebugLine]
        boxes: seq[DebugBox]
        spheres: seq[DebugSphere]
    Line* = ref LineObj
    LineObj* = object of Message
        p0: Point
        p1: Point
    Color* = ref ColorObj
    ColorObj* = object of Message
        r: uint32
        g: uint32
        b: uint32
    DebugText* = ref DebugTextObj
    DebugTextObj* = object of Message
        color: Color
        text: string
        virtualPos: Point
        worldPos: Point
        size: uint32
    DebugLine* = ref DebugLineObj
    DebugLineObj* = object of Message
        color: Color
        line: Line
    DebugBox* = ref DebugBoxObj
    DebugBoxObj* = object of Message
        color: Color
        min: Point
        max: Point
    DebugSphere* = ref DebugSphereObj
    DebugSphereObj* = object of Message
        color: Color
        p: Point
        r: float32
    DebugCreateUnit* = ref DebugCreateUnitObj
    DebugCreateUnitObj* = object of Message
        unitType: uint32
        owner: int32
        pos: Point2D
        quantity: uint32
    DebugKillUnit* = ref DebugKillUnitObj
    DebugKillUnitObj* = object of Message
        tag: seq[uint64]
    DebugTestProcess* = ref DebugTestProcessObj
    DebugTestProcessObj* = object of Message
        test: DebugTestProcess_Test
        delayMs: int32
    DebugSetScore* = ref DebugSetScoreObj
    DebugSetScoreObj* = object of Message
        score: float32
    DebugEndGame* = ref DebugEndGameObj
    DebugEndGameObj* = object of Message
        endResult: DebugEndGame_EndResult
    DebugSetUnitValue* = ref DebugSetUnitValueObj
    DebugSetUnitValueObj* = object of Message
        unitValue: DebugSetUnitValue_UnitValue
        value: float32
        unitTag: uint64

proc newColor*(): Color
proc newColor*(data: string): Color
proc newColor*(data: seq[byte]): Color
proc writeColor*(stream: Stream, message: Color)
proc readColor*(stream: Stream): Color
proc sizeOfColor*(message: Color): uint64

proc newDebugSphere*(): DebugSphere
proc newDebugSphere*(data: string): DebugSphere
proc newDebugSphere*(data: seq[byte]): DebugSphere
proc writeDebugSphere*(stream: Stream, message: DebugSphere)
proc readDebugSphere*(stream: Stream): DebugSphere
proc sizeOfDebugSphere*(message: DebugSphere): uint64

proc newDebugKillUnit*(): DebugKillUnit
proc newDebugKillUnit*(data: string): DebugKillUnit
proc newDebugKillUnit*(data: seq[byte]): DebugKillUnit
proc writeDebugKillUnit*(stream: Stream, message: DebugKillUnit)
proc readDebugKillUnit*(stream: Stream): DebugKillUnit
proc sizeOfDebugKillUnit*(message: DebugKillUnit): uint64

proc newDebugSetScore*(): DebugSetScore
proc newDebugSetScore*(data: string): DebugSetScore
proc newDebugSetScore*(data: seq[byte]): DebugSetScore
proc writeDebugSetScore*(stream: Stream, message: DebugSetScore)
proc readDebugSetScore*(stream: Stream): DebugSetScore
proc sizeOfDebugSetScore*(message: DebugSetScore): uint64

proc newDebugSetUnitValue*(): DebugSetUnitValue
proc newDebugSetUnitValue*(data: string): DebugSetUnitValue
proc newDebugSetUnitValue*(data: seq[byte]): DebugSetUnitValue
proc writeDebugSetUnitValue*(stream: Stream, message: DebugSetUnitValue)
proc readDebugSetUnitValue*(stream: Stream): DebugSetUnitValue
proc sizeOfDebugSetUnitValue*(message: DebugSetUnitValue): uint64

proc newDebugEndGame*(): DebugEndGame
proc newDebugEndGame*(data: string): DebugEndGame
proc newDebugEndGame*(data: seq[byte]): DebugEndGame
proc writeDebugEndGame*(stream: Stream, message: DebugEndGame)
proc readDebugEndGame*(stream: Stream): DebugEndGame
proc sizeOfDebugEndGame*(message: DebugEndGame): uint64

proc newDebugBox*(): DebugBox
proc newDebugBox*(data: string): DebugBox
proc newDebugBox*(data: seq[byte]): DebugBox
proc writeDebugBox*(stream: Stream, message: DebugBox)
proc readDebugBox*(stream: Stream): DebugBox
proc sizeOfDebugBox*(message: DebugBox): uint64

proc newDebugText*(): DebugText
proc newDebugText*(data: string): DebugText
proc newDebugText*(data: seq[byte]): DebugText
proc writeDebugText*(stream: Stream, message: DebugText)
proc readDebugText*(stream: Stream): DebugText
proc sizeOfDebugText*(message: DebugText): uint64

proc newLine*(): Line
proc newLine*(data: string): Line
proc newLine*(data: seq[byte]): Line
proc writeLine*(stream: Stream, message: Line)
proc readLine*(stream: Stream): Line
proc sizeOfLine*(message: Line): uint64

proc newDebugLine*(): DebugLine
proc newDebugLine*(data: string): DebugLine
proc newDebugLine*(data: seq[byte]): DebugLine
proc writeDebugLine*(stream: Stream, message: DebugLine)
proc readDebugLine*(stream: Stream): DebugLine
proc sizeOfDebugLine*(message: DebugLine): uint64

proc newDebugDraw*(): DebugDraw
proc newDebugDraw*(data: string): DebugDraw
proc newDebugDraw*(data: seq[byte]): DebugDraw
proc writeDebugDraw*(stream: Stream, message: DebugDraw)
proc readDebugDraw*(stream: Stream): DebugDraw
proc sizeOfDebugDraw*(message: DebugDraw): uint64

proc newDebugCreateUnit*(): DebugCreateUnit
proc newDebugCreateUnit*(data: string): DebugCreateUnit
proc newDebugCreateUnit*(data: seq[byte]): DebugCreateUnit
proc writeDebugCreateUnit*(stream: Stream, message: DebugCreateUnit)
proc readDebugCreateUnit*(stream: Stream): DebugCreateUnit
proc sizeOfDebugCreateUnit*(message: DebugCreateUnit): uint64

proc newDebugTestProcess*(): DebugTestProcess
proc newDebugTestProcess*(data: string): DebugTestProcess
proc newDebugTestProcess*(data: seq[byte]): DebugTestProcess
proc writeDebugTestProcess*(stream: Stream, message: DebugTestProcess)
proc readDebugTestProcess*(stream: Stream): DebugTestProcess
proc sizeOfDebugTestProcess*(message: DebugTestProcess): uint64

proc newDebugCommand*(): DebugCommand
proc newDebugCommand*(data: string): DebugCommand
proc newDebugCommand*(data: seq[byte]): DebugCommand
proc writeDebugCommand*(stream: Stream, message: DebugCommand)
proc readDebugCommand*(stream: Stream): DebugCommand
proc sizeOfDebugCommand*(message: DebugCommand): uint64

proc fullyQualifiedName*(T: typedesc[Color]): string = "Color"

proc readColorImpl(stream: Stream): Message = readColor(stream)
proc writeColorImpl(stream: Stream, msg: Message) = writeColor(stream, Color(msg))

proc ColorProcs*(): MessageProcs =
    result.readImpl = readColorImpl
    result.writeImpl = writeColorImpl

proc newColor*(): Color =
    new(result)
    initMessage(result[])
    result.procs = ColorProcs()
    result.r = 0
    result.g = 0
    result.b = 0

proc clearr*(message: Color) =
    message.r = 0
    clearFields(message, [1])

proc hasr*(message: Color): bool =
    result = hasField(message, 1)

proc setr*(message: Color, value: uint32) =
    message.r = value
    setField(message, 1)

proc r*(message: Color): uint32 {.inline.} =
    message.r

proc `r=`*(message: Color, value: uint32) {.inline.} =
    setr(message, value)

proc clearg*(message: Color) =
    message.g = 0
    clearFields(message, [2])

proc hasg*(message: Color): bool =
    result = hasField(message, 2)

proc setg*(message: Color, value: uint32) =
    message.g = value
    setField(message, 2)

proc g*(message: Color): uint32 {.inline.} =
    message.g

proc `g=`*(message: Color, value: uint32) {.inline.} =
    setg(message, value)

proc clearb*(message: Color) =
    message.b = 0
    clearFields(message, [3])

proc hasb*(message: Color): bool =
    result = hasField(message, 3)

proc setb*(message: Color, value: uint32) =
    message.b = value
    setField(message, 3)

proc b*(message: Color): uint32 {.inline.} =
    message.b

proc `b=`*(message: Color, value: uint32) {.inline.} =
    setb(message, value)

proc `$`*(message: Color): string =
    runnableExamples:
        echo $Color
        echo fmt"{Color}"
        echo &"{Color}"
    var resultSeq: seq[string]
    if message.hasr:
        resultSeq.add(&"r: {message.r}")
    if message.hasg:
        resultSeq.add(&"g: {message.g}")
    if message.hasb:
        resultSeq.add(&"b: {message.b}")
    result = resultSeq.join(", ")
    result = &"Color({result})"

proc sizeOfColor*(message: Color): uint64 =
    if hasr(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.r)
    if hasg(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfUInt32(message.g)
    if hasb(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfUInt32(message.b)
    result = result + sizeOfUnknownFields(message)

proc writeColor*(stream: Stream, message: Color) =
    if hasr(message):
        protoWriteUInt32(stream, message.r, 1)
    if hasg(message):
        protoWriteUInt32(stream, message.g, 2)
    if hasb(message):
        protoWriteUInt32(stream, message.b, 3)
    writeUnknownFields(stream, message)

proc readColor*(stream: Stream): Color =
    result = newColor()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setr(result, protoReadUInt32(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setg(result, protoReadUInt32(stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setb(result, protoReadUInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: Color): string =
    let
        ss = newStringStream()
    writeColor(ss, message)
    result = ss.data

proc newColor*(data: string): Color =
    let
        ss = newStringStream(data)
    result = readColor(ss)

proc newColor*(data: seq[byte]): Color =
    let
        ss = newStringStream(cast[string](data))
    result = readColor(ss)


proc fullyQualifiedName*(T: typedesc[DebugSphere]): string = "DebugSphere"

proc readDebugSphereImpl(stream: Stream): Message = readDebugSphere(stream)
proc writeDebugSphereImpl(stream: Stream, msg: Message) = writeDebugSphere(stream, DebugSphere(msg))

proc DebugSphereProcs*(): MessageProcs =
    result.readImpl = readDebugSphereImpl
    result.writeImpl = writeDebugSphereImpl

proc newDebugSphere*(): DebugSphere =
    new(result)
    initMessage(result[])
    result.procs = DebugSphereProcs()
    result.color = nil
    result.p = nil
    result.r = 0

proc clearcolor*(message: DebugSphere) =
    message.color = nil
    clearFields(message, [1])

proc hascolor*(message: DebugSphere): bool =
    result = hasField(message, 1)

proc setcolor*(message: DebugSphere, value: Color) =
    message.color = value
    setField(message, 1)

proc color*(message: DebugSphere): Color {.inline.} =
    message.color

proc `color=`*(message: DebugSphere, value: Color) {.inline.} =
    setcolor(message, value)

proc clearp*(message: DebugSphere) =
    message.p = nil
    clearFields(message, [2])

proc hasp*(message: DebugSphere): bool =
    result = hasField(message, 2)

proc setp*(message: DebugSphere, value: Point) =
    message.p = value
    setField(message, 2)

proc p*(message: DebugSphere): Point {.inline.} =
    message.p

proc `p=`*(message: DebugSphere, value: Point) {.inline.} =
    setp(message, value)

proc clearr*(message: DebugSphere) =
    message.r = 0
    clearFields(message, [3])

proc hasr*(message: DebugSphere): bool =
    result = hasField(message, 3)

proc setr*(message: DebugSphere, value: float32) =
    message.r = value
    setField(message, 3)

proc r*(message: DebugSphere): float32 {.inline.} =
    message.r

proc `r=`*(message: DebugSphere, value: float32) {.inline.} =
    setr(message, value)

proc `$`*(message: DebugSphere): string =
    runnableExamples:
        echo $DebugSphere
        echo fmt"{DebugSphere}"
        echo &"{DebugSphere}"
    var resultSeq: seq[string]
    if message.hascolor:
        resultSeq.add(&"color: {message.color}")
    if message.hasp:
        resultSeq.add(&"p: {message.p}")
    if message.hasr:
        resultSeq.add(&"r: {message.r}")
    result = resultSeq.join(", ")
    result = &"DebugSphere({result})"

proc sizeOfDebugSphere*(message: DebugSphere): uint64 =
    if hascolor(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfColor(message.color))
    if hasp(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint(message.p))
    if hasr(message):
        result = result + sizeOfTag(3, WireType.Fixed32)
        result = result + sizeOfFloat(message.r)
    result = result + sizeOfUnknownFields(message)

proc writeDebugSphere*(stream: Stream, message: DebugSphere) =
    if hascolor(message):
        writeMessage(stream, message.color, 1)
    if hasp(message):
        writeMessage(stream, message.p, 2)
    if hasr(message):
        protoWriteFloat(stream, message.r, 3)
    writeUnknownFields(stream, message)

proc readDebugSphere*(stream: Stream): DebugSphere =
    result = newDebugSphere()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcolor(result, newColor(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setp(result, newPoint(data))
        of 3:
            expectWireType(wireType, WireType.Fixed32)
            setr(result, protoReadFloat(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: DebugSphere): string =
    let
        ss = newStringStream()
    writeDebugSphere(ss, message)
    result = ss.data

proc newDebugSphere*(data: string): DebugSphere =
    let
        ss = newStringStream(data)
    result = readDebugSphere(ss)

proc newDebugSphere*(data: seq[byte]): DebugSphere =
    let
        ss = newStringStream(cast[string](data))
    result = readDebugSphere(ss)


proc fullyQualifiedName*(T: typedesc[DebugKillUnit]): string = "DebugKillUnit"

proc readDebugKillUnitImpl(stream: Stream): Message = readDebugKillUnit(stream)
proc writeDebugKillUnitImpl(stream: Stream, msg: Message) = writeDebugKillUnit(stream, DebugKillUnit(msg))

proc DebugKillUnitProcs*(): MessageProcs =
    result.readImpl = readDebugKillUnitImpl
    result.writeImpl = writeDebugKillUnitImpl

proc newDebugKillUnit*(): DebugKillUnit =
    new(result)
    initMessage(result[])
    result.procs = DebugKillUnitProcs()
    result.tag = @[]

proc cleartag*(message: DebugKillUnit) =
    message.tag = @[]
    clearFields(message, [1])

proc hastag*(message: DebugKillUnit): bool =
    result = hasField(message, 1) or (len(message.tag) > 0)

proc settag*(message: DebugKillUnit, value: seq[uint64]) =
    message.tag = value
    setField(message, 1)

proc addtag*(message: DebugKillUnit, value: uint64) =
    add(message.tag, value)

proc tag*(message: DebugKillUnit): seq[uint64] {.inline.} =
    message.tag

proc `tag=`*(message: DebugKillUnit, value: seq[uint64]) {.inline.} =
    settag(message, value)

proc `$`*(message: DebugKillUnit): string =
    runnableExamples:
        echo $DebugKillUnit
        echo fmt"{DebugKillUnit}"
        echo &"{DebugKillUnit}"
    var resultSeq: seq[string]
    if message.hastag:
        resultSeq.add(&"tag: {message.tag}")
    result = resultSeq.join(", ")
    result = &"DebugKillUnit({result})"

proc sizeOfDebugKillUnit*(message: DebugKillUnit): uint64 =
    if len(message.tag) > 0:
        for value in message.tag:
            result = result + sizeOfTag(1, WireType.Varint)
            result = result + sizeOfUInt64(value)
    result = result + sizeOfUnknownFields(message)

proc writeDebugKillUnit*(stream: Stream, message: DebugKillUnit) =
    for value in message.tag:
        protoWriteUInt64(stream, value, 1)
    writeUnknownFields(stream, message)

proc readDebugKillUnit*(stream: Stream): DebugKillUnit =
    result = newDebugKillUnit()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint, WireType.LengthDelimited)
            if wireType == WireType.LengthDelimited:
                let
                    size = readVarint(stream)
                    start = uint64(getPosition(stream))
                var consumed = 0'u64
                while consumed < size:
                    addtag(result, protoReadUInt64(stream))
                    consumed = uint64(getPosition(stream)) - start
                if consumed != size:
                    raise newException(Exception, "packed field size mismatch")
            else:
                addtag(result, protoReadUInt64(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: DebugKillUnit): string =
    let
        ss = newStringStream()
    writeDebugKillUnit(ss, message)
    result = ss.data

proc newDebugKillUnit*(data: string): DebugKillUnit =
    let
        ss = newStringStream(data)
    result = readDebugKillUnit(ss)

proc newDebugKillUnit*(data: seq[byte]): DebugKillUnit =
    let
        ss = newStringStream(cast[string](data))
    result = readDebugKillUnit(ss)


proc fullyQualifiedName*(T: typedesc[DebugSetScore]): string = "DebugSetScore"

proc readDebugSetScoreImpl(stream: Stream): Message = readDebugSetScore(stream)
proc writeDebugSetScoreImpl(stream: Stream, msg: Message) = writeDebugSetScore(stream, DebugSetScore(msg))

proc DebugSetScoreProcs*(): MessageProcs =
    result.readImpl = readDebugSetScoreImpl
    result.writeImpl = writeDebugSetScoreImpl

proc newDebugSetScore*(): DebugSetScore =
    new(result)
    initMessage(result[])
    result.procs = DebugSetScoreProcs()
    result.score = 0

proc clearscore*(message: DebugSetScore) =
    message.score = 0
    clearFields(message, [1])

proc hasscore*(message: DebugSetScore): bool =
    result = hasField(message, 1)

proc setscore*(message: DebugSetScore, value: float32) =
    message.score = value
    setField(message, 1)

proc score*(message: DebugSetScore): float32 {.inline.} =
    message.score

proc `score=`*(message: DebugSetScore, value: float32) {.inline.} =
    setscore(message, value)

proc `$`*(message: DebugSetScore): string =
    runnableExamples:
        echo $DebugSetScore
        echo fmt"{DebugSetScore}"
        echo &"{DebugSetScore}"
    var resultSeq: seq[string]
    if message.hasscore:
        resultSeq.add(&"score: {message.score}")
    result = resultSeq.join(", ")
    result = &"DebugSetScore({result})"

proc sizeOfDebugSetScore*(message: DebugSetScore): uint64 =
    if hasscore(message):
        result = result + sizeOfTag(1, WireType.Fixed32)
        result = result + sizeOfFloat(message.score)
    result = result + sizeOfUnknownFields(message)

proc writeDebugSetScore*(stream: Stream, message: DebugSetScore) =
    if hasscore(message):
        protoWriteFloat(stream, message.score, 1)
    writeUnknownFields(stream, message)

proc readDebugSetScore*(stream: Stream): DebugSetScore =
    result = newDebugSetScore()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Fixed32)
            setscore(result, protoReadFloat(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: DebugSetScore): string =
    let
        ss = newStringStream()
    writeDebugSetScore(ss, message)
    result = ss.data

proc newDebugSetScore*(data: string): DebugSetScore =
    let
        ss = newStringStream(data)
    result = readDebugSetScore(ss)

proc newDebugSetScore*(data: seq[byte]): DebugSetScore =
    let
        ss = newStringStream(cast[string](data))
    result = readDebugSetScore(ss)


proc fullyQualifiedName*(T: typedesc[DebugSetUnitValue]): string = "DebugSetUnitValue"

proc readDebugSetUnitValueImpl(stream: Stream): Message = readDebugSetUnitValue(stream)
proc writeDebugSetUnitValueImpl(stream: Stream, msg: Message) = writeDebugSetUnitValue(stream, DebugSetUnitValue(msg))

proc DebugSetUnitValueProcs*(): MessageProcs =
    result.readImpl = readDebugSetUnitValueImpl
    result.writeImpl = writeDebugSetUnitValueImpl

proc newDebugSetUnitValue*(): DebugSetUnitValue =
    new(result)
    initMessage(result[])
    result.procs = DebugSetUnitValueProcs()
    result.unitValue = DebugSetUnitValue_UnitValue.Energy
    result.value = 0
    result.unitTag = 0

proc clearunitValue*(message: DebugSetUnitValue) =
    message.unitValue = DebugSetUnitValue_UnitValue.Energy
    clearFields(message, [1])

proc hasunitValue*(message: DebugSetUnitValue): bool =
    result = hasField(message, 1)

proc setunitValue*(message: DebugSetUnitValue, value: DebugSetUnitValue_UnitValue) =
    message.unitValue = value
    setField(message, 1)

proc unitValue*(message: DebugSetUnitValue): DebugSetUnitValue_UnitValue {.inline.} =
    message.unitValue

proc `unitValue=`*(message: DebugSetUnitValue, value: DebugSetUnitValue_UnitValue) {.inline.} =
    setunitValue(message, value)

proc clearvalue*(message: DebugSetUnitValue) =
    message.value = 0
    clearFields(message, [2])

proc hasvalue*(message: DebugSetUnitValue): bool =
    result = hasField(message, 2)

proc setvalue*(message: DebugSetUnitValue, value: float32) =
    message.value = value
    setField(message, 2)

proc value*(message: DebugSetUnitValue): float32 {.inline.} =
    message.value

proc `value=`*(message: DebugSetUnitValue, value: float32) {.inline.} =
    setvalue(message, value)

proc clearunitTag*(message: DebugSetUnitValue) =
    message.unitTag = 0
    clearFields(message, [3])

proc hasunitTag*(message: DebugSetUnitValue): bool =
    result = hasField(message, 3)

proc setunitTag*(message: DebugSetUnitValue, value: uint64) =
    message.unitTag = value
    setField(message, 3)

proc unitTag*(message: DebugSetUnitValue): uint64 {.inline.} =
    message.unitTag

proc `unitTag=`*(message: DebugSetUnitValue, value: uint64) {.inline.} =
    setunitTag(message, value)

proc `$`*(message: DebugSetUnitValue): string =
    runnableExamples:
        echo $DebugSetUnitValue
        echo fmt"{DebugSetUnitValue}"
        echo &"{DebugSetUnitValue}"
    var resultSeq: seq[string]
    if message.hasunitValue:
        resultSeq.add(&"unitValue: {message.unitValue}")
    if message.hasvalue:
        resultSeq.add(&"value: {message.value}")
    if message.hasunitTag:
        resultSeq.add(&"unitTag: {message.unitTag}")
    result = resultSeq.join(", ")
    result = &"DebugSetUnitValue({result})"

proc sizeOfDebugSetUnitValue*(message: DebugSetUnitValue): uint64 =
    if hasunitValue(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfEnum[DebugSetUnitValue_UnitValue](message.unitValue)
    if hasvalue(message):
        result = result + sizeOfTag(2, WireType.Fixed32)
        result = result + sizeOfFloat(message.value)
    if hasunitTag(message):
        result = result + sizeOfTag(3, WireType.Varint)
        result = result + sizeOfUInt64(message.unitTag)
    result = result + sizeOfUnknownFields(message)

proc writeDebugSetUnitValue*(stream: Stream, message: DebugSetUnitValue) =
    if hasunitValue(message):
        protoWriteEnum(stream, message.unitValue, 1)
    if hasvalue(message):
        protoWriteFloat(stream, message.value, 2)
    if hasunitTag(message):
        protoWriteUInt64(stream, message.unitTag, 3)
    writeUnknownFields(stream, message)

proc readDebugSetUnitValue*(stream: Stream): DebugSetUnitValue =
    result = newDebugSetUnitValue()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setunitValue(result, protoReadEnum[DebugSetUnitValue_UnitValue](stream))
        of 2:
            expectWireType(wireType, WireType.Fixed32)
            setvalue(result, protoReadFloat(stream))
        of 3:
            expectWireType(wireType, WireType.Varint)
            setunitTag(result, protoReadUInt64(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: DebugSetUnitValue): string =
    let
        ss = newStringStream()
    writeDebugSetUnitValue(ss, message)
    result = ss.data

proc newDebugSetUnitValue*(data: string): DebugSetUnitValue =
    let
        ss = newStringStream(data)
    result = readDebugSetUnitValue(ss)

proc newDebugSetUnitValue*(data: seq[byte]): DebugSetUnitValue =
    let
        ss = newStringStream(cast[string](data))
    result = readDebugSetUnitValue(ss)


proc fullyQualifiedName*(T: typedesc[DebugEndGame]): string = "DebugEndGame"

proc readDebugEndGameImpl(stream: Stream): Message = readDebugEndGame(stream)
proc writeDebugEndGameImpl(stream: Stream, msg: Message) = writeDebugEndGame(stream, DebugEndGame(msg))

proc DebugEndGameProcs*(): MessageProcs =
    result.readImpl = readDebugEndGameImpl
    result.writeImpl = writeDebugEndGameImpl

proc newDebugEndGame*(): DebugEndGame =
    new(result)
    initMessage(result[])
    result.procs = DebugEndGameProcs()
    result.endResult = DebugEndGame_EndResult.Surrender

proc clearendResult*(message: DebugEndGame) =
    message.endResult = DebugEndGame_EndResult.Surrender
    clearFields(message, [1])

proc hasendResult*(message: DebugEndGame): bool =
    result = hasField(message, 1)

proc setendResult*(message: DebugEndGame, value: DebugEndGame_EndResult) =
    message.endResult = value
    setField(message, 1)

proc endResult*(message: DebugEndGame): DebugEndGame_EndResult {.inline.} =
    message.endResult

proc `endResult=`*(message: DebugEndGame, value: DebugEndGame_EndResult) {.inline.} =
    setendResult(message, value)

proc `$`*(message: DebugEndGame): string =
    runnableExamples:
        echo $DebugEndGame
        echo fmt"{DebugEndGame}"
        echo &"{DebugEndGame}"
    var resultSeq: seq[string]
    if message.hasendResult:
        resultSeq.add(&"endResult: {message.endResult}")
    result = resultSeq.join(", ")
    result = &"DebugEndGame({result})"

proc sizeOfDebugEndGame*(message: DebugEndGame): uint64 =
    if hasendResult(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfEnum[DebugEndGame_EndResult](message.endResult)
    result = result + sizeOfUnknownFields(message)

proc writeDebugEndGame*(stream: Stream, message: DebugEndGame) =
    if hasendResult(message):
        protoWriteEnum(stream, message.endResult, 1)
    writeUnknownFields(stream, message)

proc readDebugEndGame*(stream: Stream): DebugEndGame =
    result = newDebugEndGame()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setendResult(result, protoReadEnum[DebugEndGame_EndResult](stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: DebugEndGame): string =
    let
        ss = newStringStream()
    writeDebugEndGame(ss, message)
    result = ss.data

proc newDebugEndGame*(data: string): DebugEndGame =
    let
        ss = newStringStream(data)
    result = readDebugEndGame(ss)

proc newDebugEndGame*(data: seq[byte]): DebugEndGame =
    let
        ss = newStringStream(cast[string](data))
    result = readDebugEndGame(ss)


proc fullyQualifiedName*(T: typedesc[DebugBox]): string = "DebugBox"

proc readDebugBoxImpl(stream: Stream): Message = readDebugBox(stream)
proc writeDebugBoxImpl(stream: Stream, msg: Message) = writeDebugBox(stream, DebugBox(msg))

proc DebugBoxProcs*(): MessageProcs =
    result.readImpl = readDebugBoxImpl
    result.writeImpl = writeDebugBoxImpl

proc newDebugBox*(): DebugBox =
    new(result)
    initMessage(result[])
    result.procs = DebugBoxProcs()
    result.color = nil
    result.min = nil
    result.max = nil

proc clearcolor*(message: DebugBox) =
    message.color = nil
    clearFields(message, [1])

proc hascolor*(message: DebugBox): bool =
    result = hasField(message, 1)

proc setcolor*(message: DebugBox, value: Color) =
    message.color = value
    setField(message, 1)

proc color*(message: DebugBox): Color {.inline.} =
    message.color

proc `color=`*(message: DebugBox, value: Color) {.inline.} =
    setcolor(message, value)

proc clearmin*(message: DebugBox) =
    message.min = nil
    clearFields(message, [2])

proc hasmin*(message: DebugBox): bool =
    result = hasField(message, 2)

proc setmin*(message: DebugBox, value: Point) =
    message.min = value
    setField(message, 2)

proc min*(message: DebugBox): Point {.inline.} =
    message.min

proc `min=`*(message: DebugBox, value: Point) {.inline.} =
    setmin(message, value)

proc clearmax*(message: DebugBox) =
    message.max = nil
    clearFields(message, [3])

proc hasmax*(message: DebugBox): bool =
    result = hasField(message, 3)

proc setmax*(message: DebugBox, value: Point) =
    message.max = value
    setField(message, 3)

proc max*(message: DebugBox): Point {.inline.} =
    message.max

proc `max=`*(message: DebugBox, value: Point) {.inline.} =
    setmax(message, value)

proc `$`*(message: DebugBox): string =
    runnableExamples:
        echo $DebugBox
        echo fmt"{DebugBox}"
        echo &"{DebugBox}"
    var resultSeq: seq[string]
    if message.hascolor:
        resultSeq.add(&"color: {message.color}")
    if message.hasmin:
        resultSeq.add(&"min: {message.min}")
    if message.hasmax:
        resultSeq.add(&"max: {message.max}")
    result = resultSeq.join(", ")
    result = &"DebugBox({result})"

proc sizeOfDebugBox*(message: DebugBox): uint64 =
    if hascolor(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfColor(message.color))
    if hasmin(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint(message.min))
    if hasmax(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint(message.max))
    result = result + sizeOfUnknownFields(message)

proc writeDebugBox*(stream: Stream, message: DebugBox) =
    if hascolor(message):
        writeMessage(stream, message.color, 1)
    if hasmin(message):
        writeMessage(stream, message.min, 2)
    if hasmax(message):
        writeMessage(stream, message.max, 3)
    writeUnknownFields(stream, message)

proc readDebugBox*(stream: Stream): DebugBox =
    result = newDebugBox()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcolor(result, newColor(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setmin(result, newPoint(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setmax(result, newPoint(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: DebugBox): string =
    let
        ss = newStringStream()
    writeDebugBox(ss, message)
    result = ss.data

proc newDebugBox*(data: string): DebugBox =
    let
        ss = newStringStream(data)
    result = readDebugBox(ss)

proc newDebugBox*(data: seq[byte]): DebugBox =
    let
        ss = newStringStream(cast[string](data))
    result = readDebugBox(ss)


proc fullyQualifiedName*(T: typedesc[DebugText]): string = "DebugText"

proc readDebugTextImpl(stream: Stream): Message = readDebugText(stream)
proc writeDebugTextImpl(stream: Stream, msg: Message) = writeDebugText(stream, DebugText(msg))

proc DebugTextProcs*(): MessageProcs =
    result.readImpl = readDebugTextImpl
    result.writeImpl = writeDebugTextImpl

proc newDebugText*(): DebugText =
    new(result)
    initMessage(result[])
    result.procs = DebugTextProcs()
    result.color = nil
    result.text = ""
    result.virtualPos = nil
    result.worldPos = nil
    result.size = 0

proc clearcolor*(message: DebugText) =
    message.color = nil
    clearFields(message, [1])

proc hascolor*(message: DebugText): bool =
    result = hasField(message, 1)

proc setcolor*(message: DebugText, value: Color) =
    message.color = value
    setField(message, 1)

proc color*(message: DebugText): Color {.inline.} =
    message.color

proc `color=`*(message: DebugText, value: Color) {.inline.} =
    setcolor(message, value)

proc cleartext*(message: DebugText) =
    message.text = ""
    clearFields(message, [2])

proc hastext*(message: DebugText): bool =
    result = hasField(message, 2)

proc settext*(message: DebugText, value: string) =
    message.text = value
    setField(message, 2)

proc text*(message: DebugText): string {.inline.} =
    message.text

proc `text=`*(message: DebugText, value: string) {.inline.} =
    settext(message, value)

proc clearvirtualPos*(message: DebugText) =
    message.virtualPos = nil
    clearFields(message, [3])

proc hasvirtualPos*(message: DebugText): bool =
    result = hasField(message, 3)

proc setvirtualPos*(message: DebugText, value: Point) =
    message.virtualPos = value
    setField(message, 3)

proc virtualPos*(message: DebugText): Point {.inline.} =
    message.virtualPos

proc `virtualPos=`*(message: DebugText, value: Point) {.inline.} =
    setvirtualPos(message, value)

proc clearworldPos*(message: DebugText) =
    message.worldPos = nil
    clearFields(message, [4])

proc hasworldPos*(message: DebugText): bool =
    result = hasField(message, 4)

proc setworldPos*(message: DebugText, value: Point) =
    message.worldPos = value
    setField(message, 4)

proc worldPos*(message: DebugText): Point {.inline.} =
    message.worldPos

proc `worldPos=`*(message: DebugText, value: Point) {.inline.} =
    setworldPos(message, value)

proc clearsize*(message: DebugText) =
    message.size = 0
    clearFields(message, [5])

proc hassize*(message: DebugText): bool =
    result = hasField(message, 5)

proc setsize*(message: DebugText, value: uint32) =
    message.size = value
    setField(message, 5)

proc size*(message: DebugText): uint32 {.inline.} =
    message.size

proc `size=`*(message: DebugText, value: uint32) {.inline.} =
    setsize(message, value)

proc `$`*(message: DebugText): string =
    runnableExamples:
        echo $DebugText
        echo fmt"{DebugText}"
        echo &"{DebugText}"
    var resultSeq: seq[string]
    if message.hascolor:
        resultSeq.add(&"color: {message.color}")
    if message.hastext:
        resultSeq.add(&"text: {message.text}")
    if message.hasvirtualPos:
        resultSeq.add(&"virtualPos: {message.virtualPos}")
    if message.hasworldPos:
        resultSeq.add(&"worldPos: {message.worldPos}")
    if message.hassize:
        resultSeq.add(&"size: {message.size}")
    result = resultSeq.join(", ")
    result = &"DebugText({result})"

proc sizeOfDebugText*(message: DebugText): uint64 =
    if hascolor(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfColor(message.color))
    if hastext(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfString(message.text)
    if hasvirtualPos(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint(message.virtualPos))
    if hasworldPos(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint(message.worldPos))
    if hassize(message):
        result = result + sizeOfTag(5, WireType.Varint)
        result = result + sizeOfUInt32(message.size)
    result = result + sizeOfUnknownFields(message)

proc writeDebugText*(stream: Stream, message: DebugText) =
    if hascolor(message):
        writeMessage(stream, message.color, 1)
    if hastext(message):
        protoWriteString(stream, message.text, 2)
    if hasvirtualPos(message):
        writeMessage(stream, message.virtualPos, 3)
    if hasworldPos(message):
        writeMessage(stream, message.worldPos, 4)
    if hassize(message):
        protoWriteUInt32(stream, message.size, 5)
    writeUnknownFields(stream, message)

proc readDebugText*(stream: Stream): DebugText =
    result = newDebugText()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcolor(result, newColor(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            settext(result, protoReadString(stream))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setvirtualPos(result, newPoint(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setworldPos(result, newPoint(data))
        of 5:
            expectWireType(wireType, WireType.Varint)
            setsize(result, protoReadUInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: DebugText): string =
    let
        ss = newStringStream()
    writeDebugText(ss, message)
    result = ss.data

proc newDebugText*(data: string): DebugText =
    let
        ss = newStringStream(data)
    result = readDebugText(ss)

proc newDebugText*(data: seq[byte]): DebugText =
    let
        ss = newStringStream(cast[string](data))
    result = readDebugText(ss)


proc fullyQualifiedName*(T: typedesc[Line]): string = "Line"

proc readLineImpl(stream: Stream): Message = readLine(stream)
proc writeLineImpl(stream: Stream, msg: Message) = writeLine(stream, Line(msg))

proc LineProcs*(): MessageProcs =
    result.readImpl = readLineImpl
    result.writeImpl = writeLineImpl

proc newLine*(): Line =
    new(result)
    initMessage(result[])
    result.procs = LineProcs()
    result.p0 = nil
    result.p1 = nil

proc clearp0*(message: Line) =
    message.p0 = nil
    clearFields(message, [1])

proc hasp0*(message: Line): bool =
    result = hasField(message, 1)

proc setp0*(message: Line, value: Point) =
    message.p0 = value
    setField(message, 1)

proc p0*(message: Line): Point {.inline.} =
    message.p0

proc `p0=`*(message: Line, value: Point) {.inline.} =
    setp0(message, value)

proc clearp1*(message: Line) =
    message.p1 = nil
    clearFields(message, [2])

proc hasp1*(message: Line): bool =
    result = hasField(message, 2)

proc setp1*(message: Line, value: Point) =
    message.p1 = value
    setField(message, 2)

proc p1*(message: Line): Point {.inline.} =
    message.p1

proc `p1=`*(message: Line, value: Point) {.inline.} =
    setp1(message, value)

proc `$`*(message: Line): string =
    runnableExamples:
        echo $Line
        echo fmt"{Line}"
        echo &"{Line}"
    var resultSeq: seq[string]
    if message.hasp0:
        resultSeq.add(&"p0: {message.p0}")
    if message.hasp1:
        resultSeq.add(&"p1: {message.p1}")
    result = resultSeq.join(", ")
    result = &"Line({result})"

proc sizeOfLine*(message: Line): uint64 =
    if hasp0(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint(message.p0))
    if hasp1(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint(message.p1))
    result = result + sizeOfUnknownFields(message)

proc writeLine*(stream: Stream, message: Line) =
    if hasp0(message):
        writeMessage(stream, message.p0, 1)
    if hasp1(message):
        writeMessage(stream, message.p1, 2)
    writeUnknownFields(stream, message)

proc readLine*(stream: Stream): Line =
    result = newLine()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setp0(result, newPoint(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setp1(result, newPoint(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: Line): string =
    let
        ss = newStringStream()
    writeLine(ss, message)
    result = ss.data

proc newLine*(data: string): Line =
    let
        ss = newStringStream(data)
    result = readLine(ss)

proc newLine*(data: seq[byte]): Line =
    let
        ss = newStringStream(cast[string](data))
    result = readLine(ss)


proc fullyQualifiedName*(T: typedesc[DebugLine]): string = "DebugLine"

proc readDebugLineImpl(stream: Stream): Message = readDebugLine(stream)
proc writeDebugLineImpl(stream: Stream, msg: Message) = writeDebugLine(stream, DebugLine(msg))

proc DebugLineProcs*(): MessageProcs =
    result.readImpl = readDebugLineImpl
    result.writeImpl = writeDebugLineImpl

proc newDebugLine*(): DebugLine =
    new(result)
    initMessage(result[])
    result.procs = DebugLineProcs()
    result.color = nil
    result.line = nil

proc clearcolor*(message: DebugLine) =
    message.color = nil
    clearFields(message, [1])

proc hascolor*(message: DebugLine): bool =
    result = hasField(message, 1)

proc setcolor*(message: DebugLine, value: Color) =
    message.color = value
    setField(message, 1)

proc color*(message: DebugLine): Color {.inline.} =
    message.color

proc `color=`*(message: DebugLine, value: Color) {.inline.} =
    setcolor(message, value)

proc clearline*(message: DebugLine) =
    message.line = nil
    clearFields(message, [2])

proc hasline*(message: DebugLine): bool =
    result = hasField(message, 2)

proc setline*(message: DebugLine, value: Line) =
    message.line = value
    setField(message, 2)

proc line*(message: DebugLine): Line {.inline.} =
    message.line

proc `line=`*(message: DebugLine, value: Line) {.inline.} =
    setline(message, value)

proc `$`*(message: DebugLine): string =
    runnableExamples:
        echo $DebugLine
        echo fmt"{DebugLine}"
        echo &"{DebugLine}"
    var resultSeq: seq[string]
    if message.hascolor:
        resultSeq.add(&"color: {message.color}")
    if message.hasline:
        resultSeq.add(&"line: {message.line}")
    result = resultSeq.join(", ")
    result = &"DebugLine({result})"

proc sizeOfDebugLine*(message: DebugLine): uint64 =
    if hascolor(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfColor(message.color))
    if hasline(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfLine(message.line))
    result = result + sizeOfUnknownFields(message)

proc writeDebugLine*(stream: Stream, message: DebugLine) =
    if hascolor(message):
        writeMessage(stream, message.color, 1)
    if hasline(message):
        writeMessage(stream, message.line, 2)
    writeUnknownFields(stream, message)

proc readDebugLine*(stream: Stream): DebugLine =
    result = newDebugLine()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcolor(result, newColor(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setline(result, newLine(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: DebugLine): string =
    let
        ss = newStringStream()
    writeDebugLine(ss, message)
    result = ss.data

proc newDebugLine*(data: string): DebugLine =
    let
        ss = newStringStream(data)
    result = readDebugLine(ss)

proc newDebugLine*(data: seq[byte]): DebugLine =
    let
        ss = newStringStream(cast[string](data))
    result = readDebugLine(ss)


proc fullyQualifiedName*(T: typedesc[DebugDraw]): string = "DebugDraw"

proc readDebugDrawImpl(stream: Stream): Message = readDebugDraw(stream)
proc writeDebugDrawImpl(stream: Stream, msg: Message) = writeDebugDraw(stream, DebugDraw(msg))

proc DebugDrawProcs*(): MessageProcs =
    result.readImpl = readDebugDrawImpl
    result.writeImpl = writeDebugDrawImpl

proc newDebugDraw*(): DebugDraw =
    new(result)
    initMessage(result[])
    result.procs = DebugDrawProcs()
    result.text = @[]
    result.lines = @[]
    result.boxes = @[]
    result.spheres = @[]

proc cleartext*(message: DebugDraw) =
    message.text = @[]
    clearFields(message, [1])

proc hastext*(message: DebugDraw): bool =
    result = hasField(message, 1) or (len(message.text) > 0)

proc settext*(message: DebugDraw, value: seq[DebugText]) =
    message.text = value
    setField(message, 1)

proc addtext*(message: DebugDraw, value: DebugText) =
    add(message.text, value)

proc text*(message: DebugDraw): seq[DebugText] {.inline.} =
    message.text

proc `text=`*(message: DebugDraw, value: seq[DebugText]) {.inline.} =
    settext(message, value)

proc clearlines*(message: DebugDraw) =
    message.lines = @[]
    clearFields(message, [2])

proc haslines*(message: DebugDraw): bool =
    result = hasField(message, 2) or (len(message.lines) > 0)

proc setlines*(message: DebugDraw, value: seq[DebugLine]) =
    message.lines = value
    setField(message, 2)

proc addlines*(message: DebugDraw, value: DebugLine) =
    add(message.lines, value)

proc lines*(message: DebugDraw): seq[DebugLine] {.inline.} =
    message.lines

proc `lines=`*(message: DebugDraw, value: seq[DebugLine]) {.inline.} =
    setlines(message, value)

proc clearboxes*(message: DebugDraw) =
    message.boxes = @[]
    clearFields(message, [3])

proc hasboxes*(message: DebugDraw): bool =
    result = hasField(message, 3) or (len(message.boxes) > 0)

proc setboxes*(message: DebugDraw, value: seq[DebugBox]) =
    message.boxes = value
    setField(message, 3)

proc addboxes*(message: DebugDraw, value: DebugBox) =
    add(message.boxes, value)

proc boxes*(message: DebugDraw): seq[DebugBox] {.inline.} =
    message.boxes

proc `boxes=`*(message: DebugDraw, value: seq[DebugBox]) {.inline.} =
    setboxes(message, value)

proc clearspheres*(message: DebugDraw) =
    message.spheres = @[]
    clearFields(message, [4])

proc hasspheres*(message: DebugDraw): bool =
    result = hasField(message, 4) or (len(message.spheres) > 0)

proc setspheres*(message: DebugDraw, value: seq[DebugSphere]) =
    message.spheres = value
    setField(message, 4)

proc addspheres*(message: DebugDraw, value: DebugSphere) =
    add(message.spheres, value)

proc spheres*(message: DebugDraw): seq[DebugSphere] {.inline.} =
    message.spheres

proc `spheres=`*(message: DebugDraw, value: seq[DebugSphere]) {.inline.} =
    setspheres(message, value)

proc `$`*(message: DebugDraw): string =
    runnableExamples:
        echo $DebugDraw
        echo fmt"{DebugDraw}"
        echo &"{DebugDraw}"
    var resultSeq: seq[string]
    if message.hastext:
        resultSeq.add(&"text: {message.text}")
    if message.haslines:
        resultSeq.add(&"lines: {message.lines}")
    if message.hasboxes:
        resultSeq.add(&"boxes: {message.boxes}")
    if message.hasspheres:
        resultSeq.add(&"spheres: {message.spheres}")
    result = resultSeq.join(", ")
    result = &"DebugDraw({result})"

proc sizeOfDebugDraw*(message: DebugDraw): uint64 =
    for value in message.text:
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfDebugText(value))
    for value in message.lines:
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfDebugLine(value))
    for value in message.boxes:
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfDebugBox(value))
    for value in message.spheres:
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfDebugSphere(value))
    result = result + sizeOfUnknownFields(message)

proc writeDebugDraw*(stream: Stream, message: DebugDraw) =
    for value in message.text:
        writeMessage(stream, value, 1)
    for value in message.lines:
        writeMessage(stream, value, 2)
    for value in message.boxes:
        writeMessage(stream, value, 3)
    for value in message.spheres:
        writeMessage(stream, value, 4)
    writeUnknownFields(stream, message)

proc readDebugDraw*(stream: Stream): DebugDraw =
    result = newDebugDraw()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addtext(result, newDebugText(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addlines(result, newDebugLine(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addboxes(result, newDebugBox(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            addspheres(result, newDebugSphere(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: DebugDraw): string =
    let
        ss = newStringStream()
    writeDebugDraw(ss, message)
    result = ss.data

proc newDebugDraw*(data: string): DebugDraw =
    let
        ss = newStringStream(data)
    result = readDebugDraw(ss)

proc newDebugDraw*(data: seq[byte]): DebugDraw =
    let
        ss = newStringStream(cast[string](data))
    result = readDebugDraw(ss)


proc fullyQualifiedName*(T: typedesc[DebugCreateUnit]): string = "DebugCreateUnit"

proc readDebugCreateUnitImpl(stream: Stream): Message = readDebugCreateUnit(stream)
proc writeDebugCreateUnitImpl(stream: Stream, msg: Message) = writeDebugCreateUnit(stream, DebugCreateUnit(msg))

proc DebugCreateUnitProcs*(): MessageProcs =
    result.readImpl = readDebugCreateUnitImpl
    result.writeImpl = writeDebugCreateUnitImpl

proc newDebugCreateUnit*(): DebugCreateUnit =
    new(result)
    initMessage(result[])
    result.procs = DebugCreateUnitProcs()
    result.unitType = 0
    result.owner = 0
    result.pos = nil
    result.quantity = 0

proc clearunitType*(message: DebugCreateUnit) =
    message.unitType = 0
    clearFields(message, [1])

proc hasunitType*(message: DebugCreateUnit): bool =
    result = hasField(message, 1)

proc setunitType*(message: DebugCreateUnit, value: uint32) =
    message.unitType = value
    setField(message, 1)

proc unitType*(message: DebugCreateUnit): uint32 {.inline.} =
    message.unitType

proc `unitType=`*(message: DebugCreateUnit, value: uint32) {.inline.} =
    setunitType(message, value)

proc clearowner*(message: DebugCreateUnit) =
    message.owner = 0
    clearFields(message, [2])

proc hasowner*(message: DebugCreateUnit): bool =
    result = hasField(message, 2)

proc setowner*(message: DebugCreateUnit, value: int32) =
    message.owner = value
    setField(message, 2)

proc owner*(message: DebugCreateUnit): int32 {.inline.} =
    message.owner

proc `owner=`*(message: DebugCreateUnit, value: int32) {.inline.} =
    setowner(message, value)

proc clearpos*(message: DebugCreateUnit) =
    message.pos = nil
    clearFields(message, [3])

proc haspos*(message: DebugCreateUnit): bool =
    result = hasField(message, 3)

proc setpos*(message: DebugCreateUnit, value: Point2D) =
    message.pos = value
    setField(message, 3)

proc pos*(message: DebugCreateUnit): Point2D {.inline.} =
    message.pos

proc `pos=`*(message: DebugCreateUnit, value: Point2D) {.inline.} =
    setpos(message, value)

proc clearquantity*(message: DebugCreateUnit) =
    message.quantity = 0
    clearFields(message, [4])

proc hasquantity*(message: DebugCreateUnit): bool =
    result = hasField(message, 4)

proc setquantity*(message: DebugCreateUnit, value: uint32) =
    message.quantity = value
    setField(message, 4)

proc quantity*(message: DebugCreateUnit): uint32 {.inline.} =
    message.quantity

proc `quantity=`*(message: DebugCreateUnit, value: uint32) {.inline.} =
    setquantity(message, value)

proc `$`*(message: DebugCreateUnit): string =
    runnableExamples:
        echo $DebugCreateUnit
        echo fmt"{DebugCreateUnit}"
        echo &"{DebugCreateUnit}"
    var resultSeq: seq[string]
    if message.hasunitType:
        resultSeq.add(&"unitType: {message.unitType}")
    if message.hasowner:
        resultSeq.add(&"owner: {message.owner}")
    if message.haspos:
        resultSeq.add(&"pos: {message.pos}")
    if message.hasquantity:
        resultSeq.add(&"quantity: {message.quantity}")
    result = resultSeq.join(", ")
    result = &"DebugCreateUnit({result})"

proc sizeOfDebugCreateUnit*(message: DebugCreateUnit): uint64 =
    if hasunitType(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfUInt32(message.unitType)
    if hasowner(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfInt32(message.owner)
    if haspos(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPoint2D(message.pos))
    if hasquantity(message):
        result = result + sizeOfTag(4, WireType.Varint)
        result = result + sizeOfUInt32(message.quantity)
    result = result + sizeOfUnknownFields(message)

proc writeDebugCreateUnit*(stream: Stream, message: DebugCreateUnit) =
    if hasunitType(message):
        protoWriteUInt32(stream, message.unitType, 1)
    if hasowner(message):
        protoWriteInt32(stream, message.owner, 2)
    if haspos(message):
        writeMessage(stream, message.pos, 3)
    if hasquantity(message):
        protoWriteUInt32(stream, message.quantity, 4)
    writeUnknownFields(stream, message)

proc readDebugCreateUnit*(stream: Stream): DebugCreateUnit =
    result = newDebugCreateUnit()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setunitType(result, protoReadUInt32(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setowner(result, protoReadInt32(stream))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setpos(result, newPoint2D(data))
        of 4:
            expectWireType(wireType, WireType.Varint)
            setquantity(result, protoReadUInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: DebugCreateUnit): string =
    let
        ss = newStringStream()
    writeDebugCreateUnit(ss, message)
    result = ss.data

proc newDebugCreateUnit*(data: string): DebugCreateUnit =
    let
        ss = newStringStream(data)
    result = readDebugCreateUnit(ss)

proc newDebugCreateUnit*(data: seq[byte]): DebugCreateUnit =
    let
        ss = newStringStream(cast[string](data))
    result = readDebugCreateUnit(ss)


proc fullyQualifiedName*(T: typedesc[DebugTestProcess]): string = "DebugTestProcess"

proc readDebugTestProcessImpl(stream: Stream): Message = readDebugTestProcess(stream)
proc writeDebugTestProcessImpl(stream: Stream, msg: Message) = writeDebugTestProcess(stream, DebugTestProcess(msg))

proc DebugTestProcessProcs*(): MessageProcs =
    result.readImpl = readDebugTestProcessImpl
    result.writeImpl = writeDebugTestProcessImpl

proc newDebugTestProcess*(): DebugTestProcess =
    new(result)
    initMessage(result[])
    result.procs = DebugTestProcessProcs()
    result.test = DebugTestProcess_Test.hang
    result.delayMs = 0

proc cleartest*(message: DebugTestProcess) =
    message.test = DebugTestProcess_Test.hang
    clearFields(message, [1])

proc hastest*(message: DebugTestProcess): bool =
    result = hasField(message, 1)

proc settest*(message: DebugTestProcess, value: DebugTestProcess_Test) =
    message.test = value
    setField(message, 1)

proc test*(message: DebugTestProcess): DebugTestProcess_Test {.inline.} =
    message.test

proc `test=`*(message: DebugTestProcess, value: DebugTestProcess_Test) {.inline.} =
    settest(message, value)

proc cleardelayMs*(message: DebugTestProcess) =
    message.delayMs = 0
    clearFields(message, [2])

proc hasdelayMs*(message: DebugTestProcess): bool =
    result = hasField(message, 2)

proc setdelayMs*(message: DebugTestProcess, value: int32) =
    message.delayMs = value
    setField(message, 2)

proc delayMs*(message: DebugTestProcess): int32 {.inline.} =
    message.delayMs

proc `delayMs=`*(message: DebugTestProcess, value: int32) {.inline.} =
    setdelayMs(message, value)

proc `$`*(message: DebugTestProcess): string =
    runnableExamples:
        echo $DebugTestProcess
        echo fmt"{DebugTestProcess}"
        echo &"{DebugTestProcess}"
    var resultSeq: seq[string]
    if message.hastest:
        resultSeq.add(&"test: {message.test}")
    if message.hasdelayMs:
        resultSeq.add(&"delayMs: {message.delayMs}")
    result = resultSeq.join(", ")
    result = &"DebugTestProcess({result})"

proc sizeOfDebugTestProcess*(message: DebugTestProcess): uint64 =
    if hastest(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfEnum[DebugTestProcess_Test](message.test)
    if hasdelayMs(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfInt32(message.delayMs)
    result = result + sizeOfUnknownFields(message)

proc writeDebugTestProcess*(stream: Stream, message: DebugTestProcess) =
    if hastest(message):
        protoWriteEnum(stream, message.test, 1)
    if hasdelayMs(message):
        protoWriteInt32(stream, message.delayMs, 2)
    writeUnknownFields(stream, message)

proc readDebugTestProcess*(stream: Stream): DebugTestProcess =
    result = newDebugTestProcess()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            settest(result, protoReadEnum[DebugTestProcess_Test](stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setdelayMs(result, protoReadInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: DebugTestProcess): string =
    let
        ss = newStringStream()
    writeDebugTestProcess(ss, message)
    result = ss.data

proc newDebugTestProcess*(data: string): DebugTestProcess =
    let
        ss = newStringStream(data)
    result = readDebugTestProcess(ss)

proc newDebugTestProcess*(data: seq[byte]): DebugTestProcess =
    let
        ss = newStringStream(cast[string](data))
    result = readDebugTestProcess(ss)


proc fullyQualifiedName*(T: typedesc[DebugCommand]): string = "DebugCommand"

proc readDebugCommandImpl(stream: Stream): Message = readDebugCommand(stream)
proc writeDebugCommandImpl(stream: Stream, msg: Message) = writeDebugCommand(stream, DebugCommand(msg))

proc DebugCommandProcs*(): MessageProcs =
    result.readImpl = readDebugCommandImpl
    result.writeImpl = writeDebugCommandImpl

proc newDebugCommand*(): DebugCommand =
    new(result)
    initMessage(result[])
    result.procs = DebugCommandProcs()
    result.command = DebugCommand_command_OneOf(kind: DebugCommand_command_Kind.NotSet)

proc cleardraw*(message: DebugCommand) =
    reset(message.command)
    message.command.kind = DebugCommand_command_Kind.NotSet
    clearFields(message, [1, 2, 3, 4, 5, 6, 7, 8])

proc hasdraw*(message: DebugCommand): bool =
    result = hasField(message, 1)

proc setdraw*(message: DebugCommand, value: DebugDraw) =
    if message.command.kind != DebugCommand_command_Kind.Draw:
        message.command = DebugCommand_command_OneOf(kind: DebugCommand_command_Kind.Draw, draw: value)
    else:
        message.command.draw = value
    setField(message, 1)
    clearFields(message, [2, 3, 4, 5, 6, 7, 8])

proc draw*(message: DebugCommand): DebugDraw {.inline.} =
    message.command.draw

proc `draw=`*(message: DebugCommand, value: DebugDraw) {.inline.} =
    setdraw(message, value)

proc cleargameState*(message: DebugCommand) =
    reset(message.command)
    message.command.kind = DebugCommand_command_Kind.NotSet
    clearFields(message, [2, 1, 3, 4, 5, 6, 7, 8])

proc hasgameState*(message: DebugCommand): bool =
    result = hasField(message, 2)

proc setgameState*(message: DebugCommand, value: DebugGameState) =
    if message.command.kind != DebugCommand_command_Kind.GameState:
        message.command = DebugCommand_command_OneOf(kind: DebugCommand_command_Kind.GameState, gameState: value)
    else:
        message.command.gameState = value
    setField(message, 2)
    clearFields(message, [1, 3, 4, 5, 6, 7, 8])

proc gameState*(message: DebugCommand): DebugGameState {.inline.} =
    message.command.gameState

proc `gameState=`*(message: DebugCommand, value: DebugGameState) {.inline.} =
    setgameState(message, value)

proc clearcreateUnit*(message: DebugCommand) =
    reset(message.command)
    message.command.kind = DebugCommand_command_Kind.NotSet
    clearFields(message, [3, 1, 2, 4, 5, 6, 7, 8])

proc hascreateUnit*(message: DebugCommand): bool =
    result = hasField(message, 3)

proc setcreateUnit*(message: DebugCommand, value: DebugCreateUnit) =
    if message.command.kind != DebugCommand_command_Kind.CreateUnit:
        message.command = DebugCommand_command_OneOf(kind: DebugCommand_command_Kind.CreateUnit, createUnit: value)
    else:
        message.command.createUnit = value
    setField(message, 3)
    clearFields(message, [1, 2, 4, 5, 6, 7, 8])

proc createUnit*(message: DebugCommand): DebugCreateUnit {.inline.} =
    message.command.createUnit

proc `createUnit=`*(message: DebugCommand, value: DebugCreateUnit) {.inline.} =
    setcreateUnit(message, value)

proc clearkillUnit*(message: DebugCommand) =
    reset(message.command)
    message.command.kind = DebugCommand_command_Kind.NotSet
    clearFields(message, [4, 1, 2, 3, 5, 6, 7, 8])

proc haskillUnit*(message: DebugCommand): bool =
    result = hasField(message, 4)

proc setkillUnit*(message: DebugCommand, value: DebugKillUnit) =
    if message.command.kind != DebugCommand_command_Kind.KillUnit:
        message.command = DebugCommand_command_OneOf(kind: DebugCommand_command_Kind.KillUnit, killUnit: value)
    else:
        message.command.killUnit = value
    setField(message, 4)
    clearFields(message, [1, 2, 3, 5, 6, 7, 8])

proc killUnit*(message: DebugCommand): DebugKillUnit {.inline.} =
    message.command.killUnit

proc `killUnit=`*(message: DebugCommand, value: DebugKillUnit) {.inline.} =
    setkillUnit(message, value)

proc cleartestProcess*(message: DebugCommand) =
    reset(message.command)
    message.command.kind = DebugCommand_command_Kind.NotSet
    clearFields(message, [5, 1, 2, 3, 4, 6, 7, 8])

proc hastestProcess*(message: DebugCommand): bool =
    result = hasField(message, 5)

proc settestProcess*(message: DebugCommand, value: DebugTestProcess) =
    if message.command.kind != DebugCommand_command_Kind.TestProcess:
        message.command = DebugCommand_command_OneOf(kind: DebugCommand_command_Kind.TestProcess, testProcess: value)
    else:
        message.command.testProcess = value
    setField(message, 5)
    clearFields(message, [1, 2, 3, 4, 6, 7, 8])

proc testProcess*(message: DebugCommand): DebugTestProcess {.inline.} =
    message.command.testProcess

proc `testProcess=`*(message: DebugCommand, value: DebugTestProcess) {.inline.} =
    settestProcess(message, value)

proc clearscore*(message: DebugCommand) =
    reset(message.command)
    message.command.kind = DebugCommand_command_Kind.NotSet
    clearFields(message, [6, 1, 2, 3, 4, 5, 7, 8])

proc hasscore*(message: DebugCommand): bool =
    result = hasField(message, 6)

proc setscore*(message: DebugCommand, value: DebugSetScore) =
    if message.command.kind != DebugCommand_command_Kind.Score:
        message.command = DebugCommand_command_OneOf(kind: DebugCommand_command_Kind.Score, score: value)
    else:
        message.command.score = value
    setField(message, 6)
    clearFields(message, [1, 2, 3, 4, 5, 7, 8])

proc score*(message: DebugCommand): DebugSetScore {.inline.} =
    message.command.score

proc `score=`*(message: DebugCommand, value: DebugSetScore) {.inline.} =
    setscore(message, value)

proc clearendGame*(message: DebugCommand) =
    reset(message.command)
    message.command.kind = DebugCommand_command_Kind.NotSet
    clearFields(message, [7, 1, 2, 3, 4, 5, 6, 8])

proc hasendGame*(message: DebugCommand): bool =
    result = hasField(message, 7)

proc setendGame*(message: DebugCommand, value: DebugEndGame) =
    if message.command.kind != DebugCommand_command_Kind.EndGame:
        message.command = DebugCommand_command_OneOf(kind: DebugCommand_command_Kind.EndGame, endGame: value)
    else:
        message.command.endGame = value
    setField(message, 7)
    clearFields(message, [1, 2, 3, 4, 5, 6, 8])

proc endGame*(message: DebugCommand): DebugEndGame {.inline.} =
    message.command.endGame

proc `endGame=`*(message: DebugCommand, value: DebugEndGame) {.inline.} =
    setendGame(message, value)

proc clearunitValue*(message: DebugCommand) =
    reset(message.command)
    message.command.kind = DebugCommand_command_Kind.NotSet
    clearFields(message, [8, 1, 2, 3, 4, 5, 6, 7])

proc hasunitValue*(message: DebugCommand): bool =
    result = hasField(message, 8)

proc setunitValue*(message: DebugCommand, value: DebugSetUnitValue) =
    if message.command.kind != DebugCommand_command_Kind.UnitValue:
        message.command = DebugCommand_command_OneOf(kind: DebugCommand_command_Kind.UnitValue, unitValue: value)
    else:
        message.command.unitValue = value
    setField(message, 8)
    clearFields(message, [1, 2, 3, 4, 5, 6, 7])

proc unitValue*(message: DebugCommand): DebugSetUnitValue {.inline.} =
    message.command.unitValue

proc `unitValue=`*(message: DebugCommand, value: DebugSetUnitValue) {.inline.} =
    setunitValue(message, value)

proc `$`*(message: DebugCommand): string =
    runnableExamples:
        echo $DebugCommand
        echo fmt"{DebugCommand}"
        echo &"{DebugCommand}"
    var resultSeq: seq[string]
    if message.hasdraw:
        resultSeq.add(&"draw: {message.draw}")
    if message.hasgameState:
        resultSeq.add(&"gameState: {message.gameState}")
    if message.hascreateUnit:
        resultSeq.add(&"createUnit: {message.createUnit}")
    if message.haskillUnit:
        resultSeq.add(&"killUnit: {message.killUnit}")
    if message.hastestProcess:
        resultSeq.add(&"testProcess: {message.testProcess}")
    if message.hasscore:
        resultSeq.add(&"score: {message.score}")
    if message.hasendGame:
        resultSeq.add(&"endGame: {message.endGame}")
    if message.hasunitValue:
        resultSeq.add(&"unitValue: {message.unitValue}")
    result = resultSeq.join(", ")
    result = &"DebugCommand({result})"

proc sizeOfDebugCommand*(message: DebugCommand): uint64 =
    if hasdraw(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfDebugDraw(message.command.draw))
    if hasgameState(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfEnum[DebugGameState](message.command.gameState)
    if hascreateUnit(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfDebugCreateUnit(message.command.createUnit))
    if haskillUnit(message):
        result = result + sizeOfTag(4, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfDebugKillUnit(message.command.killUnit))
    if hastestProcess(message):
        result = result + sizeOfTag(5, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfDebugTestProcess(message.command.testProcess))
    if hasscore(message):
        result = result + sizeOfTag(6, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfDebugSetScore(message.command.score))
    if hasendGame(message):
        result = result + sizeOfTag(7, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfDebugEndGame(message.command.endGame))
    if hasunitValue(message):
        result = result + sizeOfTag(8, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfDebugSetUnitValue(message.command.unitValue))
    result = result + sizeOfUnknownFields(message)

proc writeDebugCommand*(stream: Stream, message: DebugCommand) =
    if hasdraw(message):
        writeMessage(stream, message.command.draw, 1)
    if hasgameState(message):
        protoWriteEnum(stream, message.command.gameState, 2)
    if hascreateUnit(message):
        writeMessage(stream, message.command.createUnit, 3)
    if haskillUnit(message):
        writeMessage(stream, message.command.killUnit, 4)
    if hastestProcess(message):
        writeMessage(stream, message.command.testProcess, 5)
    if hasscore(message):
        writeMessage(stream, message.command.score, 6)
    if hasendGame(message):
        writeMessage(stream, message.command.endGame, 7)
    if hasunitValue(message):
        writeMessage(stream, message.command.unitValue, 8)
    writeUnknownFields(stream, message)

proc readDebugCommand*(stream: Stream): DebugCommand =
    result = newDebugCommand()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setdraw(result, newDebugDraw(data))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setgameState(result, protoReadEnum[DebugGameState](stream))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setcreateUnit(result, newDebugCreateUnit(data))
        of 4:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setkillUnit(result, newDebugKillUnit(data))
        of 5:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            settestProcess(result, newDebugTestProcess(data))
        of 6:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setscore(result, newDebugSetScore(data))
        of 7:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setendGame(result, newDebugEndGame(data))
        of 8:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setunitValue(result, newDebugSetUnitValue(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: DebugCommand): string =
    let
        ss = newStringStream()
    writeDebugCommand(ss, message)
    result = ss.data

proc newDebugCommand*(data: string): DebugCommand =
    let
        ss = newStringStream(data)
    result = readDebugCommand(ss)

proc newDebugCommand*(data: seq[byte]): DebugCommand =
    let
        ss = newStringStream(cast[string](data))
    result = readDebugCommand(ss)


