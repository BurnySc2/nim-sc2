# Generated by protoc_gen_nim. Do not edit!

import base64
import intsets
import json
import strutils

import nimpb/nimpb
import nimpb/json as nimpb_json

type
    Race* {.pure.} = enum
        NoRace = 0
        Terran = 1
        Zerg = 2
        Protoss = 3
        Random = 4
    AvailableAbility* = ref AvailableAbilityObj
    AvailableAbilityObj* = object of Message
        abilityId: int32
        requiresPoint: bool
    ImageData* = ref ImageDataObj
    ImageDataObj* = object of Message
        bitsPerPixel: int32
        size: Size2DI
        data: seq[byte]
    PointI* = ref PointIObj
    PointIObj* = object of Message
        x: int32
        y: int32
    RectangleI* = ref RectangleIObj
    RectangleIObj* = object of Message
        p0: PointI
        p1: PointI
    Point2D* = ref Point2DObj
    Point2DObj* = object of Message
        x: float32
        y: float32
    Point* = ref PointObj
    PointObj* = object of Message
        x: float32
        y: float32
        z: float32
    Size2DI* = ref Size2DIObj
    Size2DIObj* = object of Message
        x: int32
        y: int32

proc newPointI*(): PointI
proc newPointI*(data: string): PointI
proc newPointI*(data: seq[byte]): PointI
proc writePointI*(stream: Stream, message: PointI)
proc readPointI*(stream: Stream): PointI
proc sizeOfPointI*(message: PointI): uint64

proc newRectangleI*(): RectangleI
proc newRectangleI*(data: string): RectangleI
proc newRectangleI*(data: seq[byte]): RectangleI
proc writeRectangleI*(stream: Stream, message: RectangleI)
proc readRectangleI*(stream: Stream): RectangleI
proc sizeOfRectangleI*(message: RectangleI): uint64

proc newAvailableAbility*(): AvailableAbility
proc newAvailableAbility*(data: string): AvailableAbility
proc newAvailableAbility*(data: seq[byte]): AvailableAbility
proc writeAvailableAbility*(stream: Stream, message: AvailableAbility)
proc readAvailableAbility*(stream: Stream): AvailableAbility
proc sizeOfAvailableAbility*(message: AvailableAbility): uint64

proc newPoint2D*(): Point2D
proc newPoint2D*(data: string): Point2D
proc newPoint2D*(data: seq[byte]): Point2D
proc writePoint2D*(stream: Stream, message: Point2D)
proc readPoint2D*(stream: Stream): Point2D
proc sizeOfPoint2D*(message: Point2D): uint64

proc newSize2DI*(): Size2DI
proc newSize2DI*(data: string): Size2DI
proc newSize2DI*(data: seq[byte]): Size2DI
proc writeSize2DI*(stream: Stream, message: Size2DI)
proc readSize2DI*(stream: Stream): Size2DI
proc sizeOfSize2DI*(message: Size2DI): uint64

proc newImageData*(): ImageData
proc newImageData*(data: string): ImageData
proc newImageData*(data: seq[byte]): ImageData
proc writeImageData*(stream: Stream, message: ImageData)
proc readImageData*(stream: Stream): ImageData
proc sizeOfImageData*(message: ImageData): uint64

proc newPoint*(): Point
proc newPoint*(data: string): Point
proc newPoint*(data: seq[byte]): Point
proc writePoint*(stream: Stream, message: Point)
proc readPoint*(stream: Stream): Point
proc sizeOfPoint*(message: Point): uint64

proc fullyQualifiedName*(T: typedesc[PointI]): string = "PointI"

proc readPointIImpl(stream: Stream): Message = readPointI(stream)
proc writePointIImpl(stream: Stream, msg: Message) = writePointI(stream, PointI(msg))

proc PointIProcs*(): MessageProcs =
    result.readImpl = readPointIImpl
    result.writeImpl = writePointIImpl

proc newPointI*(): PointI =
    new(result)
    initMessage(result[])
    result.procs = PointIProcs()
    result.x = 0
    result.y = 0

proc clearx*(message: PointI) =
    message.x = 0
    clearFields(message, [1])

proc hasx*(message: PointI): bool =
    result = hasField(message, 1)

proc setx*(message: PointI, value: int32) =
    message.x = value
    setField(message, 1)

proc x*(message: PointI): int32 {.inline.} =
    message.x

proc `x=`*(message: PointI, value: int32) {.inline.} =
    setx(message, value)

proc cleary*(message: PointI) =
    message.y = 0
    clearFields(message, [2])

proc hasy*(message: PointI): bool =
    result = hasField(message, 2)

proc sety*(message: PointI, value: int32) =
    message.y = value
    setField(message, 2)

proc y*(message: PointI): int32 {.inline.} =
    message.y

proc `y=`*(message: PointI, value: int32) {.inline.} =
    sety(message, value)

proc sizeOfPointI*(message: PointI): uint64 =
    if hasx(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfInt32(message.x)
    if hasy(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfInt32(message.y)
    result = result + sizeOfUnknownFields(message)

proc writePointI*(stream: Stream, message: PointI) =
    if hasx(message):
        protoWriteInt32(stream, message.x, 1)
    if hasy(message):
        protoWriteInt32(stream, message.y, 2)
    writeUnknownFields(stream, message)

proc readPointI*(stream: Stream): PointI =
    result = newPointI()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setx(result, protoReadInt32(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            sety(result, protoReadInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: PointI): string =
    let
        ss = newStringStream()
    writePointI(ss, message)
    result = ss.data

proc newPointI*(data: string): PointI =
    let
        ss = newStringStream(data)
    result = readPointI(ss)

proc newPointI*(data: seq[byte]): PointI =
    let
        ss = newStringStream(cast[string](data))
    result = readPointI(ss)


proc fullyQualifiedName*(T: typedesc[RectangleI]): string = "RectangleI"

proc readRectangleIImpl(stream: Stream): Message = readRectangleI(stream)
proc writeRectangleIImpl(stream: Stream, msg: Message) = writeRectangleI(stream, RectangleI(msg))

proc RectangleIProcs*(): MessageProcs =
    result.readImpl = readRectangleIImpl
    result.writeImpl = writeRectangleIImpl

proc newRectangleI*(): RectangleI =
    new(result)
    initMessage(result[])
    result.procs = RectangleIProcs()
    result.p0 = nil
    result.p1 = nil

proc clearp0*(message: RectangleI) =
    message.p0 = nil
    clearFields(message, [1])

proc hasp0*(message: RectangleI): bool =
    result = hasField(message, 1)

proc setp0*(message: RectangleI, value: PointI) =
    message.p0 = value
    setField(message, 1)

proc p0*(message: RectangleI): PointI {.inline.} =
    message.p0

proc `p0=`*(message: RectangleI, value: PointI) {.inline.} =
    setp0(message, value)

proc clearp1*(message: RectangleI) =
    message.p1 = nil
    clearFields(message, [2])

proc hasp1*(message: RectangleI): bool =
    result = hasField(message, 2)

proc setp1*(message: RectangleI, value: PointI) =
    message.p1 = value
    setField(message, 2)

proc p1*(message: RectangleI): PointI {.inline.} =
    message.p1

proc `p1=`*(message: RectangleI, value: PointI) {.inline.} =
    setp1(message, value)

proc sizeOfRectangleI*(message: RectangleI): uint64 =
    if hasp0(message):
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPointI(message.p0))
    if hasp1(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfPointI(message.p1))
    result = result + sizeOfUnknownFields(message)

proc writeRectangleI*(stream: Stream, message: RectangleI) =
    if hasp0(message):
        writeMessage(stream, message.p0, 1)
    if hasp1(message):
        writeMessage(stream, message.p1, 2)
    writeUnknownFields(stream, message)

proc readRectangleI*(stream: Stream): RectangleI =
    result = newRectangleI()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setp0(result, newPointI(data))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setp1(result, newPointI(data))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: RectangleI): string =
    let
        ss = newStringStream()
    writeRectangleI(ss, message)
    result = ss.data

proc newRectangleI*(data: string): RectangleI =
    let
        ss = newStringStream(data)
    result = readRectangleI(ss)

proc newRectangleI*(data: seq[byte]): RectangleI =
    let
        ss = newStringStream(cast[string](data))
    result = readRectangleI(ss)


proc fullyQualifiedName*(T: typedesc[AvailableAbility]): string = "AvailableAbility"

proc readAvailableAbilityImpl(stream: Stream): Message = readAvailableAbility(stream)
proc writeAvailableAbilityImpl(stream: Stream, msg: Message) = writeAvailableAbility(stream, AvailableAbility(msg))

proc AvailableAbilityProcs*(): MessageProcs =
    result.readImpl = readAvailableAbilityImpl
    result.writeImpl = writeAvailableAbilityImpl

proc newAvailableAbility*(): AvailableAbility =
    new(result)
    initMessage(result[])
    result.procs = AvailableAbilityProcs()
    result.abilityId = 0
    result.requiresPoint = false

proc clearabilityId*(message: AvailableAbility) =
    message.abilityId = 0
    clearFields(message, [1])

proc hasabilityId*(message: AvailableAbility): bool =
    result = hasField(message, 1)

proc setabilityId*(message: AvailableAbility, value: int32) =
    message.abilityId = value
    setField(message, 1)

proc abilityId*(message: AvailableAbility): int32 {.inline.} =
    message.abilityId

proc `abilityId=`*(message: AvailableAbility, value: int32) {.inline.} =
    setabilityId(message, value)

proc clearrequiresPoint*(message: AvailableAbility) =
    message.requiresPoint = false
    clearFields(message, [2])

proc hasrequiresPoint*(message: AvailableAbility): bool =
    result = hasField(message, 2)

proc setrequiresPoint*(message: AvailableAbility, value: bool) =
    message.requiresPoint = value
    setField(message, 2)

proc requiresPoint*(message: AvailableAbility): bool {.inline.} =
    message.requiresPoint

proc `requiresPoint=`*(message: AvailableAbility, value: bool) {.inline.} =
    setrequiresPoint(message, value)

proc sizeOfAvailableAbility*(message: AvailableAbility): uint64 =
    if hasabilityId(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfInt32(message.abilityId)
    if hasrequiresPoint(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfBool(message.requiresPoint)
    result = result + sizeOfUnknownFields(message)

proc writeAvailableAbility*(stream: Stream, message: AvailableAbility) =
    if hasabilityId(message):
        protoWriteInt32(stream, message.abilityId, 1)
    if hasrequiresPoint(message):
        protoWriteBool(stream, message.requiresPoint, 2)
    writeUnknownFields(stream, message)

proc readAvailableAbility*(stream: Stream): AvailableAbility =
    result = newAvailableAbility()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setabilityId(result, protoReadInt32(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            setrequiresPoint(result, protoReadBool(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: AvailableAbility): string =
    let
        ss = newStringStream()
    writeAvailableAbility(ss, message)
    result = ss.data

proc newAvailableAbility*(data: string): AvailableAbility =
    let
        ss = newStringStream(data)
    result = readAvailableAbility(ss)

proc newAvailableAbility*(data: seq[byte]): AvailableAbility =
    let
        ss = newStringStream(cast[string](data))
    result = readAvailableAbility(ss)


proc fullyQualifiedName*(T: typedesc[Point2D]): string = "Point2D"

proc readPoint2DImpl(stream: Stream): Message = readPoint2D(stream)
proc writePoint2DImpl(stream: Stream, msg: Message) = writePoint2D(stream, Point2D(msg))

proc Point2DProcs*(): MessageProcs =
    result.readImpl = readPoint2DImpl
    result.writeImpl = writePoint2DImpl

proc newPoint2D*(): Point2D =
    new(result)
    initMessage(result[])
    result.procs = Point2DProcs()
    result.x = 0
    result.y = 0

proc clearx*(message: Point2D) =
    message.x = 0
    clearFields(message, [1])

proc hasx*(message: Point2D): bool =
    result = hasField(message, 1)

proc setx*(message: Point2D, value: float32) =
    message.x = value
    setField(message, 1)

proc x*(message: Point2D): float32 {.inline.} =
    message.x

proc `x=`*(message: Point2D, value: float32) {.inline.} =
    setx(message, value)

proc cleary*(message: Point2D) =
    message.y = 0
    clearFields(message, [2])

proc hasy*(message: Point2D): bool =
    result = hasField(message, 2)

proc sety*(message: Point2D, value: float32) =
    message.y = value
    setField(message, 2)

proc y*(message: Point2D): float32 {.inline.} =
    message.y

proc `y=`*(message: Point2D, value: float32) {.inline.} =
    sety(message, value)

proc sizeOfPoint2D*(message: Point2D): uint64 =
    if hasx(message):
        result = result + sizeOfTag(1, WireType.Fixed32)
        result = result + sizeOfFloat(message.x)
    if hasy(message):
        result = result + sizeOfTag(2, WireType.Fixed32)
        result = result + sizeOfFloat(message.y)
    result = result + sizeOfUnknownFields(message)

proc writePoint2D*(stream: Stream, message: Point2D) =
    if hasx(message):
        protoWriteFloat(stream, message.x, 1)
    if hasy(message):
        protoWriteFloat(stream, message.y, 2)
    writeUnknownFields(stream, message)

proc readPoint2D*(stream: Stream): Point2D =
    result = newPoint2D()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Fixed32)
            setx(result, protoReadFloat(stream))
        of 2:
            expectWireType(wireType, WireType.Fixed32)
            sety(result, protoReadFloat(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: Point2D): string =
    let
        ss = newStringStream()
    writePoint2D(ss, message)
    result = ss.data

proc newPoint2D*(data: string): Point2D =
    let
        ss = newStringStream(data)
    result = readPoint2D(ss)

proc newPoint2D*(data: seq[byte]): Point2D =
    let
        ss = newStringStream(cast[string](data))
    result = readPoint2D(ss)


proc fullyQualifiedName*(T: typedesc[Size2DI]): string = "Size2DI"

proc readSize2DIImpl(stream: Stream): Message = readSize2DI(stream)
proc writeSize2DIImpl(stream: Stream, msg: Message) = writeSize2DI(stream, Size2DI(msg))

proc Size2DIProcs*(): MessageProcs =
    result.readImpl = readSize2DIImpl
    result.writeImpl = writeSize2DIImpl

proc newSize2DI*(): Size2DI =
    new(result)
    initMessage(result[])
    result.procs = Size2DIProcs()
    result.x = 0
    result.y = 0

proc clearx*(message: Size2DI) =
    message.x = 0
    clearFields(message, [1])

proc hasx*(message: Size2DI): bool =
    result = hasField(message, 1)

proc setx*(message: Size2DI, value: int32) =
    message.x = value
    setField(message, 1)

proc x*(message: Size2DI): int32 {.inline.} =
    message.x

proc `x=`*(message: Size2DI, value: int32) {.inline.} =
    setx(message, value)

proc cleary*(message: Size2DI) =
    message.y = 0
    clearFields(message, [2])

proc hasy*(message: Size2DI): bool =
    result = hasField(message, 2)

proc sety*(message: Size2DI, value: int32) =
    message.y = value
    setField(message, 2)

proc y*(message: Size2DI): int32 {.inline.} =
    message.y

proc `y=`*(message: Size2DI, value: int32) {.inline.} =
    sety(message, value)

proc sizeOfSize2DI*(message: Size2DI): uint64 =
    if hasx(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfInt32(message.x)
    if hasy(message):
        result = result + sizeOfTag(2, WireType.Varint)
        result = result + sizeOfInt32(message.y)
    result = result + sizeOfUnknownFields(message)

proc writeSize2DI*(stream: Stream, message: Size2DI) =
    if hasx(message):
        protoWriteInt32(stream, message.x, 1)
    if hasy(message):
        protoWriteInt32(stream, message.y, 2)
    writeUnknownFields(stream, message)

proc readSize2DI*(stream: Stream): Size2DI =
    result = newSize2DI()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setx(result, protoReadInt32(stream))
        of 2:
            expectWireType(wireType, WireType.Varint)
            sety(result, protoReadInt32(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: Size2DI): string =
    let
        ss = newStringStream()
    writeSize2DI(ss, message)
    result = ss.data

proc newSize2DI*(data: string): Size2DI =
    let
        ss = newStringStream(data)
    result = readSize2DI(ss)

proc newSize2DI*(data: seq[byte]): Size2DI =
    let
        ss = newStringStream(cast[string](data))
    result = readSize2DI(ss)


proc fullyQualifiedName*(T: typedesc[ImageData]): string = "ImageData"

proc readImageDataImpl(stream: Stream): Message = readImageData(stream)
proc writeImageDataImpl(stream: Stream, msg: Message) = writeImageData(stream, ImageData(msg))

proc ImageDataProcs*(): MessageProcs =
    result.readImpl = readImageDataImpl
    result.writeImpl = writeImageDataImpl

proc newImageData*(): ImageData =
    new(result)
    initMessage(result[])
    result.procs = ImageDataProcs()
    result.bitsPerPixel = 0
    result.size = nil
    result.data = @[]

proc clearbitsPerPixel*(message: ImageData) =
    message.bitsPerPixel = 0
    clearFields(message, [1])

proc hasbitsPerPixel*(message: ImageData): bool =
    result = hasField(message, 1)

proc setbitsPerPixel*(message: ImageData, value: int32) =
    message.bitsPerPixel = value
    setField(message, 1)

proc bitsPerPixel*(message: ImageData): int32 {.inline.} =
    message.bitsPerPixel

proc `bitsPerPixel=`*(message: ImageData, value: int32) {.inline.} =
    setbitsPerPixel(message, value)

proc clearsize*(message: ImageData) =
    message.size = nil
    clearFields(message, [2])

proc hassize*(message: ImageData): bool =
    result = hasField(message, 2)

proc setsize*(message: ImageData, value: Size2DI) =
    message.size = value
    setField(message, 2)

proc size*(message: ImageData): Size2DI {.inline.} =
    message.size

proc `size=`*(message: ImageData, value: Size2DI) {.inline.} =
    setsize(message, value)

proc cleardata*(message: ImageData) =
    message.data = @[]
    clearFields(message, [3])

proc hasdata*(message: ImageData): bool =
    result = hasField(message, 3)

proc setdata*(message: ImageData, value: seq[byte]) =
    message.data = value
    setField(message, 3)

proc data*(message: ImageData): seq[byte] {.inline.} =
    message.data

proc `data=`*(message: ImageData, value: seq[byte]) {.inline.} =
    setdata(message, value)

proc sizeOfImageData*(message: ImageData): uint64 =
    if hasbitsPerPixel(message):
        result = result + sizeOfTag(1, WireType.Varint)
        result = result + sizeOfInt32(message.bitsPerPixel)
    if hassize(message):
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfLengthDelimited(sizeOfSize2DI(message.size))
    if hasdata(message):
        result = result + sizeOfTag(3, WireType.LengthDelimited)
        result = result + sizeOfBytes(message.data)
    result = result + sizeOfUnknownFields(message)

proc writeImageData*(stream: Stream, message: ImageData) =
    if hasbitsPerPixel(message):
        protoWriteInt32(stream, message.bitsPerPixel, 1)
    if hassize(message):
        writeMessage(stream, message.size, 2)
    if hasdata(message):
        protoWriteBytes(stream, message.data, 3)
    writeUnknownFields(stream, message)

proc readImageData*(stream: Stream): ImageData =
    result = newImageData()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Varint)
            setbitsPerPixel(result, protoReadInt32(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            let data = readLengthDelimited(stream)
            setsize(result, newSize2DI(data))
        of 3:
            expectWireType(wireType, WireType.LengthDelimited)
            setdata(result, protoReadBytes(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: ImageData): string =
    let
        ss = newStringStream()
    writeImageData(ss, message)
    result = ss.data

proc newImageData*(data: string): ImageData =
    let
        ss = newStringStream(data)
    result = readImageData(ss)

proc newImageData*(data: seq[byte]): ImageData =
    let
        ss = newStringStream(cast[string](data))
    result = readImageData(ss)


proc fullyQualifiedName*(T: typedesc[Point]): string = "Point"

proc readPointImpl(stream: Stream): Message = readPoint(stream)
proc writePointImpl(stream: Stream, msg: Message) = writePoint(stream, Point(msg))

proc PointProcs*(): MessageProcs =
    result.readImpl = readPointImpl
    result.writeImpl = writePointImpl

proc newPoint*(): Point =
    new(result)
    initMessage(result[])
    result.procs = PointProcs()
    result.x = 0
    result.y = 0
    result.z = 0

proc clearx*(message: Point) =
    message.x = 0
    clearFields(message, [1])

proc hasx*(message: Point): bool =
    result = hasField(message, 1)

proc setx*(message: Point, value: float32) =
    message.x = value
    setField(message, 1)

proc x*(message: Point): float32 {.inline.} =
    message.x

proc `x=`*(message: Point, value: float32) {.inline.} =
    setx(message, value)

proc cleary*(message: Point) =
    message.y = 0
    clearFields(message, [2])

proc hasy*(message: Point): bool =
    result = hasField(message, 2)

proc sety*(message: Point, value: float32) =
    message.y = value
    setField(message, 2)

proc y*(message: Point): float32 {.inline.} =
    message.y

proc `y=`*(message: Point, value: float32) {.inline.} =
    sety(message, value)

proc clearz*(message: Point) =
    message.z = 0
    clearFields(message, [3])

proc hasz*(message: Point): bool =
    result = hasField(message, 3)

proc setz*(message: Point, value: float32) =
    message.z = value
    setField(message, 3)

proc z*(message: Point): float32 {.inline.} =
    message.z

proc `z=`*(message: Point, value: float32) {.inline.} =
    setz(message, value)

proc sizeOfPoint*(message: Point): uint64 =
    if hasx(message):
        result = result + sizeOfTag(1, WireType.Fixed32)
        result = result + sizeOfFloat(message.x)
    if hasy(message):
        result = result + sizeOfTag(2, WireType.Fixed32)
        result = result + sizeOfFloat(message.y)
    if hasz(message):
        result = result + sizeOfTag(3, WireType.Fixed32)
        result = result + sizeOfFloat(message.z)
    result = result + sizeOfUnknownFields(message)

proc writePoint*(stream: Stream, message: Point) =
    if hasx(message):
        protoWriteFloat(stream, message.x, 1)
    if hasy(message):
        protoWriteFloat(stream, message.y, 2)
    if hasz(message):
        protoWriteFloat(stream, message.z, 3)
    writeUnknownFields(stream, message)

proc readPoint*(stream: Stream): Point =
    result = newPoint()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.Fixed32)
            setx(result, protoReadFloat(stream))
        of 2:
            expectWireType(wireType, WireType.Fixed32)
            sety(result, protoReadFloat(stream))
        of 3:
            expectWireType(wireType, WireType.Fixed32)
            setz(result, protoReadFloat(stream))
        else: readUnknownField(stream, result, tag)

proc serialize*(message: Point): string =
    let
        ss = newStringStream()
    writePoint(ss, message)
    result = ss.data

proc newPoint*(data: string): Point =
    let
        ss = newStringStream(data)
    result = readPoint(ss)

proc newPoint*(data: seq[byte]): Point =
    let
        ss = newStringStream(cast[string](data))
    result = readPoint(ss)


